<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++简要知识点</title>
    <url>/2021/04/27/C-%E7%AE%80%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>C++简要知识点</p>
<h2><span id="左值与右值">左值与右值</span></h2><p>左值 (lvalue, locator value) 表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。<br>右值 (rvalue) 则使用排除法来定义。一个表达式不是 左值 就是 右值 。 那么，右值是一个 不 表示内存中某个可识别位置的对象的表达式。</p>
<ul>
<li>需要一个右值参数，但返回一个左值结果<pre class="line-numbers language-none"><code class="language-none">int arr[] &#x3D; &#123;1, 2&#125;;
int* p &#x3D; &amp;arr[0];
*(p + 1) &#x3D; 10;   &#x2F;&#x2F; 正确: p + 1 是右值，但 *(p + 1) 是左值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
&amp; 需要一个左值参数，返回一个右值<pre class="line-numbers language-none"><code class="language-none">int var &#x3D; 10;
int* bad_addr &#x3D; &amp;(var + 1); &#x2F;&#x2F; 错误: 一元 &#39;&amp;&#39; 操作符需要左值参数
int* addr &#x3D; &amp;var;           &#x2F;&#x2F; 正确: var 是左值
&amp;var &#x3D; 40;                  &#x2F;&#x2F; 错误: 赋值操作的左操作数需要是左值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="emplace_back">emplace_back</span></h2>emplace_back只调用构造函数，没有移动构造函数，也没有拷贝构造函数。<h2><span id="move">move()</span></h2>移动所做的事情取决于移动构造函数和移动赋值函数的实现。对大多数 STL 容器来说，所做的事情就是两件：进行浅拷贝；拷贝完之后将源对象中的指针置为 nullptr，防止其被释放。<br>因此 vector 内部的指针是被直接移走的，并且不会调用元素类型的移动赋值函数，地址一样。<h2><span id="count">count</span></h2>map和set两种容器的底层结构都是红黑树，所以容器中不会出现相同的元素，因此count()的结果只能为0和1，可以以此来判断键值元素是否存在(当然也可以使用find()方法判断键值是否存在)。<br>拿map&lt; key,value &gt;举例，find()方法返回值是一个迭代器，成功返回迭代器指向要查找的元素，失败返回的迭代器指向end。count()方法返回值是一个整数，1表示有这个元素，0表示没有这个元素。<h2><span id="map">map[]</span></h2>map的下标操作符[]使用上面的方法定义，<br>使向map里插入值和使用关键码来访问相应的值变得非常方便而快速。<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; accessing mapped values
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

int main ()
&#123;
  std::map&lt;char,std::string&gt; mymap;

  mymap[&#39;a&#39;]&#x3D;&quot;an element&quot;;
  mymap[&#39;b&#39;]&#x3D;&quot;another element&quot;;
  mymap[&#39;c&#39;]&#x3D;mymap[&#39;b&#39;];

  std::cout &lt;&lt; &quot;mymap[&#39;a&#39;] is &quot; &lt;&lt; mymap[&#39;a&#39;] &lt;&lt; &#39;\n&#39;;
  std::cout &lt;&lt; &quot;mymap[&#39;b&#39;] is &quot; &lt;&lt; mymap[&#39;b&#39;] &lt;&lt; &#39;\n&#39;;
  std::cout &lt;&lt; &quot;mymap[&#39;c&#39;] is &quot; &lt;&lt; mymap[&#39;c&#39;] &lt;&lt; &#39;\n&#39;;
  std::cout &lt;&lt; &quot;mymap[&#39;d&#39;] is &quot; &lt;&lt; mymap[&#39;d&#39;] &lt;&lt; &#39;\n&#39;;

  std::cout &lt;&lt; &quot;mymap now contains &quot; &lt;&lt; mymap.size() &lt;&lt; &quot; elements.\n&quot;;

  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
mymap[‘a’] is an element<br>mymap[‘b’] is another element<br>mymap[‘c’] is another element<br>mymap[‘d’] is<br>mymap now contains 4 elements</li>
</ul>
<h2><span id="字符串长度计算">字符串长度计算</span></h2><p>在这里我提供四种方法计算字符串的长度:</p>
<p>1.使用递归函数。</p>
<p>2.数数，从第一个字符开始数数，没遇到一个字符，长度加一，直到遇到”\0”,停止数数。</p>
<p>3.使用strlen函数，使用此函数时，需包含头文件 include &lt; string.h &gt;  </p>
<p>4.使用sizeof，对于字符串，一定要减去1，因为字符数组的末尾有一个”\0”，size=sizeof(str)/sizeof(str[0])</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++进阶笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Birthday</title>
    <url>/2021/03/12/birthday/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>小鸡长大了就变成了鹅，<br>鹅长大了，就变成了羊，<br>羊再长大了，就变成了牛，<br>等牛长大了，我就成为了独当一面的人了。。</p>
<p>开始怀念18岁以前的日子，无知，幼稚，冲动，但爱的人，在乎的人却是触手可及。<br>如今，感叹爱我的人一点点变老，愿时间走的慢一些，愿家人健康。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>小杨的编程之路</title>
    <url>/2021/02/01/hello/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="/download/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89.pdf">mysql第三版</a></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1804380596&auto=1&height=66"></iframe><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>冲呀</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo上传github</title>
    <url>/2021/06/09/hexo%E4%B8%8A%E4%BC%A0github/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>当初小白，辖研究终于搞定了hexo上传github。今天发表文章的时候，github<br>官方提醒我输入密码上传的服务在8/31号之后终止。慌的一笔，只好研究怎么可以不用密码，直接用电脑生成的密钥进行上传。所有操作均是在虚拟机ubuntu系统上完成。</p>
<p>打开终端</p>
<pre class="line-numbers language-none"><code class="language-none">$ cd ~&#x2F;.ssh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用 ssh-keygen 生成密钥</p>
<pre class="line-numbers language-none"><code class="language-none">$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里设定密码两次</p>
<pre class="line-numbers language-none"><code class="language-none">Enter passphrase (empty for no passphrase): [Type a passphrase]
Enter same passphrase again: [Type passphrase again]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>密钥生成成功</p>
<pre class="line-numbers language-none"><code class="language-none">Your identification has been saved in &#x2F;home&#x2F;you&#x2F;.ssh&#x2F;id_rsa.
Your public key has been saved in &#x2F;home&#x2F;you&#x2F;.ssh&#x2F;id_rsa.pub.
The key fingerprint is:
…………………此处是密钥内容…………………… your_email@example.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>进入自己的github网站<br>首页菜单栏中点击 Settings –&gt; SSH and GPG keys –&gt; Add SSH key，然后将生成的 id_rsa.pub 中的内容全选复制到 key 输入框中，然后点击 Add key 完成添加公钥。</p>
<p>这里如果要查看自己的私钥进行下列操作</p>
<pre class="line-numbers language-none"><code class="language-none">cd ~&#x2F;.ssh
ls
cat id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>将命令后显示的内容全部复制到add key的页面框内即可。</p>
<p>测试配置是否成功</p>
<pre class="line-numbers language-none"><code class="language-none">$ ssh -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>更改hexo 配置文件</p>
<pre class="line-numbers language-none"><code class="language-none">deploy:
  type: &#39;git&#39;
  repository: git@github.com:YXY996&#x2F;yxy996.github.io.git
  branch: main
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>大功告成，撒花。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Qlearning</title>
    <url>/2021/02/22/Qlearning/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="qlearning">Qlearning</span></h2><p>QLearning是强化学习算法中value-based的算法，Q即为Q（s,a）就是在某一时刻的 s 状态下(s∈S)，采取 动作a (a∈A)动作能够获得收益的期望，环境会根据agent的动作反馈相应的回报reward r，所以算法的主要思想就是将State与Action构建成一张Q-table来存储Q值，然后根据Q值来选取能够获得最大的收益的动作。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt
<span class="token operator">%</span>matplotlib inline<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
ax <span class="token operator">=</span> plt<span class="token punctuation">.</span>gca<span class="token punctuation">(</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>color <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">,</span>linewidth<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>color <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">,</span>linewidth<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>color <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">,</span>linewidth<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>color <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">,</span>linewidth<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>

plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">2.5</span><span class="token punctuation">,</span><span class="token string">'s0'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">1.5</span><span class="token punctuation">,</span><span class="token number">2.5</span><span class="token punctuation">,</span><span class="token string">'s1'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">2.5</span><span class="token punctuation">,</span><span class="token number">2.5</span><span class="token punctuation">,</span><span class="token string">'s2'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">1.5</span><span class="token punctuation">,</span><span class="token string">'s3'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">1.5</span><span class="token punctuation">,</span><span class="token number">1.5</span><span class="token punctuation">,</span><span class="token string">'s4'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">2.5</span><span class="token punctuation">,</span><span class="token number">1.5</span><span class="token punctuation">,</span><span class="token string">'s5'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token string">'s6'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">1.5</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token string">'s7'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">2.5</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token string">'s8'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">2.3</span><span class="token punctuation">,</span><span class="token string">'Start'</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">2.5</span><span class="token punctuation">,</span><span class="token number">0.3</span><span class="token punctuation">,</span><span class="token string">'goal'</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>

ax<span class="token punctuation">.</span>set_xlim<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
ax<span class="token punctuation">.</span>set_ylim<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>tick_params<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token string">'both'</span><span class="token punctuation">,</span>which<span class="token operator">=</span><span class="token string">'both'</span><span class="token punctuation">,</span>bottom<span class="token operator">=</span><span class="token string">'off'</span><span class="token punctuation">,</span>top<span class="token operator">=</span><span class="token string">'off'</span><span class="token punctuation">,</span>labelbottom<span class="token operator">=</span><span class="token string">'off'</span><span class="token punctuation">,</span>right<span class="token operator">=</span><span class="token string">'off'</span><span class="token punctuation">,</span>left<span class="token operator">=</span><span class="token string">'off'</span><span class="token punctuation">,</span>labelleft<span class="token operator">=</span><span class="token string">'off'</span><span class="token punctuation">)</span>

line<span class="token punctuation">,</span> <span class="token operator">=</span> ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>marker<span class="token operator">=</span><span class="token string">"o"</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">"g"</span><span class="token punctuation">,</span>markersize<span class="token operator">=</span><span class="token number">60</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/image/output_1_0.png" alt="png"></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">theta_0 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 初期设定数组 数组的行列的设定值与 theta_0相同</span>
<span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> theta_0<span class="token punctuation">.</span>shape
<span class="token comment"># np.random.rand()使用这个函数可以返回一个或者一组服从“0-1”均匀分布的随机样品值</span>
Q <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token operator">*</span>theta_0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">simple_convert_pi_from_theta</span><span class="token punctuation">(</span>theta<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token punctuation">[</span>m<span class="token punctuation">,</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> theta<span class="token punctuation">.</span>shape
    pi <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>
        pi<span class="token punctuation">[</span>i<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> theta<span class="token punctuation">[</span>i<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">/</span>np<span class="token punctuation">.</span>nansum<span class="token punctuation">(</span>theta<span class="token punctuation">[</span>i<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    pi <span class="token operator">=</span> np<span class="token punctuation">.</span>nan_to_num<span class="token punctuation">(</span>pi<span class="token punctuation">)</span>
    <span class="token keyword">return</span> pi
pi_0 <span class="token operator">=</span> simple_convert_pi_from_theta<span class="token punctuation">(</span>theta_0<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_action</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>Q<span class="token punctuation">,</span>epsilon<span class="token punctuation">,</span>pi_0<span class="token punctuation">)</span><span class="token punctuation">:</span>
    direction <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"up"</span><span class="token punctuation">,</span><span class="token string">"right"</span><span class="token punctuation">,</span><span class="token string">"down"</span><span class="token punctuation">,</span><span class="token string">"left"</span><span class="token punctuation">]</span>
    <span class="token keyword">if</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>epsilon<span class="token punctuation">:</span>
        next_direction  <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>direction<span class="token punctuation">,</span>p <span class="token operator">=</span> pi_0<span class="token punctuation">[</span>s<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token comment"># np.nanargmax 是求配列中最大值的方法 这个把nan忽视掉</span>
        <span class="token comment"># 如果是np.argmax 的话nan是当作最大值</span>
        next_direction <span class="token operator">=</span> direction<span class="token punctuation">[</span>np<span class="token punctuation">.</span>nanargmax<span class="token punctuation">(</span>Q<span class="token punctuation">[</span>s<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment">#这里求的是最大值的索引</span>

    <span class="token keyword">if</span> next_direction <span class="token operator">==</span> <span class="token string">"up"</span><span class="token punctuation">:</span>
        action <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">elif</span> next_direction <span class="token operator">==</span> <span class="token string">"right"</span><span class="token punctuation">:</span>
        action  <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">elif</span> next_direction <span class="token operator">==</span> <span class="token string">"down"</span><span class="token punctuation">:</span>
        action <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token keyword">elif</span> next_direction <span class="token operator">==</span> <span class="token string">"left"</span><span class="token punctuation">:</span>
        action <span class="token operator">=</span> <span class="token number">3</span>
    <span class="token keyword">return</span> action
<span class="token keyword">def</span> <span class="token function">get_s_next</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>a<span class="token punctuation">,</span>Q<span class="token punctuation">,</span>epsilon<span class="token punctuation">,</span>pi_0<span class="token punctuation">)</span><span class="token punctuation">:</span>
    direction <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"up"</span><span class="token punctuation">,</span><span class="token string">"right"</span><span class="token punctuation">,</span><span class="token string">"down"</span><span class="token punctuation">,</span><span class="token string">"left"</span><span class="token punctuation">]</span>
    next_direction <span class="token operator">=</span> direction<span class="token punctuation">[</span>a<span class="token punctuation">]</span>
    <span class="token keyword">if</span> next_direction <span class="token operator">==</span> <span class="token string">"up"</span><span class="token punctuation">:</span>
        s_next <span class="token operator">=</span> s<span class="token operator">-</span><span class="token number">3</span>
    <span class="token keyword">elif</span> next_direction <span class="token operator">==</span> <span class="token string">"right"</span><span class="token punctuation">:</span>
        s_next <span class="token operator">=</span> s<span class="token operator">+</span><span class="token number">1</span>
    <span class="token keyword">elif</span> next_direction <span class="token operator">==</span> <span class="token string">"down"</span><span class="token punctuation">:</span>
        s_next <span class="token operator">=</span> s<span class="token operator">+</span><span class="token number">3</span>
    <span class="token keyword">elif</span> next_direction <span class="token operator">==</span> <span class="token string">"left"</span><span class="token punctuation">:</span>
        s_next <span class="token operator">=</span> s<span class="token operator">-</span><span class="token number">1</span>
    <span class="token keyword">return</span> s_next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">Q_learning</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>a<span class="token punctuation">,</span>r<span class="token punctuation">,</span>s_next<span class="token punctuation">,</span>Q<span class="token punctuation">,</span>eta<span class="token punctuation">,</span>gamma<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> s_next <span class="token operator">==</span> <span class="token number">8</span><span class="token punctuation">:</span>
        Q<span class="token punctuation">[</span>s<span class="token punctuation">,</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> Q<span class="token punctuation">[</span>s<span class="token punctuation">,</span>a<span class="token punctuation">]</span><span class="token operator">+</span>eta<span class="token operator">*</span><span class="token punctuation">(</span>r<span class="token operator">-</span>Q<span class="token punctuation">[</span>s<span class="token punctuation">,</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        Q<span class="token punctuation">[</span>s<span class="token punctuation">,</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> Q<span class="token punctuation">[</span>s<span class="token punctuation">,</span>a<span class="token punctuation">]</span><span class="token operator">+</span>eta<span class="token operator">*</span><span class="token punctuation">(</span>r<span class="token operator">+</span>gamma<span class="token operator">*</span>np<span class="token punctuation">.</span>nanmax<span class="token punctuation">(</span>Q<span class="token punctuation">[</span>s_next<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> Q<span class="token punctuation">[</span>s<span class="token punctuation">,</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token comment">#这里np.nanmaxQ[s_next,:]是取四个行动(0,1,2,3)中Q价值最大动作</span>
    <span class="token keyword">return</span> Q

<span class="token keyword">def</span> <span class="token function">goal_maze_ret_s_a_Q</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>epsilon<span class="token punctuation">,</span>eta<span class="token punctuation">,</span>gamma<span class="token punctuation">,</span>pi<span class="token punctuation">)</span><span class="token punctuation">:</span>
    s <span class="token operator">=</span> <span class="token number">0</span>
    a <span class="token operator">=</span> a_next <span class="token operator">=</span> get_action<span class="token punctuation">(</span>s<span class="token punctuation">,</span>Q<span class="token punctuation">,</span>epsilon<span class="token punctuation">,</span>pi<span class="token punctuation">)</span>
    s_a_history <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        a <span class="token operator">=</span> a_next
        <span class="token comment"># 将行动代入当前状态  当前s_a_history只有一个状态行动 代入行动 之后每次都对最后一次的状态进行操作</span>
        s_a_history<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a
        s_next <span class="token operator">=</span> get_s_next<span class="token punctuation">(</span>s<span class="token punctuation">,</span>a<span class="token punctuation">,</span>Q<span class="token punctuation">,</span>epsilon<span class="token punctuation">,</span>pi<span class="token punctuation">)</span>
        <span class="token comment"># 状态代入 行动不知道np.nan</span>
        s_a_history<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>s_next<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> s_next <span class="token operator">==</span><span class="token number">8</span><span class="token punctuation">:</span>
            <span class="token comment"># 到达终点报酬</span>
            r <span class="token operator">=</span><span class="token number">1</span>
            a_next <span class="token operator">=</span> np<span class="token punctuation">.</span>nan
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            r <span class="token operator">=</span><span class="token number">0</span>
            a_next <span class="token operator">=</span> get_action<span class="token punctuation">(</span>s_next<span class="token punctuation">,</span>Q<span class="token punctuation">,</span>epsilon<span class="token punctuation">,</span>pi<span class="token punctuation">)</span>

        <span class="token comment">#价值函数更新</span>
        Q <span class="token operator">=</span> Q_learning<span class="token punctuation">(</span>s<span class="token punctuation">,</span>a<span class="token punctuation">,</span>r<span class="token punctuation">,</span>s_next<span class="token punctuation">,</span>Q<span class="token punctuation">,</span>eta<span class="token punctuation">,</span>gamma<span class="token punctuation">)</span>
        <span class="token keyword">if</span> s_next <span class="token operator">==</span> <span class="token number">8</span><span class="token punctuation">:</span>
            <span class="token keyword">break</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            s <span class="token operator">=</span> s_next
    <span class="token keyword">return</span> <span class="token punctuation">[</span>s_a_history<span class="token punctuation">,</span>Q<span class="token punctuation">]</span> <span class="token comment"># 这里一定要注意缩进 条件语句之后执行结束后 将s_a_history输出</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> theta_0<span class="token punctuation">.</span>shape
Q <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">*</span>theta_0<span class="token operator">*</span> <span class="token number">0.1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 学习率eta 时间折旧gamma </span>
<span class="token comment"># ε-greedy 初期值0.5</span>
eta <span class="token operator">=</span> <span class="token number">0.1</span> 
gamma <span class="token operator">=</span> <span class="token number">0.9</span>
epsilon <span class="token operator">=</span> <span class="token number">0.5</span>
<span class="token comment"># 每个状态下价值Q的最大值</span>
v <span class="token operator">=</span> np<span class="token punctuation">.</span>nanmax<span class="token punctuation">(</span>Q<span class="token punctuation">,</span>axis <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
is_continue <span class="token operator">=</span> <span class="token boolean">True</span>
episode <span class="token operator">=</span><span class="token number">1</span>
V <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
V<span class="token punctuation">.</span>append<span class="token punctuation">(</span>np<span class="token punctuation">.</span>nanmax<span class="token punctuation">(</span>Q<span class="token punctuation">,</span>axis <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">while</span> is_continue<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"episode:"</span><span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>episode<span class="token punctuation">)</span><span class="token punctuation">)</span>

    epsilon <span class="token operator">=</span> epsilon<span class="token operator">/</span><span class="token number">2</span>   <span class="token comment">#epsilon越小说明随机选择概率越小 Q最大值选择概率越大</span>
    <span class="token punctuation">[</span>s_a_history<span class="token punctuation">,</span>Q<span class="token punctuation">]</span> <span class="token operator">=</span> goal_maze_ret_s_a_Q<span class="token punctuation">(</span>Q<span class="token punctuation">,</span>epsilon<span class="token punctuation">,</span>eta<span class="token punctuation">,</span>gamma<span class="token punctuation">,</span>pi_0<span class="token punctuation">)</span>
    new_v <span class="token operator">=</span> np<span class="token punctuation">.</span>nanmax<span class="token punctuation">(</span>Q<span class="token punctuation">,</span>axis <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span>new_v <span class="token operator">-</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    v <span class="token operator">=</span> new_v
    V<span class="token punctuation">.</span>append<span class="token punctuation">(</span>v<span class="token punctuation">)</span>

    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"迷路问题解决需要step"</span> <span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>s_a_history<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    episode <span class="token operator">=</span> episode <span class="token operator">+</span><span class="token number">1</span>
    <span class="token keyword">if</span> episode <span class="token operator">></span><span class="token number">100</span><span class="token punctuation">:</span>
        <span class="token keyword">break</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>episode:1
0.22862197060646997
迷路问题解决需要step446
episode:2
0.10822810474180004
迷路问题解决需要step126
episode:3
0.09478925672666577
迷路问题解决需要step10
episode:4
0.09316359830793433
迷路问题解决需要step4
episode:5
0.09218509281504522
迷路问题解决需要step4
episode:6
0.09117946265700733
迷路问题解决需要step4
episode:7
0.09013985857702625
迷路问题解决需要step4
episode:8
0.08905839616307487
迷路问题解决需要step4
episode:9
0.08792718721460428
迷路问题解决需要step4
episode:10
0.08673905078137753
迷路问题解决需要step4   
</code></pre>
<p>.<br>.<br>.</p>
<pre><code>episode:89
0.0013699715508602717
迷路问题解决需要step4
episode:90
0.001270445578285262
迷路问题解决需要step4
episode:91
0.0011778113705001036
迷路问题解决需要step4
episode:92
0.0010916235040459021
迷路问题解决需要step4
episode:93
0.00101146232569449
迷路问题解决需要step4
episode:94
0.0009369327553031548
迷路问题解决需要step4
episode:95
0.0008676631138282431
迷路问题解决需要step4
episode:96
0.0008033039797293862
迷路问题解决需要step4
episode:97
0.0007435270763960222
迷路问题解决需要step4
episode:98
0.0006880241927098574
迷路问题解决需要step4
episode:99
0.0006365061383794002
迷路问题解决需要step4
episode:100
0.0005887017352651513
迷路问题解决需要step4
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> animation
<span class="token keyword">from</span> IPython<span class="token punctuation">.</span>display <span class="token keyword">import</span> HTML  
<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>cm <span class="token keyword">as</span> cm <span class="token comment">#color map</span>
<span class="token comment"># IPython这是是大写</span>
<span class="token keyword">def</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    line<span class="token punctuation">.</span>set_data<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  
    <span class="token keyword">return</span> <span class="token punctuation">(</span>line<span class="token punctuation">,</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">animate</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
    line<span class="token punctuation">,</span> <span class="token operator">=</span> ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>marker <span class="token operator">=</span> <span class="token string">"s"</span><span class="token punctuation">,</span>color <span class="token operator">=</span> cm<span class="token punctuation">.</span>jet<span class="token punctuation">(</span>V<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>markersize <span class="token operator">=</span> <span class="token number">85</span><span class="token punctuation">)</span> <span class="token comment">#s0</span>
    line<span class="token punctuation">,</span> <span class="token operator">=</span> ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>marker <span class="token operator">=</span> <span class="token string">"s"</span><span class="token punctuation">,</span>color <span class="token operator">=</span> cm<span class="token punctuation">.</span>jet<span class="token punctuation">(</span>V<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>markersize <span class="token operator">=</span> <span class="token number">85</span><span class="token punctuation">)</span>
    line<span class="token punctuation">,</span> <span class="token operator">=</span> ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>marker <span class="token operator">=</span> <span class="token string">"s"</span><span class="token punctuation">,</span>color <span class="token operator">=</span> cm<span class="token punctuation">.</span>jet<span class="token punctuation">(</span>V<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>markersize <span class="token operator">=</span> <span class="token number">85</span><span class="token punctuation">)</span>
    line<span class="token punctuation">,</span> <span class="token operator">=</span> ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>marker <span class="token operator">=</span> <span class="token string">"s"</span><span class="token punctuation">,</span>color <span class="token operator">=</span> cm<span class="token punctuation">.</span>jet<span class="token punctuation">(</span>V<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>markersize <span class="token operator">=</span> <span class="token number">85</span><span class="token punctuation">)</span>
    line<span class="token punctuation">,</span> <span class="token operator">=</span> ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>marker <span class="token operator">=</span> <span class="token string">"s"</span><span class="token punctuation">,</span>color <span class="token operator">=</span> cm<span class="token punctuation">.</span>jet<span class="token punctuation">(</span>V<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>markersize <span class="token operator">=</span> <span class="token number">85</span><span class="token punctuation">)</span>
    line<span class="token punctuation">,</span> <span class="token operator">=</span> ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>marker <span class="token operator">=</span> <span class="token string">"s"</span><span class="token punctuation">,</span>color <span class="token operator">=</span> cm<span class="token punctuation">.</span>jet<span class="token punctuation">(</span>V<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>markersize <span class="token operator">=</span> <span class="token number">85</span><span class="token punctuation">)</span>
    line<span class="token punctuation">,</span> <span class="token operator">=</span> ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>marker <span class="token operator">=</span> <span class="token string">"s"</span><span class="token punctuation">,</span>color <span class="token operator">=</span> cm<span class="token punctuation">.</span>jet<span class="token punctuation">(</span>V<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>markersize <span class="token operator">=</span> <span class="token number">85</span><span class="token punctuation">)</span>
    line<span class="token punctuation">,</span> <span class="token operator">=</span> ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>marker <span class="token operator">=</span> <span class="token string">"s"</span><span class="token punctuation">,</span>color <span class="token operator">=</span> cm<span class="token punctuation">.</span>jet<span class="token punctuation">(</span>V<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>markersize <span class="token operator">=</span> <span class="token number">85</span><span class="token punctuation">)</span>
    line<span class="token punctuation">,</span> <span class="token operator">=</span> ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>marker <span class="token operator">=</span> <span class="token string">"s"</span><span class="token punctuation">,</span>color <span class="token operator">=</span> cm<span class="token punctuation">.</span>jet<span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>markersize <span class="token operator">=</span> <span class="token number">85</span><span class="token punctuation">)</span>
anim <span class="token operator">=</span> animation<span class="token punctuation">.</span>FuncAnimation<span class="token punctuation">(</span>fig<span class="token punctuation">,</span>animate<span class="token punctuation">,</span>init_func <span class="token operator">=</span> init<span class="token punctuation">,</span>frames <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>V<span class="token punctuation">)</span><span class="token punctuation">,</span>interval <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">,</span>repeat <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span>
HTML<span class="token punctuation">(</span>anim<span class="token punctuation">.</span>to_jshtml<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/image/33.gif" alt="gif"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux指令（更新中）</title>
    <url>/2021/07/01/linux%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="linux指令">Linux指令</span></h2><h3><span id="文件操作">文件操作</span></h3><p>1.创建文件</p>
<pre class="line-numbers language-none"><code class="language-none">int open(const char &amp;pathname,int flags,mode_t mode);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*
#include &lt;sys&#x2F;types.h&gt;
#include &lt;sys&#x2F;stat.h&gt;
#include &lt;fcntl.h&gt;
int open(const char &amp;pathname,int flags,mode_t mode);
    参数： 
        -pathname：要创建的文件的路径
        -flags：对文件的操作权限和其他设置
            -必选项：O_RDONLY O_WRONLY O_RDWR
            -可选项：O_CREAT 文件不存在创建文件
        -mode：八进制的数，表示创建出的新文件的操作权限，比如：0775
        最终的权限是：mode &amp; ~umask
        0777 -&gt; 111111111   
    &amp;
        0775 -&gt; 111111101
    -----------------------------------------
                111111101
    按位与：0和任何数都为0
    umask抹去某些权限
    flags参数是一个int类型数据，占4个字节 32位
    flag 32个位 每一个位都是一个标志位。
*&#x2F;
#include &lt;sys&#x2F;types.h&gt;
#include &lt;sys&#x2F;stat.h&gt;
#include &lt;fcntl.h&gt;
#include&lt;stdio.h&gt;
#include&lt;unistd.h&gt;
int main()&#123;
    &#x2F;&#x2F;创建一个新的文件
    int fd &#x3D; open(&quot;create.txt&quot;, O_RDWR | O_CREAT, 0777);
    if(fd &#x3D;&#x3D; -1)&#123;
        perror(&quot;open&quot;);
    &#125;
    &#x2F;&#x2F;关闭
    close(fd);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>2.打开已存在文件</p>
<pre class="line-numbers language-none"><code class="language-none">int open(const char &amp;pathname,int flags);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*
        #include &lt;sys&#x2F;types.h&gt;
        #include &lt;sys&#x2F;stat.h&gt;
        #include &lt;fcntl.h&gt;
        &#x2F;&#x2F;打开一个已经存在的文件
        int open(const char &amp;pathname,int flags);
            参数：
                - pathname：要打开的文件的路径
                - flags：对文件的操作权限和其他设置
                  O_RDONLY O_WRONLY O_RDWR 这三个设置是互斥的
            返回值：返回一个新的文件描述符。如果调用失败返回-1
        errono：属于linux系统函数库，库里面的一个全局变量 记录的是最近的错误号。
        
        #include &lt;stdio.h&gt;
        void perror(const char *s); 作用：打印error对应的错误描述
            s参数：用户描述，比如hello，最终输出的内容是hello：xxx（实际的错误描述）

        #include &lt;errno.h&gt;

        &#x2F;&#x2F;创建一个新的文件
        int open(const char &amp;pathname,int flags,mode_t mode);

       
*&#x2F;
#include &lt;sys&#x2F;types.h&gt;
#include &lt;sys&#x2F;stat.h&gt;
#include &lt;fcntl.h&gt;
#include&lt;unistd.h&gt;
#include&lt;stdio.h&gt;
int main()&#123;
    int fd &#x3D; open(&quot;a.txt&quot;, O_RDONLY);
    if(fd &#x3D;&#x3D; -1)&#123;
        perror(&quot;open&quot;);
    &#125;
    &#x2F;&#x2F;读写操作
    
    &#x2F;&#x2F;关闭
    close(fd);
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.复制文件</p>
<pre class="line-numbers language-none"><code class="language-none">ssize_t read(int fd,void *buf,size_t count);
ssize_t write(int fd,void *buf,size_t count);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*
    #include&lt;unistd.h&gt;
    ssize_t read(int fd,void *buf,size_t count);
        参数：
            -fd：文件描述符 ，open得到的，通过这个文件描述符操作某个文件
            -buf：需要读取数据存放的地方，数组的地址
            -count：指定的数组的大小
        返回值：
            -成功：
                &gt;0:返回实际读取到的字节数
                &#x3D;0：文件已经读取完成
            -失败：-1 ，并且设置perror
    #include&lt;unistd.h&gt;
    ssize_t write(int fd,void *buf,size_t count);
        参数：
            -fd:文件描述符，open得到的，通过这个文件描述符操作某个文件
            -buf：要往磁盘写入的数据，数据
            -count：要写的数据的实际大小
        返回值：
            -成功：
                &gt;0:返回实际读取到的字节数
                -失败：-1 ，并且设置perror
*&#x2F;
#include&lt;unistd.h&gt;
#include&lt;stdio.h&gt;
#include&lt;sys&#x2F;types.h&gt;
#include&lt;sys&#x2F;stat.h&gt;
#include&lt;fcntl.h&gt;
int main()&#123;
    &#x2F;&#x2F;通过open打开english.txt
    int srcfd &#x3D; open(&quot;english.txt&quot;, O_RDONLY);
    if(srcfd &#x3D;&#x3D; -1)&#123;
        perror(&quot;open&quot;);
        return -1;
    &#125;
    &#x2F;&#x2F;创建一个新的文件（拷贝文件）
    int destfd &#x3D; open(&quot;cpy.txt&quot;, O_WRONLY | O_CREAT, 0664);
    if(destfd &#x3D;&#x3D; -1)&#123;
        perror(&quot;open&quot;);
        return -1;
    &#125;
    &#x2F;&#x2F;频繁的读写操作
    char buf[1024] &#x3D; &#123;0&#125;;
    int len &#x3D; 0;
    while ((len &#x3D; read(srcfd, buf, sizeof(buf)))&gt;0)&#123;
        write(destfd, buf, len);
    &#125;
    &#x2F;&#x2F;关闭文件
    close(destfd);
    close(srcfd);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>4.lseek </p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*
    标准C库函数
    #include&lt;stdio.h&gt;
    int fseek(FILE *stream,long offset,int whence)
    
    Linux 系统函数
    #include &lt;sys&#x2F;types.h&gt;
    #include &lt;unistd.h&gt;
    off_t lseek(int fd, off_t offset, int whence);
        参数
            -fd:文件描述符，通过open得到，通过fd操作某个文件
            -offset：偏移量
            -whence：
                SEEK_SET
                    设置文件指针的偏移量
                SEEK_CUR
                    设置偏移量：当前位置+第二个参数offset的值
                SEEK_END    
                    设置偏移量：文件大小+第二个参数offset的值
        返回值：返回文件指针的位置
    作用：
        1.移动文件指针到文件头
        lseek(fd,0,SEEK_SET);
        
        2.获取当前文件指针的位置
        lseek(fd,0,SEEK_CUR);

        3.获取文件长度
        lseek(fd,0,SEEK_END);

        4.扩展文件的长度，当前文件10b，110b，增加了100b
        lseek(fd,100,SEEK_END);从文件末尾向后偏移100

        注意：需要写入一次数据
        
*&#x2F;
#include &lt;sys&#x2F;types.h&gt;
#include&lt;sys&#x2F;stat.h&gt;
#include&lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include&lt;stdio.h&gt;
int main()&#123;
    int fd &#x3D; open(&quot;hello.txt&quot;, O_RDWR);
    if(fd &#x3D;&#x3D; -1)&#123;
        perror(&quot;open&quot;);
        return -1;
    &#125;
    &#x2F;&#x2F;扩展文件的长度
    int ret &#x3D; lseek(fd, 100, SEEK_END);
    if(ret &#x3D;&#x3D; -1)&#123;
        perror(&quot;lseek&quot;);
        return -1;
    &#125;
    &#x2F;&#x2F;写入一个空数据
    write(fd, &quot; &quot;, 1);
    close(fd);
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>5.获取文件信息</p>
<pre class="line-numbers language-none"><code class="language-none">int stat(const char *pathname, struct stat *statbuf);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*
       #include &lt;sys&#x2F;types.h&gt;
       #include &lt;sys&#x2F;stat.h&gt;
       #include &lt;unistd.h&gt;

       int stat(const char *pathname, struct stat *statbuf);
            作用：获取一个文件信息
            参数：
                -pathname：操作的文件的路径
                -statbuf：结构体变量，传出参数，用于保存获取到的信息
            返回值：
                成功：返回0
                失败：返回-1，设置errno

       int lstat(const char *pathname, struct stat *statbuf);
            参数：
                -pathname：操作的文件的路径
                -statbuf：结构体变量，传出参数，用于保存获取到的信息
            返回值：
                成功：返回0
                失败：返回-1，设置errno        

*&#x2F;
#include&lt;sys&#x2F;types.h&gt;
#include&lt;stdio.h&gt;
#include&lt;sys&#x2F;stat.h&gt;
#include&lt;unistd.h&gt;
int main()&#123;
    struct stat statbuf;
    int ret &#x3D; stat(&quot;a.txt&quot;, &amp;statbuf);
    if(ret &#x3D;&#x3D; -1)&#123;
        perror(&quot;stat&quot;);
        return -1;
    &#125;
    printf(&quot;size: %ld\n&quot;, statbuf.st_size);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>6.判断某个文件是否有某个权限，或者某个文件是否存在</p>
<pre class="line-numbers language-none"><code class="language-none">int access(const char * pathname,int mode);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*
       #include &lt;unistd.h&gt;

       int access(const char *pathname, int mode);
        作用：判断某个文件是否有某个权限，或者判断文件是否存在
        参数：
            -pathname ：判断的文件路径
            -mode：
                R_OK:判断文件内是否有读权限
                W_OK:判断文件内是否有写权限
                X_OK:判断文件内是否有执行权限
                F_OK:判断文件内是否存在
        返回值：
            成功返回0 ，失败返回-1
*&#x2F;


#include&lt;unistd.h&gt;
#include&lt;stdio.h&gt;
int main()&#123;
    int ret &#x3D; access(&quot;a.txt&quot;, F_OK);
    if(ret &#x3D;&#x3D; -1)&#123;
        perror(&quot;access&quot;);
        return -1;
    &#125;
    printf(&quot;文件存在!!\n&quot;);
    return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>7.修改文件的权限</p>
<pre class="line-numbers language-none"><code class="language-none">int chmod(const char *pathname,mode_t mode);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*
       #include &lt;sys&#x2F;stat.h&gt;

       int chmod(const char *pathname, mode_t mode);
        作用：修改文件的权限
        参数：
            -pathname 需要修改的文件的路径
            -mode:需要修改的权限值，八进制的数
        返回值：成功返回0 失败返回-1

*&#x2F;
#include&lt;unistd.h&gt;
#include&lt;sys&#x2F;stat.h&gt;
#include&lt;stdio.h&gt;
int main()&#123;
    int ret &#x3D; chmod(&quot;a.txt&quot;, 0777);
    if(ret &#x3D;&#x3D; -1)&#123;
        perror(&quot;chmod&quot;);
        return -1;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>8.缩减或扩展文件到指定的大小</p>
<pre class="line-numbers language-none"><code class="language-none">int truncate(const char *path,off_t length);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*
SYNOPSIS
       #include &lt;unistd.h&gt;
       #include &lt;sys&#x2F;types.h&gt;

       int truncate(const char *path, off_t length);
            作用：缩减或扩展文件的尺寸至指定的大小
            参数：
                -path：需要修改的文件的路径
                -length：需要最终文件变成的大小
            返回值:成功返回0 失败返回-1
*&#x2F;
#include &lt;unistd.h&gt;
#include &lt;sys&#x2F;types.h&gt;
#include&lt;stdio.h&gt;
int main()&#123;
    int ret &#x3D; truncate(&quot;b.txt&quot;, 5);
    if(ret &#x3D;&#x3D; -1)&#123;
        perror(&quot;truncate&quot;);
        return -1;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>9.创建一个目录</p>
<pre class="line-numbers language-none"><code class="language-none">int mkdir(const char* pathname,mode_t mode);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*
       #include &lt;sys&#x2F;stat.h&gt;
       #include &lt;sys&#x2F;types.h&gt;

       int mkdir(const char *pathname, mode_t mode);
        作用：创建一个目录
        参数：  
            pathname：创建的目录的路径
            mode：权限 8进制的数
        返回值：
            成功返回0 失败返回-1
*&#x2F; 

#include &lt;sys&#x2F;stat.h&gt;
#include &lt;sys&#x2F;types.h&gt;
#include&lt;stdio.h&gt;
int main()&#123;
    int ret &#x3D; mkdir(&quot;aaa&quot;, 0777);
    if(ret &#x3D;&#x3D; -1)&#123;
        perror(&quot;mkdir&quot;);
        return -1;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>10.修改目录名称</p>
<pre class="line-numbers language-none"><code class="language-none">int rename(const char *oldpath,const char *newpath);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*
       #include &lt;stdio.h&gt;

       int rename(const char *oldpath, const char *newpath);

*&#x2F;
#include &lt;stdio.h&gt;
int main()&#123;
    int ret &#x3D; rename(&quot;aaa&quot;, &quot;bbb&quot;);
    if(ret &#x3D;&#x3D; -1)&#123;
        perror(&quot;rename&quot;);
        return -1;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>11.修改进程的工作目录</p>
<pre class="line-numbers language-none"><code class="language-none">int chdir(const char *path);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*
       #include &lt;unistd.h&gt;

       int chdir(const char *path);
            作用：修改进程的工作目录
                比如在&#x2F;home&#x2F;yxy目录下启动了一个可执行程序a.out,进程的工作目录&#x2F;home&#x2F;yxy
            参数：
                path：需要修改的工作目录

       #include &lt;unistd.h&gt;

       char *getcwd(char *buf, size_t size);
       作用：获取当前的工作目录
       参数：
            -buf：存储的路径，指向的是一个数组，传出参数
            -size：数组的大小

        返回值：
            返回的指向的一块内存，这个数据就是第一个参数


*&#x2F;


#include &lt;unistd.h&gt;
#include&lt;stdio.h&gt;
#include&lt;sys&#x2F;stat.h&gt;
#include&lt;sys&#x2F;types.h&gt;
#include&lt;fcntl.h&gt;
int main()&#123;
    &#x2F;&#x2F;获取当前的工作目录
    char buf[128];
    getcwd(buf, sizeof(buf));
    printf(&quot;当前的工作目录是:%s\n&quot;,buf);

    &#x2F;&#x2F;修改工作目录

    int ret &#x3D; chdir(&quot;&#x2F;home&#x2F;yxy&#x2F;Linux&#x2F;lesson13&quot;);
    if(ret &#x3D;&#x3D; -1)&#123;
        perror(&quot;chdir&quot;);
        return -1;
    &#125;

    &#x2F;&#x2F;创建一个新的文件
    int fd &#x3D; open(&quot;chdir.txt&quot;, O_CREAT | O_RDWR, 0664);
    if(fd &#x3D;&#x3D; -1)&#123;
        perror(&quot;open&quot;);
        return -1;
    &#125;
    close(fd);

    &#x2F;&#x2F;获取当前的工作目录
    char buf1[128];
    getcwd(buf1, sizeof(buf));
    printf(&quot;当前的工作目录是:%s\n&quot;,buf1);

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="2内存映射的注意事项">2.内存映射的注意事项</span></h3><p>1.如果对mmap的返回值(ptr)做++操作，munmap是否能成功</p>
<p>void * ptr =  mmap(….);<br>ptr++;可以进行++操作<br>munmap(ptr,len);  //错误，要保存地址   new  delete</p>
<p>2.如果open时O_RDONLY,mmap时prot参数指定PROT_READ | PROT_WRITE 会怎样？</p>
<p>错误，返回MAP_FAILED;<br>open()函数中的权限建议和PROT参数的权限保持一致</p>
<p>3.如果文件偏移量1000 会怎样？<br>偏移量必须是4k的整数倍，错误，返回MAP_FAILED</p>
<p>4.mmap什么情况下会调用失败？<br>    -第二个参数 length = 0<br>    -第三个参数 prot<br>        -只指定了写权限<br>        - prot  PROT_READ | PROT_WRITE<br>            第五个参数通过open函数时指定的O_RDONLY /O_WRONLY</p>
<p>5.可以open的时候O_CREAT 一个新文件来创建映射区吗？<br>    -可以的，但是创建的文件的大小如果为0的话，肯定不行<br>    -可以对新的文件进行扩展<br>        -lseek()<br>        -truncate()</p>
<p>6.mmap后关闭文件描述符，对mmap映射有没有影响？<br>int fd = open(“xxx”);<br>mmap(,,,fd,,);<br>close(fd);<br>映射区还在，创建映射区的fd被关闭了没有任何影响</p>
<p>7.对ptr越界操作会怎么样？<br>void * ptr = mmap(NULL,100,,,,);<br>4K<br>越界操作操作的是非法的内存，—&gt;产生段错误</p>
<h3><span id="阻塞信号集和未决信号集">阻塞信号集和未决信号集</span></h3><p>1.用户通过键盘 crtl + c产生2号信号SIGINT(信号被创建）<br>2.信号产生但是没有被处理（未决）<br>    在内核中将所有的没有被处理的信号存储在一个集合中(未决信号集)<br>    SIGINT信号状态被存储在第二个标志位上<br>        这个标志位的值为0，说明信号不是未决状态<br>        这个标志位的值为1，说明信号处于未决状态<br>3.这个未决状态的信号需要被处理，处理之前需要和另一个信号集(阻塞信号集)，进行一个比较。<br>    -阻塞信号集默认不阻塞任何的信号<br>    -如果先要阻塞某些信号，需要用户调用系统的API</p>
<p>4.在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞。<br>    -如果没有阻塞，这个信号就被处理。<br>    -如果阻塞了，这个信号就继续处于未决状态，直到阻塞接触，这个信号被处理。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql安装 取消Root密码</title>
    <url>/2021/02/01/mysql%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%8F%96%E6%B6%88%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="密码忘记-关闭mysql">密码忘记 关闭mysql</span></h2><p>第一步：关闭mysql服务器。<br>苹果 –》系统偏好设置 –》 mysql –》Stop Mysql Server<br>第二步：进入mysql安装路径，用系统管理员权限跳过mysql安全认证，命令结果如下图所示。</p>
<p>1.打开启动台–》其他 –》终端</p>
<p>2.进入mysql安装路径  cd /usr/local/mysql/bin/</p>
<p>3.登录管理员权限 sudo su</p>
<p>4.输入开机密码 <strong>**</strong></p>
<p>5.输入跳过mysql安全认证的命令  ./mysqld_safe –skip-grant-tables &amp;</p>
<p>6.在第一步的mysql设置的画面中发现 关闭的mysql server 又重新变成running了</p>
<p>7.进入mysql 输入命令  ./mysql</p>
<p>如果显示以下字样，则为登录成功。</p>
<p>Welcome to the MySQL monitor.  Commands end with ; or \g.</p>
<p>Your MySQL connection id is 12</p>
<p>Server version: 5.7.24 MySQL Community Server (GPL)</p>
<p>8.刷新权限 FLUSH PRIVILEGES</p>
<p>Query OK, 0 rows affected (0.01 sec)</p>
<h2><span id="强行修改跳过密码">强行修改跳过密码</span></h2><p>忘记密码强行修改一：</p>
<p>1.停止mysql服务 sudo /usr/local/mysql/support-files/mysql.server stop 输入开机密码</p>
<p>2.进入安装目录 cd /usr/local/mysql/bin</p>
<p>3.禁止mysql安全验证  ./mysqld_safe –skip-grant-tables &amp;</p>
<p>显示如下时，禁止成功</p>
<p>root@guofei:/usr/local/mysql-5.7.24-macos10.14-x86_64/bin#     2019-02-14T05:18:51.6NZ mysqld_safe Logging to ‘/usr/local/mysql-5.7.24-macos10.14-x86_64/data/guofei.local.err’.</p>
<p>2019-02-14T05:18:51.6NZ mysqld_safe Starting mysqld daemon with databases from /usr/local/mysql-5.7.24-macos10.14-x86_64/data</p>
<p>输入./mysql 显示如下时，无安全认证情况下登录成功</p>
<p>Welcome to the MySQL monitor.  Commands end with ; or \g.</p>
<p>Your MySQL connection id is 2</p>
<p>Server version: 5.7.24 MySQL Community Server (GPL)</p>
<p>4.刷新权限  FLUSH PRIVILEGES;</p>
<p>5.修改密码 ALTER USER ‘root’@’localhost’ IDENTIFIED BY ‘888888’;</p>
<p>6.退出mysql重新登录 quit</p>
<p>mysql -u root -p 输入刚刚更新的 888888，登录成功</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>安装问题</tag>
      </tags>
  </entry>
  <entry>
    <title>算法面试5-二叉树和递归</title>
    <url>/2021/04/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="二叉树和递归">二叉树和递归</span></h2><p>例题104：<br>求一棵二叉树的最高深度</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
public:
    int maxDepth(TreeNode * root)&#123;
        if(root &#x3D;&#x3D; NULL)
            return 0;
        int leftMaxDepth &#x3D; maxDepth(root-&gt;left);
        int rightMaxDepth &#x3D; maxDepth(root-&gt;right);
        return max(leftMaxDepth,rightMaxDepth) +1；
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>复习二叉树相关的所有操作<br>例题226：<br>反转一棵二叉树</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    TreeNode* invertTree(TreeNode* root) &#123;
        if(root &#x3D;&#x3D; NULL)
            return NULL;
        invertTree(root-&gt;left);
        invertTree(root-&gt;right);
        swap(root-&gt;left,root-&gt;right);
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题100：Same Tree<br>给出两棵二叉树，判断是否一样</p>
<p>例题101： Symmetric tree<br>判断一棵二叉树是否是左右对称的</p>
<p>例题222：count Complete Tree Nodes<br>给定一棵完全二叉树，求完全二叉树的节点个数</p>
<p>例题110 ：<br>判断一棵二叉树是否为平衡二叉树</p>
<p>例题112：Path Sum</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    bool hasPathSum(TreeNode *root,int sum)&#123;
        if(root &#x3D;&#x3D; NULL)
            return sum &#x3D;&#x3D; 0;
        并列条件判断语句

        if(hasPathSum(root-&gt;left,sum-root-&gt;val))
            return true;
        if(hasPathSum(root-&gt;right,sum-root-&gt;val))
            return true;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果root的值就等于sum，虽然相等，但是没有root到子结点的路径所以正常应该是返回false</p>
<p>改进的话，改变递归终止条件</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    bool hasPathSum(TreeNode *root,int sum)&#123;
        if(root &#x3D;&#x3D; NULL) &#x2F;&#x2F;根节点root的值为空 直接返回false
            return false;
        if(root-&gt;left &#x3D;&#x3D; NULL &amp;&amp; root-&gt;right &#x3D;&#x3D; NULL)&#x2F;&#x2F;走到最后到达了 ，最终子节点的值和sum做判断
            return root-&gt;val &#x3D;&#x3D; sum;
            &#x2F;&#x2F;理解更轻松两个条件语句，一个为true则结果为true
        return (hasPathSum(root-&gt;left,sum-root-&gt;val))||(hasPathSum(root-&gt;right,sum-root-&gt;val));
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题404：<br>求出一棵二叉树所有左叶子的和</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    int sumOfLeftLeaves(TreeNode* root) &#123;
        int sum &#x3D; 0;
        if(root &#x3D;&#x3D; NULL)
            return 0;

        if(root-&gt;left!&#x3D;NULL&amp;&amp;root-&gt;left-&gt;left &#x3D;&#x3D;NULL &amp;&amp;root-&gt;left-&gt;right &#x3D;&#x3D; NULL)
             sum&#x3D;root-&gt;left-&gt;val;
        &#x2F;&#x2F;每当找到一个在最末端的左叶子就去更新sum
        &#x2F;&#x2F;sumofleftLeaves每次都会使sum获得一次更新
        return sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right) + sum;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题257：<br>给定一颗二叉树，返回所有表示从根节点到叶子节点路径的字符串</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    vector&lt;string&gt; binaryTreePaths(TreeNode * root) &#123;
        vector&lt;string&gt; res;
        if(root &#x3D;&#x3D; NULL)
            return res;
        if(root-&gt;left &#x3D;&#x3D; NULL &amp;&amp; root-&gt;right &#x3D;&#x3D; NULL)
            res.push_back(to_string(root-&gt;val));
            return res;
        vector&lt;string&gt; leftS &#x3D; binaryTreePaths(root-&gt;left);
        for(int i &#x3D; 0;i&lt;leftS.size();i++)
            res.push_back(to_string(root-&gt;val)+ &quot;-&gt;&quot;+leftS[i]);
        vector&lt;string&gt; rightS &#x3D; binaryTreePaths(root-&gt;left);
        for(int i &#x3D; 0;i&lt;rightS.size();i++)
            res.push_back(to_string(root-&gt;val) + &quot;-&gt;&quot;+rightS[i]));

        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>例题113： Path  sum II<br>例题129：Sum root to leaf numbers</p>
<h2><span id="更复杂的递归问题">更复杂的递归问题</span></h2><p>例题437：Path sum III</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    &#x2F;&#x2F;在以root为根节点的二叉树中寻找和为sum的路径，返回这样的路径个数
    int pathSum(TreeNode * root,int sum)&#123;
        if(root &#x3D;&#x3D; NULL)
            return 0;
        int res &#x3D; findPath(root,sum);
        res +&#x3D; pathSum(root-&gt;left,sum);
        res +&#x3D; pathSum(root-&gt;right,sum);
        return res;
    &#125;
private:
    &#x2F;&#x2F;在以node为根节点的二叉树中，寻找包含node的路径，和为sum
    &#x2F;&#x2F;返回这样的路径的个数
    int findPath(TreeNode * node,int num)&#123;
        if(node &#x3D;&#x3D; NULL)
            return 0;
        int res &#x3D; 0;
        if(node-&gt;val &#x3D;&#x3D; num)
            res+&#x3D;1;
        res +&#x3D; findPath(node-&gt;left,num-node-&gt;val);
        res +&#x3D; findPath(node-&gt;right,num-node-&gt;val);
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="二分搜索树中的问题">二分搜索树中的问题</span></h2><p>例题235：<br>给定一棵二分搜索树和两个节点，寻找两个节点的最近公共祖先</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    TreeNode* lowestCommonAncestor(TreeNode* root,TreeNode * p,TreeNode *q)&#123;
        assert(p!&#x3D; NULL &amp;&amp; q!&#x3D;NULL);
        if(root &#x3D;&#x3D; NULL) &#x2F;&#x2F;如果根节点为空，则返回空
            return NULL;
        if(p-&gt;val &lt;root-&gt;val &amp;&amp; q-&gt;val&lt;root-&gt;val) &#x2F;&#x2F;p,q都在左侧
            return lowestCommonAncestor(root-&gt;left,p,q);
        if(p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val&gt;root-&gt;val) &#x2F;&#x2F;p,q都在右侧
            return lowestCommonAncestor(root-&gt;right,p,q);  

        return root;      
    &#125;
    &#125;；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题98:validate binary search tree<br>给定一棵二叉树，验证是否为二分搜索树<br>例题450：Delete Node in a BST<br>给定一棵二分搜索树，删除其中的一个节点<br>例题230 Kth smallest element in a BST<br>例题236 lowest ancestor of a binary tree</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime中文设置以及g++安装</title>
    <url>/2021/02/08/sublime%E4%B8%AD%E6%96%87%E8%AE%BE%E7%BD%AE%E4%BB%A5%E5%8F%8Ag-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="markdown文本编辑器的初期配置">markdown文本编辑器的初期配置</span></h2><p>官网下载，并安装好, 刚安装好的是没有 Package Control 选项</p>
<p>找到  Tools-&gt;Install Package Control  选项，即可调出 Package Control</p>
<p>去找“Tools-&gt;Command Palette…”选项，</p>
<p>输入 ipc ,点击 Install Package Control，即可调出 Package Control</p>
<p>找到  Preferences-&gt;Package Control</p>
<p>选项弹出命令行输入框，输入ip，点击“install Package”</p>
<p>弹出命令行输入框，输入clz，点击“ChineseLocalizations”</p>
<p>搞定，设置成中文了</p>
<h2><span id="markdown下配置c编译环境">markdown下配置C++编译环境</span></h2><p>选择工具-&gt;编译系统-&gt;新建编译系统</p>
<p>将弹出的文本改为以下内容</p>
<p>{<br>    “encoding”: “utf-8”,<br>    “working_dir”: “$file_path”,<br>    “shell_cmd”: “g++ &quot;$file_name&quot; -o &quot;$file_base_name&quot;“,<br>    “file_regex”: “^(..[^:]<em>):([0-9]+):?([0-9]+)?:? (.</em>)$”,<br>    “selector”: “source.c++”,<br>     “variants”:<br>    [<br>        {<br>        “name”: “Run”,<br>        “shell_cmd”: “g++ ‘$file’ -o ‘$file_base_name’ &amp;&amp; gnome-terminal -x bash -c &quot;‘${file_path}/${file_base_name}’;read -p ‘\nPress any key to continue…’&quot;“<br>        }<br>    ]<br>}</p>
<p>保存为myC++之后即完成配置。<br>接下来快捷键ctrl+shift+p 输入选择myC++ 编辑文本即可。</p>
<p>PS：在linux系统下通过<br>sudo apt update<br>sudo apt install build-essential<br>两条代码即可轻松配置g++.</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>文本编辑器</category>
      </categories>
      <tags>
        <tag>sublime设置</tag>
      </tags>
  </entry>
  <entry>
    <title>云台设计</title>
    <url>/2021/02/09/%E4%BA%91%E5%8F%B0%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="云台设计构想及编程应用c语言c转换未完成">云台设计构想及编程应用（C语言—–C＋＋转换未完成）</span></h2><p>控制平台设计构想<br>传感器读取初始数据<br>卡尔曼滤波算法获取yaw，roll，pitch的角度<br>将数据转化为电机的目标值<br>    测量值如果和目标值相等<br>        读取磁编码测量其位置值<br>    测量值与目标值不相等<br>        经过位置环，速度环，电流环<br>            改变电机位置</p>
<p>状态预测：<br>𝑋(𝑘,𝑘−1)=𝐴(𝑘,𝑘−1)𝑋(𝑘−1)<br>或者<br>𝑋(𝑘,𝑘−1)=𝐴(𝑘,𝑘−1)𝑋(𝑘−1)+B(k)u(k)</p>
<p>这里X(k,k-1)是利用k-1时刻预测的当前状态结果<br>X(k-1)是k-1时刻最优值<br>A(k,k-1)是X(k-1)状态下的变换矩阵，它是算法对状态变量进行预测的依据<br>B(k)是作用在控制量上的变换矩阵，在大多数实际情况下并没有控制收益<br>u(k)是当前状态的控制增益，一般没有这个变量，可以设为0</p>
<p>协方差阵预测：<br>P(𝑘,𝑘−1)=𝐴(𝑘,𝑘−1)𝑃(𝑘−1) 𝐴^𝑇 (𝑘,𝑘−1)+𝐵(𝑘,𝑘−1)𝑄(𝑘−1)𝐵^𝑇 (𝑘,𝑘−1)</p>
<p>P(𝑘,𝑘−1)是k时刻系统协方差矩阵<br>P(k-1)是k-1时刻系统协方差矩阵<br>Q(k-1)是系统过程的协方差矩阵</p>
<p>滤波增益：<br>根据k时刻的协方差矩阵的预测值计算卡尔曼收益<br>𝐾(𝑘)=(𝑝(𝑘,𝑘−1) 𝐶^𝑇 (𝑘))/((𝐶(𝑘)𝑃(𝑘,𝑘−1) 𝐶^𝑇 (𝑘)+𝑅(𝑘))<br>k(k)是卡尔曼增益，是滤波的中间结果<br>C(k)是对象的预测矩阵<br>R(k)是对象测量噪声的协方差矩阵，是一个数值，作为已知条件输入滤波器。<br>这个值过大过小都会使滤波效果变差，且R(k)取值越小收敛越快,所以可以通过实验手段寻找合适的R(k)值再利用它进行真实的滤波.</p>
<p>协方差阵估计：<br>目的：为了求k时刻的协方差矩阵（为得到k+1时刻的卡尔曼输出值做准备）<br>𝑃(𝑘)=(1−𝐾(𝑘)𝐶(𝑘))𝑃(𝑘,𝑘−1)<br>当p(k,k-1)为一个一维矩阵的时候,C(k)是1</p>
<p>状态估计：<br>𝑋(k)=𝑋(𝑘,𝑘−1）+𝐾(𝑘)(𝑌(𝑘)−𝐶(𝑘)𝑋(𝑘,𝑘−1))<br>X(k)是k时刻状态变量的最优估计值<br>Y(K)是对象的测量</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;1. 结构体类型定义
typedef struct 
&#123;
    float LastP;&#x2F;&#x2F;上次估算协方差 初始化值为0.02
    float Now_P;&#x2F;&#x2F;当前估算协方差 初始化值为0
    float out;&#x2F;&#x2F;卡尔曼滤波器输出 初始化值为0
    float Kg;&#x2F;&#x2F;卡尔曼增益 初始化值为0
    float Q;&#x2F;&#x2F;过程噪声协方差 初始化值为0.001
    float R;&#x2F;&#x2F;观测噪声协方差 初始化值为0.543
&#125;KFP；&#x2F;&#x2F;Kalman Filter parameter

&#x2F;&#x2F;2. 以高度为例 定义卡尔曼结构体并初始化参数
KFP KFP_height&#x3D;&#123;0.02,0,0,0,0.001,0.543&#125;;

&#x2F;**
 *卡尔曼滤波器
 *@param KFP *kfp 卡尔曼结构体参数
 *   float input 需要滤波的参数的测量值（即传感器的采集值）
 *@return 滤波后的参数（最优值）
 *&#x2F;
 float kalmanFilter(KFP *kfp,float input)
 &#123;
     &#x2F;&#x2F;预测协方差方程：k时刻系统估算协方差 &#x3D; k-1时刻的系统协方差 + 过程噪声协方差
     kfp-&gt;Now_P &#x3D; kfp-&gt;LastP + kfp-&gt;Q;
     &#x2F;&#x2F;卡尔曼增益方程：卡尔曼增益 &#x3D; k时刻系统估算协方差 &#x2F; （k时刻系统估算协方差 + 观测噪声协方差）
     kfp-&gt;Kg &#x3D; kfp-&gt;Now_P &#x2F; (kfp-&gt;NOw_P + kfp-&gt;R);
     &#x2F;&#x2F;更新最优值方程：k时刻状态变量的最优值 &#x3D; 状态变量的预测值 + 卡尔曼增益 * （测量值 - 状态变量的预测值）
     kfp-&gt;out &#x3D; kfp-&gt;out + kfp-&gt;Kg * (input -kfp-&gt;out);&#x2F;&#x2F;因为这一次的预测值就是上一次的输出值
     &#x2F;&#x2F;更新协方差方程: 本次的系统协方差付给 kfp-&gt;LastP 威下一次运算准备。
     kfp-&gt;LastP &#x3D; (1-kfp-&gt;Kg) * kfp-&gt;Now_P;
     return kfp-&gt;out；
 &#125;

&#x2F;**
 *调用卡尔曼滤波器 实践
 *&#x2F;
int height;
int kalman_height&#x3D;0;
kalman_height &#x3D; kalmanFilter(&amp;KFP_height,(float)height);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>控制系统</category>
      </categories>
      <tags>
        <tag>云台设计</tag>
      </tags>
  </entry>
  <entry>
    <title>倒单摆深入学习</title>
    <url>/2021/02/24/%E5%80%92%E5%8D%95%E6%91%86%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里的模型是gym库的cartpole-v0<br>采用深入学习Q学习<br>构建agent，brain,environment<br>对于研究的模型来说可以通过gym来自己创建模型，具体操作之后学习</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt 
<span class="token operator">%</span>matplotlib inline
<span class="token keyword">import</span> gym<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> JSAnimation<span class="token punctuation">.</span>IPython_display <span class="token keyword">import</span> display_animation
<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> animation
<span class="token keyword">from</span> IPython<span class="token punctuation">.</span>display <span class="token keyword">import</span> display

<span class="token comment"># jupyter notebook gif动画保存方法</span>
<span class="token keyword">def</span> <span class="token function">display_frames_as_gif</span><span class="token punctuation">(</span>frames<span class="token punctuation">)</span><span class="token punctuation">:</span>
    plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span>frames<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">72.0</span><span class="token punctuation">,</span> frames<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">72.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
               dpi<span class="token operator">=</span><span class="token number">72</span><span class="token punctuation">)</span>

    patch <span class="token operator">=</span> plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>frames<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    plt<span class="token punctuation">.</span>axis<span class="token punctuation">(</span><span class="token string">'off'</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">animate</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
    patch<span class="token punctuation">.</span>set_data<span class="token punctuation">(</span>frames<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
 
    anim <span class="token operator">=</span> animation<span class="token punctuation">.</span>FuncAnimation<span class="token punctuation">(</span>plt<span class="token punctuation">.</span>gcf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> animate<span class="token punctuation">,</span> frames<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>frames<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                   interval<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">)</span>
 
    anim<span class="token punctuation">.</span>save<span class="token punctuation">(</span><span class="token string">'movie_cartpole.mp4'</span><span class="token punctuation">)</span>  <span class="token comment"># 追記：動画の保存です</span>
    display<span class="token punctuation">(</span>display_animation<span class="token punctuation">(</span>anim<span class="token punctuation">,</span> default_mode<span class="token operator">=</span><span class="token string">'loop'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">ENV <span class="token operator">=</span> <span class="token string">'CartPole-v0'</span>
NUM_DIZITIZED <span class="token operator">=</span> <span class="token number">6</span>
GAMMA <span class="token operator">=</span> <span class="token number">0.99</span>
ETA <span class="token operator">=</span> <span class="token number">0.5</span>
MAX_STEPS <span class="token operator">=</span> <span class="token number">200</span>
NUM_EPISODES <span class="token operator">=</span> <span class="token number">1000</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Agent</span><span class="token punctuation">:</span>
    
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>num_states<span class="token punctuation">,</span>num_actions<span class="token punctuation">)</span><span class="token punctuation">:</span>
    
        self<span class="token punctuation">.</span>brain <span class="token operator">=</span> Brain<span class="token punctuation">(</span>num_states<span class="token punctuation">,</span>num_actions<span class="token punctuation">)</span> <span class="token comment">#生成决定agent动作的brain</span>
    <span class="token comment"># Q函数更新</span>
    <span class="token keyword">def</span> <span class="token function">update_Q_function</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>observation<span class="token punctuation">,</span>action<span class="token punctuation">,</span>reward<span class="token punctuation">,</span>observation_next<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>brain<span class="token punctuation">.</span>update_Q_table<span class="token punctuation">(</span>observation<span class="token punctuation">,</span>action<span class="token punctuation">,</span>reward<span class="token punctuation">,</span>observation_next<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">get_action</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>observation<span class="token punctuation">,</span>step<span class="token punctuation">)</span><span class="token punctuation">:</span>
        action <span class="token operator">=</span> self<span class="token punctuation">.</span>brain<span class="token punctuation">.</span>decide_action<span class="token punctuation">(</span>observation<span class="token punctuation">,</span>step<span class="token punctuation">)</span>
        <span class="token keyword">return</span> action
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Brain</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>num_states<span class="token punctuation">,</span>num_actions<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>num_actions <span class="token operator">=</span> num_actions     <span class="token comment"># 决定单摆的行动 两个选择（left,right）</span>

        self<span class="token punctuation">.</span>q_table <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span>low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>high <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token punctuation">(</span>NUM_DIZITIZED<span class="token operator">**</span>num_states<span class="token punctuation">,</span>num_actions<span class="token punctuation">)</span><span class="token punctuation">)</span> 
        <span class="token comment"># 制作Qtable 行数是离散化后状态4个变量的数值 列数是行动执行数 num_states ：4 num_actions：2 </span>

    <span class="token keyword">def</span> <span class="token function">bins</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>clip_min<span class="token punctuation">,</span>clip_max<span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 记得写self 。。。全是泪</span>
        <span class="token keyword">return</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span>clip_min<span class="token punctuation">,</span>clip_max<span class="token punctuation">,</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> 
        <span class="token comment"># 这里的np.linspace是去生成等间隔数列 </span>
        <span class="token comment"># 对于index来说通常[-1]指的是最后一个元素 </span>
        <span class="token comment">#[-1：1]指的是第二个元素到最后一个元素的前一个元素</span>
        <span class="token comment">#numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None).在指定的间隔内返回均匀间隔的数字。返回num均匀分布的样本，在[start, stop]。</span>


    <span class="token keyword">def</span> <span class="token function">digitize_state</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>observation<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 这里起初错erro为 digitize_state() takes 1 positional argument but 2 were given</span>
        <span class="token comment"># 函数定义的时候忘记写self 只有observation一个参数所以显示错误 因为之后赋予了两个变量</span>

        cart_pos<span class="token punctuation">,</span>cart_v<span class="token punctuation">,</span>pole_angle<span class="token punctuation">,</span>pole_v <span class="token operator">=</span> observation

        digitized <span class="token operator">=</span> <span class="token punctuation">[</span>
        np<span class="token punctuation">.</span>digitize<span class="token punctuation">(</span>cart_pos<span class="token punctuation">,</span>bins <span class="token operator">=</span> self<span class="token punctuation">.</span>bins<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2.4</span><span class="token punctuation">,</span><span class="token number">2.4</span><span class="token punctuation">,</span>NUM_DIZITIZED<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        np<span class="token punctuation">.</span>digitize<span class="token punctuation">(</span>cart_v<span class="token punctuation">,</span>bins <span class="token operator">=</span> self<span class="token punctuation">.</span>bins<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3.0</span><span class="token punctuation">,</span><span class="token number">3.0</span><span class="token punctuation">,</span>NUM_DIZITIZED<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        np<span class="token punctuation">.</span>digitize<span class="token punctuation">(</span>pole_angle<span class="token punctuation">,</span>bins <span class="token operator">=</span> self<span class="token punctuation">.</span>bins<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">,</span>NUM_DIZITIZED<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">##pole_angle是rad单位</span>
        np<span class="token punctuation">.</span>digitize<span class="token punctuation">(</span>pole_v<span class="token punctuation">,</span>bins <span class="token operator">=</span> self<span class="token punctuation">.</span>bins<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">,</span><span class="token number">2.0</span><span class="token punctuation">,</span>NUM_DIZITIZED<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">]</span>
        <span class="token comment">#被赋予了两个形参 因为= 后方写成bins而不是self.bins</span>
        <span class="token keyword">return</span> <span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token operator">*</span><span class="token punctuation">(</span>NUM_DIZITIZED<span class="token operator">**</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i<span class="token punctuation">,</span>x <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>digitized<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> 
            <span class="token comment"># 通过enumerate()遍历列表获得一个索引序列，同时获得索引和值。这里返回值是状态函数的离散化后的表现形式</span>
    <span class="token comment"># 假设离散化后的列表为[1,2,3,4] 则状态 = 1*1 +2*6+3*36+4*216 = 985</span>
    <span class="token keyword">def</span> <span class="token function">update_Q_table</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> observation<span class="token punctuation">,</span> action<span class="token punctuation">,</span> reward<span class="token punctuation">,</span> observation_next<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">'''QテーブルをQ学習により更新'''</span>
        state <span class="token operator">=</span> self<span class="token punctuation">.</span>digitize_state<span class="token punctuation">(</span>observation<span class="token punctuation">)</span>  <span class="token comment"># 状態を離散化</span>
        state_next <span class="token operator">=</span> self<span class="token punctuation">.</span>digitize_state<span class="token punctuation">(</span>observation_next<span class="token punctuation">)</span>  <span class="token comment"># 次の状態を離散化</span>
        Max_Q_next <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>q_table<span class="token punctuation">[</span>state_next<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>q_table<span class="token punctuation">[</span>state<span class="token punctuation">,</span> action<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>q_table<span class="token punctuation">[</span>state<span class="token punctuation">,</span> action<span class="token punctuation">]</span> <span class="token operator">+</span> ETA <span class="token operator">*</span> <span class="token punctuation">(</span>reward <span class="token operator">+</span> GAMMA <span class="token operator">*</span> Max_Q_next <span class="token operator">-</span> self<span class="token punctuation">.</span>q_table<span class="token punctuation">[</span>state<span class="token punctuation">,</span> action<span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">decide_action</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>observation<span class="token punctuation">,</span>episode<span class="token punctuation">)</span><span class="token punctuation">:</span>
        state <span class="token operator">=</span> self<span class="token punctuation">.</span>digitize_state<span class="token punctuation">(</span>observation<span class="token punctuation">)</span>
        epsilon <span class="token operator">=</span> <span class="token number">0.5</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token punctuation">(</span>episode <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># epsilon 概率下随机执行行动 1-epsilon的概率下执行Q价值最大行动 概率随时间变化</span>

        <span class="token keyword">if</span> epsilon <span class="token operator">&lt;=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            action <span class="token operator">=</span> np<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>self<span class="token punctuation">.</span>q_table<span class="token punctuation">[</span>state<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            action <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>self<span class="token punctuation">.</span>num_actions<span class="token punctuation">)</span>
        <span class="token keyword">return</span> action<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Environment</span> <span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>env <span class="token operator">=</span> gym<span class="token punctuation">.</span>make<span class="token punctuation">(</span>ENV<span class="token punctuation">)</span>  <span class="token comment">#将模型环境设定</span>
        num_states <span class="token operator">=</span> self<span class="token punctuation">.</span>env<span class="token punctuation">.</span>observation_space<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment">#获取状态变量种类数量4</span>
        num_actions <span class="token operator">=</span> self<span class="token punctuation">.</span>env<span class="token punctuation">.</span>action_space<span class="token punctuation">.</span>n      <span class="token comment"># 获取行动执行种类数量2</span>
        self<span class="token punctuation">.</span>agent <span class="token operator">=</span> Agent<span class="token punctuation">(</span>num_states<span class="token punctuation">,</span>num_actions<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>

        complete_episodes <span class="token operator">=</span> <span class="token number">0</span>
        is_episode_final <span class="token operator">=</span> <span class="token boolean">False</span>
        frames <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        <span class="token keyword">for</span> episode <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>NUM_EPISODES<span class="token punctuation">)</span><span class="token punctuation">:</span>
            observation <span class="token operator">=</span> self<span class="token punctuation">.</span>env<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">#环境的初始化</span>
            <span class="token keyword">for</span> step <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>MAX_STEPS<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> is_episode_final <span class="token keyword">is</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token comment">#当此次试行是最终试行的话 就将各个时刻的画像追加到frames里面</span>
                    frames<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>env<span class="token punctuation">.</span>render<span class="token punctuation">(</span>mode <span class="token operator">=</span> <span class="token string">'rgb_array'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

                action <span class="token operator">=</span> self<span class="token punctuation">.</span>agent<span class="token punctuation">.</span>get_action<span class="token punctuation">(</span>observation<span class="token punctuation">,</span>episode<span class="token punctuation">)</span> <span class="token comment"># 行动计算</span>
                observation_next<span class="token punctuation">,</span> _ <span class="token punctuation">,</span>done<span class="token punctuation">,</span> _ <span class="token operator">=</span> self<span class="token punctuation">.</span>env<span class="token punctuation">.</span>step<span class="token punctuation">(</span>action<span class="token punctuation">)</span> <span class="token comment"># reward 和 info不使用 这里用 _</span>

                <span class="token keyword">if</span> done<span class="token punctuation">:</span>  <span class="token comment"># 这里的done代表当前试行结束 结束条件为 step超过200 或者模型超过一定角度</span>
                    <span class="token keyword">if</span> step <span class="token operator">&lt;</span> <span class="token number">195</span><span class="token punctuation">:</span> <span class="token comment"># 195step内如果倒了则reward给与-1</span>
                        reward  <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
                        complete_episodes <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 未成功则归0</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        reward <span class="token operator">=</span> <span class="token number">1</span>
                        complete_episodes <span class="token operator">+=</span><span class="token number">1</span> <span class="token comment">#记录更新</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    reward <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">#试行中途的reward为0</span>

                self<span class="token punctuation">.</span>agent<span class="token punctuation">.</span>update_Q_function<span class="token punctuation">(</span>observation<span class="token punctuation">,</span>action<span class="token punctuation">,</span>reward<span class="token punctuation">,</span>observation_next<span class="token punctuation">)</span> 
                <span class="token comment"># 这里注意缩进 因为这里Q更新是在for step in range(MAX_STEPS)条件下的操作</span>
                <span class="token comment">#step+1的状态下 通过observation_next来更新Q函数</span>
                observation <span class="token operator">=</span> observation_next

                <span class="token keyword">if</span> done<span class="token punctuation">:</span> <span class="token comment">#试行结束 是否和之前的条件语句调换位置 依然不影响结果？ </span>
                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'&#123;0&#125; Episode: Finish after &#123;1&#125; time steps'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>episode<span class="token punctuation">,</span>step <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">break</span>

            <span class="token keyword">if</span> is_episode_final <span class="token keyword">is</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
                display_frames_as_gif<span class="token punctuation">(</span>frames<span class="token punctuation">)</span>
                <span class="token keyword">break</span>

            <span class="token keyword">if</span> complete_episodes <span class="token operator">>=</span> <span class="token number">10</span><span class="token punctuation">:</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'１０回連続成功'</span><span class="token punctuation">)</span>
                is_episode_final <span class="token operator">=</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">cartpole_env <span class="token operator">=</span> Environment<span class="token punctuation">(</span><span class="token punctuation">)</span>
cartpole_env<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre><code>0 Episode: Finish after 28 time steps
1 Episode: Finish after 10 time steps
2 Episode: Finish after 21 time steps
3 Episode: Finish after 26 time steps
4 Episode: Finish after 16 time steps
5 Episode: Finish after 12 time steps
6 Episode: Finish after 26 time steps
7 Episode: Finish after 9 time steps
8 Episode: Finish after 16 time steps
9 Episode: Finish after 17 time steps
10 Episode: Finish after 25 time steps
11 Episode: Finish after 12 time steps
12 Episode: Finish after 9 time steps
13 Episode: Finish after 43 time steps
14 Episode: Finish after 15 time steps
15 Episode: Finish after 12 time steps
16 Episode: Finish after 9 time steps
17 Episode: Finish after 74 time steps
18 Episode: Finish after 48 time steps
19 Episode: Finish after 22 time steps
20 Episode: Finish after 32 time steps
</code></pre>
<p>.<br>.<br>.<br>    140 Episode: Finish after 37 time steps<br>    141 Episode: Finish after 200 time steps<br>    142 Episode: Finish after 200 time steps<br>    143 Episode: Finish after 185 time steps<br>    144 Episode: Finish after 185 time steps<br>    145 Episode: Finish after 162 time steps<br>.<br>.<br>.<br>    241 Episode: Finish after 200 time steps<br>    242 Episode: Finish after 140 time steps<br>    243 Episode: Finish after 200 time steps<br>    244 Episode: Finish after 200 time steps<br>    245 Episode: Finish after 200 time steps<br>    246 Episode: Finish after 200 time steps<br>    247 Episode: Finish after 146 time steps<br>    248 Episode: Finish after 186 time steps<br>    249 Episode: Finish after 200 time steps<br>    250 Episode: Finish after 179 time steps<br>    251 Episode: Finish after 127 time steps<br>    252 Episode: Finish after 112 time steps<br>    253 Episode: Finish after 105 time steps<br>    254 Episode: Finish after 200 time steps<br>    255 Episode: Finish after 200 time steps<br>    256 Episode: Finish after 200 time steps<br>    257 Episode: Finish after 110 time steps<br>    258 Episode: Finish after 85 time steps<br>    259 Episode: Finish after 31 time steps<br>    260 Episode: Finish after 91 time steps<br>    261 Episode: Finish after 200 time steps<br>    262 Episode: Finish after 200 time steps<br>    263 Episode: Finish after 200 time steps<br>    264 Episode: Finish after 131 time steps<br>    265 Episode: Finish after 180 time steps<br>    266 Episode: Finish after 139 time steps<br>    267 Episode: Finish after 99 time steps<br>    268 Episode: Finish after 135 time steps<br>    269 Episode: Finish after 129 time steps<br>    270 Episode: Finish after 184 time steps<br>    271 Episode: Finish after 123 time steps<br>    272 Episode: Finish after 78 time steps<br>    273 Episode: Finish after 174 time steps<br>    274 Episode: Finish after 169 time steps<br>    275 Episode: Finish after 140 time steps<br>    276 Episode: Finish after 200 time steps<br>    277 Episode: Finish after 111 time steps<br>    278 Episode: Finish after 125 time steps<br>    279 Episode: Finish after 96 time steps<br>    280 Episode: Finish after 200 time steps<br>    281 Episode: Finish after 185 time steps<br>    282 Episode: Finish after 97 time steps<br>    283 Episode: Finish after 200 time steps<br>    284 Episode: Finish after 184 time steps<br>    285 Episode: Finish after 143 time steps<br>    286 Episode: Finish after 200 time steps<br>    287 Episode: Finish after 200 time steps<br>   .<br>   .<br>   .<br>    393 Episode: Finish after 200 time steps<br>    394 Episode: Finish after 196 time steps<br>    395 Episode: Finish after 200 time steps<br>    396 Episode: Finish after 200 time steps<br>    397 Episode: Finish after 200 time steps<br>    398 Episode: Finish after 200 time steps<br>    399 Episode: Finish after 200 time steps<br>    400 Episode: Finish after 200 time steps<br>    401 Episode: Finish after 200 time steps<br>    402 Episode: Finish after 200 time steps<br>    １０回連続成功<br>    403 Episode: Finish after 200 time steps</p>
<p><img src="/image/44.gif" alt="gif"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Q学习实例</tag>
      </tags>
  </entry>
  <entry>
    <title>算法面试7-动态规划</title>
    <url>/2021/04/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="动态规划">动态规划</span></h2><h3><span id="记忆化搜索">记忆化搜索</span></h3><p>斐波那契数列<br>自上而下的解决问题</p>
<pre class="line-numbers language-none"><code class="language-none">vector&lt;int&gt; memo;
int fib(int n)&#123;
    if(n &#x3D;&#x3D; 0)
        return 0;
    if(n &#x3D;&#x3D; 1)
        return 1;
    if(memo[n] &#x3D;&#x3D; -1)&#123;
        &#x2F;&#x2F;这里设定如果memo[n]所对应的fib()没有计算过则为-1
        memo[n]&#x3D; fib(n-1)+fib(n-2);
    return memo[n];
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="动态规划">动态规划</span></h3><p>自下而上的解决问题</p>
<pre class="line-numbers language-none"><code class="language-none">int fib(int n)&#123;
    vector&lt;int&gt; memo(n+1,-1);
    memo[0] &#x3D; 0;
    memo[1] &#x3D; 1;
    if(int i &#x3D;0;i&lt;&#x3D;n;i++)
        memo[i] &#x3D; memo[i-1]+memo[i-2];
        &#x2F;&#x2F;自下而上的计算方式自动避免了重叠子问题
    return memo[n];
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题70<br>以下代码，多次重叠，时间超时</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
private:
    int calcWays(int n)&#123;
        if(n &#x3D;&#x3D; 0||n&#x3D;&#x3D;1)
            return 1;
        return calcWays(n-1)+calcWays(n-2);
    &#125;
public:
    int climbStairs(int n)&#123;
        return calcWays(n);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>改进，记忆化搜索</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
private:
    vector&lt;int&gt; memo;
    int calcWays(int n)&#123;
        if(n &#x3D;&#x3D; 0||n&#x3D;&#x3D;1)
            return 1;
        if(memo[n] &#x3D;&#x3D; -1)
            memo[n] &#x3D;  calcWays(n-1)+calcWays(n-2);
        return memo[n];
    &#125;
public:
    int climbStairs(int n)&#123;
        memo &#x3D; vector&lt;int&gt;(n+1,-1);
        return calcWays(n);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>动态规划</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
public:
    int climbStairs(int n)&#123;
        vector&lt;int&gt; memo(n+1,-1);
        memo[0] &#x3D; 1;
        memo[1] &#x3D; 1;
        &#x2F;&#x2F;从索引2开始。自下而上动态规划。
        for(int i &#x3D; 2;i&lt;&#x3D;n;i++)
            memo[i] &#x3D; memo[i-1]+memo[i-2];

        return memo[n];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题120<br>例题64<br>例题343<br>最优子结构<br>通过求子问题的最优解，可以获得原问题的最优解</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
private:
    vector&lt;int&gt; memo;
    int max3(int a,int b,int c)&#123;
        return max(a,max(b,c));
    &#125;
    &#x2F;&#x2F;将n进行分割（至少分割两部分），可以获得的最大乘积
    int breakInteger(int n)&#123;
        if(n&#x3D;&#x3D;1)
            return 1;
        if(memo[n]!&#x3D; -1)
            return memo[n];
        int res &#x3D; -1;

        for(int i &#x3D;1;i&lt;&#x3D;n-1;i++)
        &#x2F;&#x2F;i + (n-i) 分割至少为两部分
            res &#x3D; max3(res,i*(n-i),i* breakInteger(n-i));
            &#x2F;&#x2F;这里因为i * breakInteger(n-i)不包括i * (n-i),所以三者比较
        memo[n] &#x3D; res;
        return res;


    &#125;
public:
    int integerBreak(int n)&#123;
        memo &#x3D; vector&lt;int&gt;(n+1,-1);
        return breakInteger(n);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
private:
    int max3(int a,int b,int c)&#123;
        return max(a,max(b,c));
    &#125;
public:
    int integerBreak(int n)&#123;
        assert(n&gt;&#x3D;2);
        vector&lt;int&gt; memo(n+1,-1);
        memo[1] &#x3D; 1;
        for(int i &#x3D;2;i&lt;&#x3D;n;i++)
            &#x2F;&#x2F;求解memo[i]
            for(int j &#x3D; 1;j&lt;&#x3D;i-1;j++)
            &#x2F;&#x2F;将i进行分割 j+(i-j)
                memo[i] &#x3D; max3(memo[i],j* (i-j),j*memo[i-j]);
        return memo[n];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题279<br>例题91<br>例题62<br>例题63</p>
<p>例题198 House robber</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
private:
    &#x2F;&#x2F;记忆化搜索
    vector&lt;int&gt; memo;
    int tryRob(vector&lt;int&gt; &amp;nums,int index)&#123;
        if(index&gt;&#x3D;nums.size())
            return 0;
        if(memo[index] !&#x3D; -1)
            return memo[index];
        int res &#x3D; 0;
        for(int i &#x3D; index;i&lt;nums.size();i++)
            res &#x3D; max(res,nums[i] + tryRob(nums,i+2));
        memo[index] &#x3D; res;
        return res;
    &#125;
public:
    int rob(vector&lt;int&gt; &amp;nums)&#123;
        memo &#x3D; vector&lt;int&gt; (nums.size(),-1);
        return tryRob(nums,0);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
public:
    int rob(vector&lt;int&gt; &amp;nums)&#123;
        int n &#x3D;nums.size();
        if(n &#x3D;&#x3D; 0)
            return 0;
        vector&lt;int&gt; memo (n,-1);
        &#x2F;&#x2F;memo[i]表示考虑抢劫nums[i..n-1]所能获得的最大收益
        memo[n-1] &#x3D; nums[n-1]
        for(int i &#x3D; n-2;i&gt;&#x3D;0;i--)
            &#x2F;&#x2F;memo[i]
            for(int j &#x3D; i;j&lt;n;j++)
                memo[i] &#x3D; max(memo[i],nums[j] + (j+2&lt;n ?  memo[j+2] : 0));
        return memo[0];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题213 House Robber II</p>
<p>例题337 House Robber III</p>
<p>例题309</p>
<h3><span id="背包问题">背包问题</span></h3><p>有一个背包，容量为C。现有n种不同的物品，编号为0…n-1,其中每一件物品重量为w(i),价值为v(i).使得不超过背包容量的基础上，总价值最大</p>
<p>暴力解法O((2^n) * n)</p>
<p>贪心算法？优先放入平均价值最高的物品？<br>F(n,C) 考虑将n个物品放进容量为C的背包，使得价值最大<br>F(i,C) = F(i-1,c)                  –&gt; max<br>       = v(i) + F(i-1,c-w(i))</p>
<p>F(i,c) = max(F(i-1,c),v(i) + F(i-1,c-w(i)))</p>
<pre class="line-numbers language-none"><code class="language-none">class Knapsack01&#123;
private:    
    vector&lt;vector&lt;int&gt;&gt; memo;

    &#x2F;&#x2F;用[0...index]的物品，填充容积为c的背包的最大价值
    int bestValue(const vector&lt;int&gt; &amp;w,const vector&lt;int&gt; &amp;v,int index,int C)&#123;
        if(index &lt; 0 || c&lt;&#x3D; 0)
            return 0;
        if(memo[index][c] !&#x3D; -1)
            return memo[index][c];
        int res &#x3D; bestValue(w,v,index-1,c); &#x2F;&#x2F;res为不选择index的策略
        if(c &gt; &#x3D; w[index])
            res &#x3D; max(res,v[index] + bestValue(w,v,index-1,c-w[index]));
            &#x2F;&#x2F;选择index的策略
        memo[index][c] &#x3D; res;
        return res;


    &#125;
public:
    int knapsack01(const vector&lt;int&gt; &amp;w,const vector&lt;int&gt; &amp;v,int C)&#123;
        int n &#x3D; w.size();
        memo &#x3D; vector&lt;vector&lt;int&gt;&gt;(n,vector&lt;int&gt;(C+1,-1))
        return bestValue(w,v,n-1,C); 
        &#x2F;&#x2F;设定约束条件
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>动态规划</p>
<pre class="line-numbers language-none"><code class="language-none">class Knapsack01&#123;
public:
    int knapsack01(const vector&lt;int&gt; &amp;w,const vector&lt;int&gt; &amp;v,int C)&#123;
        assert(w.size() &#x3D;&#x3D; v.size() );
        int n &#x3D; w.size();
        if(n &#x3D;&#x3D; 0 || C &#x3D; 0) 
            return 0;
        vector&lt;vector&lt;int&gt;&gt; memo (2,vector&lt;int&gt;(C+1,-1));

        for(int j &#x3D; 0;j&lt; &#x3D; C;j++)
        &#x2F;&#x2F;物品  的背包容量
            memo[0][j] &#x3D; (j&gt; &#x3D; w[0] ? v[0] : 0)；
        for(int i &#x3D;1;i&lt;n;i++)
            for(int j &#x3D;0;j&lt;&#x3D;C;j++ )&#123;
                memo[i%2][j] &#x3D; memo[(i-1)%2][j]; &#x2F;&#x2F;第一种策略[i]物品不放入 跳到[i-1]物品
                if(j &gt;&#x3D; w[i] ) &#x2F;&#x2F;如果对于第[i]个物品来说 容量j &gt;w[i]

                &#x2F;&#x2F;重点max中的第一个memo[i][j]为上一步赋值的memo[i-1][j]
                
                    memo[i%2][j] &#x3D; max(memo[i%2][j],v[i] + memo[(i-1)%2][j-w[i]]);
            &#125;
        return memo [(n-1)%2][C];
        &#x2F;&#x2F;设定约束条件
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>优化</p>
<pre class="line-numbers language-none"><code class="language-none">class Knapsack01&#123;
public:
    int knapsack01(const vector&lt;int&gt; &amp;w,const vector&lt;int&gt; &amp;v,int C)&#123;
        assert(w.size() &#x3D;&#x3D; v.size() );
        int n &#x3D; w.size();
        if(n &#x3D;&#x3D; 0 || C &#x3D; 0) 
            return 0;
        &lt;vector&lt;int&gt; memo (C+1,-1));

        for(int j &#x3D; 0;j&lt; &#x3D; C;j++)
            for(int j &#x3D; C;j&gt;&#x3D;w[i];j-- )&#123;
                &#x2F;&#x2F;当背包剩余容量j&lt;w[i]时终止，否则依次放入物品，max选取最优策略
                &#x2F;&#x2F;放入当前物品或者跳过当前物品
                    memo[j] &#x3D; max(memo[j],v[i] + memo[j-w[i]]);
            &#125;
        return memo [C];
        &#x2F;&#x2F;设定约束条件
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题416 Partition equal subset sum</p>
<pre class="line-numbers language-none"><code class="language-none">class Knapsack01&#123;
private:
    &#x2F;&#x2F;memo[i][c]表示使用索引[0....i]的这些元素，是否可以完全填充一个容量为c的背包
    &#x2F;&#x2F;-1表示未计算 0表示不能被填充 1表示可以填充
    vector&lt;vector&lt;int&gt;&gt; memo;
    &#x2F;&#x2F; 使用nums[0..index]是否可以完全填充容量为sum的背包
    bool tryPartition(const vector&lt;int&gt; nums,int index,int sum)&#123;
        if(sum &#x3D;&#x3D; 0)
            return true;
        if(sum &lt; 0 || index &lt; 0)
            return false;
        if(memo[index][sum] !&#x3D; -1)
            return memo[index][sum] &#x3D;&#x3D; 1;
        memo[index][sum] &#x3D; tryPartition(nums,index-1,sum) ||
            tryPartition(nums,index-1,sum-nums[index]) ?1 :0;
        return memo[index][sum] &#x3D;&#x3D;1;
    &#125;
public:
    bool canPartition(vector&lt;int&gt; nums)&#123;
        int sum &#x3D; 0;
        for(int i &#x3D; 0;i&lt;nums.size(),i++)&#123;
            assert(nums[i] &gt; 0);
            sum +&#x3D; nums[i];
        &#125;
        if(sum%2 !&#x3D; 0)
            return false;
        memo &#x3D; vector&lt;vector&lt;int&gt;&gt; (nums.size(),vector&lt;int&gt;(sum&#x2F;2 +1,-1));
        return tryPartition(nums,nums.size()-1,sum&#x2F;2 );
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>动态规划 背包问题</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
public:
    bool canPartition(vector&lt;int&gt; &amp; nums)&#123;
        int sum &#x3D; 0;
        for(int i &#x3D; 0;i&lt;nums.size();i++)&#123;
            assert(nums[i] &gt; 0);
            sum +&#x3D; nums[i];
        &#125;
        if(sum%2)
            return false;
        int n &#x3D; nums.size();
        int C &#x3D; sum&#x2F;2;
        vector&lt;bool&gt; memo (C+1,false);
        for(int i &#x3D; 0;i&lt;&#x3D; C;i++)
            memo[i] &#x3D; (nums[0] &#x3D;&#x3D; i);
        for(int i &#x3D;1;i&lt;n;i++)
            for(int j &#x3D; C;j&gt;&#x3D;nums[i];j--)
                memo[j]  &#x3D; memo[j] || memo[j-nums[i]];
        return memo[C];
        &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题322 Coin change<br>例题377 Combination Sum IV<br>例题474 Ones and zeroes<br>例题139 Word Break<br>例题494 target sum</p>
<p>例题300 最长上升子序列</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
public:
    int lengthOfLIS(vector&lt;int&gt; &amp; nums)&#123;
        if(nums.size() &#x3D;&#x3D; 0)
            return 0;
        vecotr&lt;int&gt; memo(nums.size(),1);
        for(int i &#x3D; 1; i &lt; nums.size();i++)
            for(int j &#x3D; 0; j&lt;i;j++)
                if(nums[j] &lt; nums [i])
                    memo[i] &#x3D; max(memo[i],1+memo[j]);
        &#x2F;&#x2F; 将以i结尾的memo[i]的最大值都计算出来
        int res &#x3D; 1;
        for(int i &#x3D; 0,i&lt;nums.size();i++)
            res &#x3D; max(res,memo[i]);
        return res;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题376</p>
<h2><span id="更多关于动态规划">更多关于动态规划</span></h2><h3><span id="最长公共子序列-lcs">最长公共子序列 （LCS)</span></h3><h3><span id="dijkstra-单源最短路径算法">dijkstra 单源最短路径算法</span></h3><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法面试</tag>
      </tags>
  </entry>
  <entry>
    <title>博客报错</title>
    <url>/2021/02/04/%E5%8D%9A%E5%AE%A2%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>写博客时包含代码 以为不能输入代码<br>报错提示如下：<br>–Context Dump Ends<br>=====\u001b[39m’ } } ‘Something&#39;s wrong. Maybe you can find the solution here: %s’ ‘\u001b[4m<a href="https://hexo.io/docs/troubleshooting.html/u001b[24m&#39;">https://hexo.io/docs/troubleshooting.html\u001b[24m&#39;</a><br>因为我在文章里写了{ { } }<br>hexo 的文章渲染使用的是 Nunjucks ，因为在使用mathjax公式，造成了{ {重叠，而它会在生成文章时将那几个大括号识别成自己的语法，这样就会报错。<br>解决办法：<br> 在括号之间添加空格 文本可识别</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo erro</tag>
      </tags>
  </entry>
  <entry>
    <title>图像分析</title>
    <url>/2021/03/03/%E5%9B%BE%E5%83%8F%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> fetch_openml
mnist <span class="token operator">=</span> fetch_openml<span class="token punctuation">(</span><span class="token string">'mnist_784'</span><span class="token punctuation">,</span>version <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>data_home <span class="token operator">=</span> <span class="token string">"."</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">X <span class="token operator">=</span> mnist<span class="token punctuation">.</span>data<span class="token operator">/</span><span class="token number">255</span>
y <span class="token operator">=</span> mnist<span class="token punctuation">.</span>target
<span class="token comment"># 2019年1月31日訂正</span>
<span class="token comment"># MNISTのデータセットの変更により、ラベルが数値データになっていないので、</span>
<span class="token comment"># 以下により、NumPyの配列の数値型に変換します</span>
<span class="token comment">#mnist数据库变更  label没有变成数值 这里通过numpy来变成数值输出</span>
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
y <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
y <span class="token operator">=</span> y<span class="token punctuation">.</span>astype<span class="token punctuation">(</span>np<span class="token punctuation">.</span>int32<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt
<span class="token operator">%</span>matplotlib inline

plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>X<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmap<span class="token operator">=</span><span class="token string">'gray'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"この画像データのラベルは&#123;: .0f&#125;です"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>この画像データのラベルは 5です
</code></pre>
<p><img src="/image/output_2_1.png" alt="png"></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 制作dataloader</span>
<span class="token keyword">import</span> torch
<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> TensorDataset<span class="token punctuation">,</span>DataLoader
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_split
X_train<span class="token punctuation">,</span>X_test<span class="token punctuation">,</span>y_train<span class="token punctuation">,</span>y_test <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>X<span class="token punctuation">,</span>y<span class="token punctuation">,</span>test_size <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">7</span><span class="token punctuation">,</span>random_state <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#将数据转换成pytorch的张量tensor</span>
<span class="token comment">#在深度学习中，Tensor实际上就是一个多维数组（multidimensional array）其目的是能够创造更高维度的矩阵、向量。</span>
X_train <span class="token operator">=</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span>X_train<span class="token punctuation">)</span>
X_test <span class="token operator">=</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span>X_test<span class="token punctuation">)</span>
y_train <span class="token operator">=</span> torch<span class="token punctuation">.</span>LongTensor<span class="token punctuation">(</span>y_train<span class="token punctuation">)</span>
y_test <span class="token operator">=</span> torch<span class="token punctuation">.</span>LongTensor<span class="token punctuation">(</span>y_test<span class="token punctuation">)</span>
<span class="token comment"># 创建一个数据表dataset 包含数据和标签</span>
ds_train <span class="token operator">=</span> TensorDataset<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span>y_train<span class="token punctuation">)</span>
ds_test <span class="token operator">=</span> TensorDataset<span class="token punctuation">(</span>X_test<span class="token punctuation">,</span>y_test<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># BATCH_SIZE:即一次训练所抓取的数据样本数量；</span>
<span class="token comment"># BATCH_SIZE的大小影响训练速度和模型优化。同时按照以上代码可知，其大小同样影响每一epoch训练模型次数。</span>
<span class="token comment"># shuffle（中文意思：洗牌，混乱）。shuffle在机器学习与深度学习中代表的意思是，将训练模型的数据集进行打乱的操作。</span>
<span class="token comment"># 原始的数据，在样本均衡的情况下可能是按照某种顺序进行排列，如前半部分为某一类别的数据，后半部分为另一类别的数据。</span>
<span class="token comment"># 但经过打乱之后数据的排列就会拥有一定的随机性，在顺序读取的时候下一次得到的样本为任何一类型的数据的可能性相同。</span>
<span class="token comment"># shuffle 可以防止过拟合</span>
loader_train <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>ds_train<span class="token punctuation">,</span>batch_size <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">,</span>shuffle <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span>
loader_test <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>ds_test<span class="token punctuation">,</span>batch_size <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">,</span>shuffle <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#Keras</span>
<span class="token keyword">from</span> torch <span class="token keyword">import</span> nn
model <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 构建神经网络fc1,fc2,fc3三层</span>
model<span class="token punctuation">.</span>add_module<span class="token punctuation">(</span><span class="token string">'fc1'</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">28</span><span class="token operator">*</span><span class="token number">28</span><span class="token operator">*</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#输入784 输出100</span>
model<span class="token punctuation">.</span>add_module<span class="token punctuation">(</span><span class="token string">'relu1'</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 输出的100个 通过ReLU转换 负数转换为0 正数原值输出</span>
model<span class="token punctuation">.</span>add_module<span class="token punctuation">(</span><span class="token string">'fc2'</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
model<span class="token punctuation">.</span>add_module<span class="token punctuation">(</span><span class="token string">'relu2'</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
model<span class="token punctuation">.</span>add_module<span class="token punctuation">(</span><span class="token string">'fc3'</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 输出标签0-9 共十个分支</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Sequential(<br>(fc1): Linear(in_features=784, out_features=100, bias=True)<br>(relu1): ReLU()<br>(fc2): Linear(in_features=100, out_features=100, bias=True)<br>(relu2): ReLU()<br>(fc3): Linear(in_features=100, out_features=10, bias=True)<br>)</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 误差函数和最优化</span>
<span class="token keyword">from</span> torch <span class="token keyword">import</span> optim
<span class="token comment"># 误差函数设定</span>
loss_fn <span class="token operator">=</span> nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 权重学习的最优化选择</span>
optimizer <span class="token operator">=</span> optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>lr <span class="token operator">=</span> <span class="token number">0.01</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>adams 算法<br>Adam(Adaptive Moment Estimation)本质上是带有动量项的RMSprop，它利用梯度的一阶矩估计和二阶矩估计动态调整每个参数的学习率。<br>它的优点主要在于经过偏置校正后，每一次迭代学习率都有个确定范围，使得参数比较平稳。其公式如下：</p>
<p><img src="/image/adam.png"></p>
<p>其中，前两个公式分别是对梯度的一阶矩估计和二阶矩估计，可以看作是对期望E|gt|，E|gt^2|的估计;<br>公式3，4是对一阶二阶矩估计的校正，这样可以近似为对期望的无偏估计。可以看出，直接对梯度的矩估计对内存没有额外的要求，而且可以根据梯度进行动态调整。最后一项前面部分是对学习率n形成的一个动态约束，而且有明确的范围。</p>
<p>params(iterable)：可用于迭代优化的参数或者定义参数组的dicts。<br>lr (float, optional) ：学习率(默认: 1e-3)<br>betas (Tuple[float, float], optional)：用于计算梯度的平均和平方的系数(默认: (0.9, 0.999))<br>eps (float, optional)：为了提高数值稳定性而添加到分母的一个项(默认: 1e-8)<br>weight_decay (float, optional)：权重衰减(如L2惩罚)(默认: 0)</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">train</span><span class="token punctuation">(</span>epoch<span class="token punctuation">)</span><span class="token punctuation">:</span>
    model<span class="token punctuation">.</span>train<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> data<span class="token punctuation">,</span>targets <span class="token keyword">in</span> loader_train<span class="token punctuation">:</span>
        optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#计算后归零</span>
        outputs <span class="token operator">=</span> model<span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token comment"># 输入data 求输出</span>
        loss <span class="token operator">=</span> loss_fn<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span>targets<span class="token punctuation">)</span> <span class="token comment"># 计算输出和训练数据正确值的误差</span>
        loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>
        optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"epoch&#123;&#125;:终止\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>epoch<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    model<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#推理模式</span>
    correct <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">#?推导不需要微分？</span>
        <span class="token keyword">for</span> data <span class="token punctuation">,</span>targets <span class="token keyword">in</span> loader_test<span class="token punctuation">:</span>
            outputs <span class="token operator">=</span> model<span class="token punctuation">(</span>data<span class="token punctuation">)</span> 
            _<span class="token punctuation">,</span>predicted <span class="token operator">=</span> torch<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>outputs<span class="token punctuation">.</span>data<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">#计算概率最高的标签</span>
            <span class="token comment">#torch.max(a, 0): 返回每一列的最大值，且返回索引（返回最大元素在各列的行索引）。</span>

            <span class="token comment">#torch.max(a, 1): 返回每一行的最大值，且返回索引（返回最大元素在各行的列索引）。</span>
            <span class="token comment"># 注意运算符的全角半角</span>
            correct <span class="token operator">+=</span> predicted<span class="token punctuation">.</span>eq<span class="token punctuation">(</span>targets<span class="token punctuation">.</span>data<span class="token punctuation">.</span>view_as<span class="token punctuation">(</span>predicted<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">#如果和正确值一致，计数加一 </span>
    data_num <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>loader_test<span class="token punctuation">.</span>dataset<span class="token punctuation">)</span> <span class="token comment">#数据的总数</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\n 实验数据的正确率：&#123;&#125;/&#123;&#125; (&#123;: .0f&#125;%) \n'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>correct<span class="token punctuation">,</span>data_num<span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">.</span> <span class="token operator">*</span>correct<span class="token operator">/</span>data_num<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">test<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 初始不学习进行推导 </span>
<span class="token comment"># 这个时候的准确率和随机选择的概率接近</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre><code> 实验数据的正确率：1142/10000 ( 11%) 
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    train<span class="token punctuation">(</span>epoch<span class="token punctuation">)</span>

test<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>epoch0:终止

epoch1:终止

epoch2:终止


 实验数据的正确率：9565/10000 ( 96%) 
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">index <span class="token operator">=</span> <span class="token number">2018</span>
model<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
data <span class="token operator">=</span> X_test<span class="token punctuation">[</span>index<span class="token punctuation">]</span>
output <span class="token operator">=</span> model<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
_<span class="token punctuation">,</span>predicted <span class="token operator">=</span> torch<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>output<span class="token punctuation">.</span>data<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"预测结果是&#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>predicted<span class="token punctuation">)</span><span class="token punctuation">)</span>
X_test_show <span class="token operator">=</span> <span class="token punctuation">(</span>X_test<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>X_test_show<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">28</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">,</span>cmap <span class="token operator">=</span> <span class="token string">'gray'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这个画像数据的正确标签是&#123;: .0f&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>y_test<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>预测结果是2
这个画像数据的正确标签是 2
</code></pre>
<p><img src="/image/output_13_1.png" alt="png"></p>
<pre class="line-numbers language-none"><code class="language-none">import torch.nn as nn
import torch.nn.functional as F
class Net(nn.Module):
  def __init__(self,n_in,n_mid,n_out):
    super(Net,self).__init__()
    self.fc1 &#x3D; nn.Linear(n_in,n_mid)
    self.fc2 &#x3D; nn.Linear(n_mid,n_mid)
    self.fc3 &#x3D; nn.Linear(n_mid,n_out)

  def forward(self,x):
    h1 &#x3D; F.relu(self.fc1(x))
    h2 &#x3D; F.relu(self.fc2(h1))
    output &#x3D; self.fc3(h2)
    return output

model &#x3D; Net(n_in &#x3D; 28*28*1,n_mid &#x3D; 100,n_out &#x3D; 10)
print(model)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Net(<br>  (fc1): Linear(in_features=784, out_features=100, bias=True)<br>  (fc2): Linear(in_features=100, out_features=100, bias=True)<br>  (fc3): Linear(in_features=100, out_features=10, bias=True)<br>)</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>图像分析</tag>
      </tags>
  </entry>
  <entry>
    <title>头文件介绍</title>
    <url>/2021/02/15/%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>stdio.h就是指“standard input&amp;output”<br>  意思就是说标准输入输出头文件！<br>  所以了，用到标准输入输出函数时，就要调用这个头文件</p>
<h2><span id="c-头文件">C 头文件</span></h2><p>  include &lt;assert.h&gt;   //设定插入点<br>  include &lt;ctype.h&gt;    //字符处理<br>  include &lt;errno.h&gt;    //定义错误码<br>  include &lt;float.h&gt;    //浮点数处理<br>  include &lt;fstream.h&gt;  //文件输入／输出<br>  include &lt;iomanip.h&gt;  //参数化输入／输出<br>  include &lt;iostream.h&gt; //数据流输入／输出<br>  include &lt;limits.h&gt;   //定义各种数据类型最值常量<br>  include &lt;locale.h&gt;   //定义本地化函数<br>  include &lt;math.h&gt;     //定义数学函数<br>  include &lt;stdio.h&gt;    //定义输入／输出函数<br>  include &lt;stdlib.h&gt;   //定义杂项函数及内存分配函数<br>  #include &lt;string.h&gt;  //字符串处理<br>  include &lt;strstrea.h&gt; //基于数组的输入／输出<br>  include &lt;time.h&gt;     //定义关于时间的函数<br>  #include &lt;wchar.h&gt;   //宽字符处理及输入／输出<br>  include &lt;wctype.h&gt;   //宽字符分类//////</p>
<h2><span id="标准-c">标准 C++</span></h2><p>  //////////////////////////////////////////<br>  include <algorithm>  //STL 通用算法<br>  include <bitset>     //STL 位集容器<br>  include <cctype>     //定义错误码<br>  #include <cerrno>    //定义错误码<br>  include <clocale>    //定义本地化函数<br>  include <cmath>      //定义数学函数<br>  include <complex>    //复数类<br>  #include <cstdio>    /定义输入／输出函数<br>  #include <cstdlib>   //定义杂项函数及内存分配函数<br>  include <cstring>    //字符串处理<br>  #include <ctime>     //定义关于时间的函数</ctime></cstring></cstdlib></cstdio></complex></cmath></clocale></cerrno></cctype></bitset></algorithm></p>
<p>  include <deque>      //STL 双端队列容器</deque></p>
<p>  include <exception>  //异常处理类<br>  include <fstream>    //文件输入／输出</fstream></exception></p>
<p>  include <functional> //STL 定义运算函数（代替运算符）</functional></p>
<p>  include <limits>     //定义各种数据类型最值常量</limits></p>
<p>  #include <list>      //STL 线性列表容器<br>  #include <map>       //STL 映射容器<br>  include <iomanip><br>  #include <ios>       //基本输入／输出支持<br>  #include <iosfwd>    //输入／输出系统使用的前置声明<br>  include <iostream><br>  include <istream>    //基本输入流<br>  include <ostream>    //基本输出流<br>  include <queue>      //STL 队列容器<br>  include <set>        //STL 集合容器<br>  #include <sstream>   //基于字符串的流<br>  include <stack>      //STL 堆栈容器<br>  include <stdexcept>  //标准异常类<br>  include <streambuf>  //底层输入／输出支持<br>  include <string>     //字符串类<br>  include <utility>    //STL 通用模板类<br>  include <vector>     //STL 动态数组容器<br>  include <cwchar><br>  include <cwctype></cwctype></cwchar></vector></utility></string></streambuf></stdexcept></stack></sstream></set></queue></ostream></istream></iostream></iosfwd></ios></iomanip></map></list></p>
<p>  using namespace std;<br>  ///////////////////////C99 增加<br>  include &lt;complex.h&gt;  //复数处理<br>  include &lt;fenv.h&gt;     //浮点环境s<br>  include &lt;inttypes.h&gt; //整数格式转换<br>  include &lt;stdbool.h&gt;  //布尔环境<br>  include &lt;stdint.h&gt;   //整型环境<br>  include &lt;tgmath.h&gt;   //通用类型数学宏</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>头文件介绍</tag>
      </tags>
  </entry>
  <entry>
    <title>指针与数组</title>
    <url>/2021/02/08/%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="定义指向数组元素的指针">定义指向数组元素的指针</span></h2><p>定义与赋值<br>int a[10],*pa;<br>pa=&amp;a[0];或者pa=a;<br>等效的形式</p>
<ul>
<li>pa就是a[0],* (pa+1)就是a[1]….* (pa+i)就是a[i]<br>！！！重点！！！<br>a[i],* (pa+i),* (a+i),pa(i)都是等效的</li>
</ul>
<h2><span id="指针数组数组的元素是指针类型">指针数组：数组的元素是指针类型</span></h2><p>Point * pa[2];<br>是由pa[0],pa[1]两个指针组成的</p>
<p>实例</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
using namespace std;
int main()&#123;
	int line1[]&#x3D;&#123;1,0,0&#125;
	int line2[]&#x3D;&#123;0,1,0&#125;
	int line3[]&#x3D;&#123;0,0,1&#125;
	&#x2F;&#x2F;定义整型指针数组并初始化
	int * pline[3]&#x3D;&#123;line1,line2,line3&#125;;
	&#x2F;&#x2F;输出
	cout&lt;&lt;&quot;Matrix test:&quot;&lt;&lt;endl;
	for (int i&#x3D;0;i&lt;3;i++)&#123;
		for (int j&#x3D;0;j&lt;3;j++)&#123;
			cout&lt;&lt;pline[i][j]&lt;&lt;&quot; &quot;;
		&#125;
		cout&lt;&lt;endl;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/image/1.png"><br>为什么需要用指针作参数？<br>需要数据双向传递时（引用也可以达到此效果）<br>需要传递一组数据，只传首地址运行效率比较高</p>
<p>例子：读入三个浮点数，将整数部分和小数部分分开输出</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
using namespace std;
void splitFloat(float x,int *intPart,float *fracpart)&#123;
	*intPart&#x3D;static_cast&lt;int&gt;(x);
	*fracpart&#x3D;x-*intPart;
&#125;
int main()&#123;
	cout&lt;&lt;&quot;Enter 3 float point numbers:&quot;&lt;&lt;endl;
	for (int i&#x3D;0;i&lt;3;i++)&#123;
		float x,f;
		int n;
		cin&gt;&gt;x;
		splitFloat(x,&amp;n,&amp;f);&#x2F;&#x2F;变量地址作实参
		cout&lt;&lt;&quot;Integer Part&#x3D;&quot;&lt;&lt;n&lt;&lt;&quot;fracpart&#x3D;&quot;&lt;&lt;f&lt;&lt;endl;

	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例子：指向常量的指针作形参<br>传递地址且不需要主调函数中的数值是无法修改的<br>这个时候把指针定义为常量指针，只为了输出。<br>最小授权原则,对外的访问授权够用就好。</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
using namespace std;
const int N&#x3D;6;
void print(const int *p ,int n);
int main()&#123;
	int array[N];
	for (int i&#x3D;0;i&lt;N;i++)
		cin&gt;&gt;array[i];
	print(array,N);
	return 0;
&#125;
void print(const int *p,int n)&#123;
	cout&lt;&lt;&quot;&#123;&quot;&lt;&lt;*p;
	for (int i&#x3D;1;i&lt;n;i++)
		cout&lt;&lt;&quot;,&quot;&lt;&lt;*(p+i);
	cout&lt;&lt;&quot;&#125;&quot;&lt;&lt;endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="指针函数的定义形式">指针函数的定义形式：</span></h2><p>存储类型 数据类型 *函数名 ( )<br>{<br>    //函数体语句<br>}<br>！！不要将非静态局部地址用作函数的返回值<br>错误的例子：<br>在子函数中定义局部变量后将其地址返回给主函数，就是非法地址<br>错误例子：</p>
<pre class="line-numbers language-none"><code class="language-none">
int main()&#123;
	int *function();
	int *ptr&#x3D;function();
	*ptr&#x3D;5;&#x2F;&#x2F;危险的访问
	return 0;
&#125;
int *function()&#123;
	int local&#x3D;0;&#x2F;&#x2F;非静态局部变量作用域和寿命仅限于本函数体内
	return &amp;local;
&#125;&#x2F;&#x2F;函数结束运行时，变量local被释放
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>正确例子：<br>动态分配地址，函数有效</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
using namespace std;
int main()&#123;
	int *newintvar();
	int *intptr&#x3D;newintvar();
	*intptr&#x3D;5; &#x2F;&#x2F;访问的是合法有效的地址
	delete intptr;&#x2F;&#x2F;如果忘记在这里释放，会造成内存泄漏
	return 0;

&#125;
int *newintvar()&#123;
	int *p&#x3D;new int();
	return p;&#x2F;&#x2F;返回的地址指向的是动态分配的空间
&#125;&#x2F;&#x2F;函数运行结束时，p中的地址仍然有效<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="函数指针">函数指针</span></h2><p>定义形式:<br>存储类型 数据类型 （* 函数指针名）（）；<br>含义：<br>函数指针指向的是程序代码存储区。</p>
<p>函数指针的典型用途–实现函数回调<br>通过函数指针调用的函数<br>    例如将函数的指针作为参数传递给一个函数，使得在处理相似事件的时候可以灵活的使用不同的方法<br>调用者不关心谁是被调用者<br>    需知道存在一个具有特定原型和限制条件的被调用函数</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
using namespace std;
int compute(int a,int b,int (*func)(int,int))
&#123;
	return func(a,b);
&#125;
int max(int a,int b)
&#123;
	return ((a&gt;b)?a:b);
&#125;
int min(int a,int b)
&#123;
	return ((a&lt;b)?a:b);
&#125;
int sum(int a,int b)
&#123;
	return a+b;
&#125;
int main()&#123;
	int a ,b,res;
	cout&lt;&lt;&quot;请输入整数a:&quot;;cin&gt;&gt;a;
	cout&lt;&lt;&quot;请输入整数b:&quot;;cin&gt;&gt;b;
	res&#x3D;compute(a,b,&amp;max);
	cout&lt;&lt;&quot;Max of &quot;&lt;&lt;a&lt;&lt;&quot;and&quot;&lt;&lt;b&lt;&lt;&quot; is&quot;&lt;&lt;res&lt;&lt;endl;
	res&#x3D;compute(a,b,&amp;min);
	cout&lt;&lt;&quot;Min of &quot;&lt;&lt;a&lt;&lt;&quot;and&quot;&lt;&lt;b&lt;&lt;&quot; is&quot;&lt;&lt;res&lt;&lt;endl;
	res&#x3D;compute(a,b,&amp;sum);
	cout&lt;&lt;&quot;Sum of &quot;&lt;&lt;a&lt;&lt;&quot;and&quot;&lt;&lt;b&lt;&lt;&quot; is&quot;&lt;&lt;res&lt;&lt;endl;
	

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="this指针">this指针</span></h2><p>隐含于类的每一个非静态成员函数中<br>指出成员函数所操作的对象<br>    当通过一个对象调用成员函数时，系统先将该对象的地址赋给this指针，然后调用成员函数，成员函数对对象的数据成员进行操作时，就隐含使用了this指针<br>例如：<br>Point类的getX函数中的语句<br>return x;<br>相当于<br>return this-&gt;x;</p>
<h2><span id="动态申请内存操作符-new">动态申请内存操作符 new</span></h2><p>new 类型名T（初始化参数列表）<br>功能：<br>在程序执行期间，申请用于存放类型T对象的内存空间<br>并依初值列表赋以初值<br>成功：T类型的指针，指向新分配的内存<br>失败：抛出异常</p>
<h2><span id="释放内存操作符-delete">释放内存操作符 delete</span></h2><p>功能：释放指针p所指向的内存。<br>p必须是new操作的返回值</p>
<p>例子：<br>动态创建对象举例</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
using namespace std;
int main()&#123;
	cout&lt;&lt;&quot;Step One:&quot;&lt;&lt;endl;
	Point *ptr1&#x3D;new Point;&#x2F;&#x2F;调用默认构造函数
	delete ptr1;&#x2F;&#x2F;删除对象，自动调用析构函数
	cout&lt;&lt;&quot;Step Two:&quot;&lt;&lt;endl;
	ptr1&#x3D; new Point(1,2);
	delete ptr1;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>分配和释放动态数组<br>分配：new 类型名T [数组长度]<br>数组长度可以是任何整数类型表达式，在运行时计算<br>释放：delete []数组名p<br>释放指针p所指向的数组<br>p必须是用new分配得到的数组首地址</p>
<h2><span id="动态创建多维数组">动态创建多维数组</span></h2><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
using namespace std;
int main()&#123;
	int (*cp)[9][8]&#x3D;new int [7][9][8];
	for (int i&#x3D;0;i&lt;7;i++)
		for (int j&#x3D;0;j&lt;9;j++)
			for(int k&#x3D;0;k&lt;8;k++)
				*(*(*(cp+i)+j)+k)&#x3D;(i*100+j*10+k);
	for (int i&#x3D;0;i&lt;7;i++)&#123;	
		for (int j&#x3D;0;j&lt;9;j++)&#123;
			for(int k&#x3D;0;k&lt;8;k++)
				cout&lt;&lt;cp[i][j][k]&lt;&lt;&quot; &quot;;
			cout&lt;&lt;endl;
		&#125;
		cout&lt;&lt;endl;
	&#125;
	delete []cp;
	return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2><span id="将动态数组分装成类">将动态数组分装成类</span></h2><p>更加简洁，便于管理<br>可以在访问数组元素前检查<br>下标是否越界</p>
<h2><span id="c11的智能指针">C++11的智能指针</span></h2><p>unique_ptr:<br>不允许 多个指针共享资源，可以用标准库中的move函数转移指针<br>shared_ptr:<br>多个指针共享资源<br>weak_ptr:<br>可复制shared_ptr,但其构造或者释放对资源不会产生影响</p>
<h2><span id="vector">vector</span></h2><p>为什么需要vector<br>封装任何类型的动态数组，自动创建和删除<br>数组下标越界检查<br>vector对象的定义<br>vector&lt;元素类型&gt;数组对象名（数组长度）<br>例子<br>vetor<int>arr[5]<br>对象的使用<br>对数组元素的引用<br>    与普通数组具有相同形式<br>    vector对象名[下标表达式]<br>    vector数组对象名不表示数组首地址<br>获得数组长度<br>    用size函数<br>    vector对象名.size</int></p>
<p>例子：计算平均值<br>for条件语句还是习惯加花括号<br>否则容易出问题</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;
double average(const vector&lt;double&gt;&amp;arr)
&#123;
	double sum&#x3D;0;
	for (unsigned i&#x3D;0;i&lt;arr.size();i++)
		sum+&#x3D;arr[i];
		cout&lt;&lt;&quot;sum&#x3D;&quot;&lt;&lt;sum&lt;&lt;endl;
		cout&lt;&lt;&quot;size&#x3D;&quot;&lt;&lt;arr.size()&lt;&lt;endl;
	return sum&#x2F;arr.size();
&#125;
int main()&#123;
	unsigned n;
	cout&lt;&lt;&quot;n&#x3D; &quot;;
	cin&gt;&gt;n;
	vector &lt;double&gt;arr(n);
	cout&lt;&lt;&quot;please input&quot;&lt;&lt;&quot; &quot;&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;&quot;real numbers:&quot;&lt;&lt;endl;
	for (unsigned i&#x3D;0;i&lt;n;i++)
		cin&gt;&gt;arr[i];
		cout&lt;&lt;&quot;Average &#x3D;&quot;&lt;&lt;average(arr)&lt;&lt;endl;
		return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="浅层复制">浅层复制</span></h2><p>实现对象间数据元素的一一复制</p>
<h2><span id="深层复制">深层复制</span></h2><p>返回时构造临时对象，动态分配将临时对象返回到主调函数，然后删除临时对象</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
class IntNum&#123;
public:
   IntNum(int x&#x3D;0):xptr(new int (x))&#123;
      cout&lt;&lt;&quot;Calling constructor...&quot;&lt;&lt;endl;
   &#125;
   IntNum(const IntNum &amp;n):xptr(new int(*n.xptr))&#123;
      cout&lt;&lt;&quot;Calling copy constructor..&quot;&lt;&lt;endl;
   &#125;
   ~IntNum()&#123;
      delete xptr;
      cout&lt;&lt;&quot;Destructing..&quot;&lt;&lt;endl;
   &#125;
   int getInt()&#123;
      return *xptr;
   &#125;
private:
   int *xptr;
&#125;;
IntNum getNum()&#123;
   IntNum a;
   return a;
&#125;
int main()&#123;
   cout&lt;&lt;getNum().getInt()&lt;&lt;endl;
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="移动构造">移动构造</span></h2><p>class_name(class_name)<br>将要返回的局部对象转移到主调函数，省去了构造和删除临时对象的过程</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
class IntNum&#123;
public:
   IntNum(int x&#x3D;0):xptr(new int (x))&#123;
      cout&lt;&lt;&quot;Calling constructor...&quot;&lt;&lt;endl;
   &#125;
   IntNum(const IntNum &amp;n):xptr(new int(*n.xptr))&#123;
      cout&lt;&lt;&quot;Calling copy constructor..&quot;&lt;&lt;endl;
   &#125;
   ~IntNum()&#123;
      delete xptr;
      cout&lt;&lt;&quot;Destructing..&quot;&lt;&lt;endl;
   &#125;
   int getInt()&#123;
      return *xptr;
   &#125;
private:
   int *xptr;
&#125;;
IntNum getNum()&#123;
   IntNum a;
   return a;
&#125;
int main()&#123;
   cout&lt;&lt;getNum().getInt()&lt;&lt;endl;
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意：<br>&amp;&amp;是右值引用<br>函数返回的临时变量是右值</p>
<p>移动构造优于复制构造，但具体还需要之后作题练习，这里一头雾水</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++进阶笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Bat文件批量操作</title>
    <url>/2021/05/15/%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="批量操作">批量操作</span></h2><h3><span id="批量替换文件名称的部分名称">批量替换文件名称的部分名称</span></h3><pre class="line-numbers language-none"><code class="language-none">@echo off
set &#x2F;p str1&#x3D; 请输入要替换的文件(文件夹)名字符串（可替换空格）：
set &#x2F;p str2&#x3D; 请输入替换后的文件(文件夹)名字符串（若删除直接回车）：
echo.
echo 正在操作中，请稍候……
for &#x2F;f &quot;delims&#x3D;&quot; %%a in (&#39;dir &#x2F;s &#x2F;b ^|sort &#x2F;+65535&#39;) do (
if &quot;%%~nxa&quot; neq &quot;%~nx0&quot; (
set &quot;file&#x3D;%%a&quot;
set &quot;name&#x3D;%%~na&quot;
set &quot;extension&#x3D;%%~xa&quot;
call set &quot;name&#x3D;%%name:%str1%&#x3D;%str2%%%&quot;
setlocal enabledelayedexpansion
ren &quot;!file!&quot; &quot;!name!!extension!&quot; 2&gt;nul
endlocal
)
)
exit
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="新建txt文档将上述代码输入然后更改后缀名为bat">新建txt文档，将上述代码输入，然后更改后缀名为bat</span></h2><p>双击bat文件即可。</p>
<p>注意事项：<br>注意：<br>需要将该执行bat文件放入想要修改的文件所在的文件夹内<br>bat操作只对与bat在同一个文件夹中的文件起作用，针对全部文件类型</p>
<p>首先输入原文件中想要替换的部分文件名称<br>例子：<br>文件夹内存在文件<br>“张三的作业.txt”<br>这里输入 张三</p>
<p>再输入想要替换成的文件名称（如果输入为空，直接敲打回车，则删除之前选择的部分文件名）</p>
<p>如果输入 李四<br>则文件改为 “李四的作业.txt”</p>
<p>如果不输入直接回车<br>则文件名变为 “的作业.txt”</p>
<h3><span id="批量生成某一类型的文件">批量生成某一类型的文件</span></h3><pre class="line-numbers language-none"><code class="language-none">@echo off
set &#x2F;p w&#x3D;请输入要生成文件的格式(即扩展名并以回车结束)：
set &#x2F;p name&#x3D;请输入要生成文件的格式(即扩展名并以回车结束)：
set a&#x3D;0
:loop
set &#x2F;a a+&#x3D;1
type nul&gt;%name%%a%.%w%
if %a% &#x3D;&#x3D; 20 goto end
goto loop
:end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述同理。</p>
<p>注意事项：</p>
<p>首先输入要生成的文件类型的后缀名称（类似txt,docx,csv)<br>再输入文件名称<br>a为生成相同文件名的序列</p>
<pre class="line-numbers language-none"><code class="language-none">set &#x2F;a a+&#x3D;1 将结尾的数字1改变递增
 0 1 2 3 4
set &#x2F;a a+&#x3D;2
 0 2 4 6 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">if %a% &#x3D;&#x3D; 20 goto end<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里是创建文件个数，这里设置为20个。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>批量操作</category>
      </categories>
      <tags>
        <tag>bat</tag>
      </tags>
  </entry>
  <entry>
    <title>损失函数</title>
    <url>/2021/03/12/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="损失函数">损失函数</span></h2><p>nn.CrossEntropyLoss()这个损失函数用于多分类问题虽然说的是交叉熵，但是和我理解的交叉熵不一样。<br>nn.CrossEntropyLoss()是nn.logSoftmax()和nn.NLLLoss()的整合,可以直接使用它来替换网络中的这两个操作。下面我们来看一下计算过程:</p>
<p>首先输入是size是(minibatch,C)。这里的C是类别数。损失函数的计算如下：</p>
<p><img src="/image/1.PNG" alt="png"></p>
<p>损失函数中也有权重weight参数设置，若设置权重，则公式为：</p>
<p><img src="/image/2.PNG" alt="png"></p>
<p>这里的标签值class，并不参与直接计算，而是作为一个索引,索引对象为实际类别<br>举个栗子，我们一共有三种类别，批量大小为1（为了好计算），那么输入size为（1,3），具体值为torch.Tensor([[-0.7715, -0.6205,-0.2562]])。<br>标签值为target = torch.tensor([0])，这里标签值为0，表示属于第0类。loss计算如下：</p>
<pre class="line-numbers language-none"><code class="language-none">import torch
import torch.nn as nn
import math
entroy&#x3D;nn.CrossEntropyLoss()
input&#x3D;torch.Tensor([[-0.7715, -0.6205,-0.2562]])
target &#x3D; torch.tensor([0])g
output &#x3D; entroy(input, target)
print(output)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出：<br>tensor(1.3447)</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>算法公式</tag>
      </tags>
  </entry>
  <entry>
    <title>模型改进</title>
    <url>/2021/06/09/%E6%A8%A1%E5%9E%8B%E6%94%B9%E8%BF%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>模型改进<br>需要判断特殊情况下的模型运动</p>
<p>水平竖直方向同时做位移运动 是圆弧运动<br>lcostheta? lsintheta?</p>
<p>需要自定义初始化而非随机初始化<br>验证正确与否的方法：</p>
<p>特殊情况判断<br>竖直状态下 角度初始值为0<br>竖直向上运动 单摆的角度会一直为0</p>
<p>水平方向位移与竖直方向的位移的夹角恰好是单摆与竖直方向的角度<br>这个时候单摆的摇摆不会改变？</p>
<p>验证1：<br>当初始化state为[0,0,0,0,0,0]<br>初始化单摆的角度为0<br>这个时候只给模型竖直向上的位移，结果单摆也竖直向上运动</p>
<p>验证2：<br>简单化，水平位移与竖直位移相等，支点位移角度应该是45度，这个时候单摆的运动观察。</p>
<p>完成：<br>1.<br>增加变量t到state中<br>给小车一个随时间变化的位移<br>画出关于x-t的图像  cos函数</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法实现</title>
    <url>/2021/07/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><img src="/image/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" alt="png"></p>
<h1><span id="c排序算法实现">C++排序算法实现</span></h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&quot;sort.h&quot;
void menu()&#123;
    cout &lt;&lt; &quot;**********************************************\n&quot;;
    cout &lt;&lt; &quot;*****************1，冒泡排序******************\n&quot;;
    cout &lt;&lt; &quot;*****************2，插入排序******************\n&quot;;
    cout &lt;&lt; &quot;*****************3，希尔排序******************\n&quot;;
    cout &lt;&lt; &quot;*****************4，选择排序******************\n&quot;;
    cout &lt;&lt; &quot;***************5，快速排序算法****************\n&quot;;
    cout &lt;&lt; &quot;*****************6，堆排序********************\n&quot;;
    cout &lt;&lt; &quot;*****************7，归并排序******************\n&quot;;
    cout &lt;&lt; &quot;*****************8，计数排序******************\n&quot;;
    cout &lt;&lt; &quot;*****************9，基数排序******************\n&quot;;
    cout &lt;&lt; &quot;*******************0，退出********************\n&quot;;
    cout &lt;&lt; &quot;**********************************************\n&quot;;
    cout &lt;&lt; &quot;请选择一种排序的算法： &quot; &lt;&lt; endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="1冒泡排序">1.冒泡排序</span></h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;1.冒泡排序
void BubbleSort(vector&lt;int&gt; &amp;a ,size_t n)&#123;
    int i, j;
    int tmp;
    for (int i &#x3D; 0; i &lt; n;++i)&#123;
        for (int j &#x3D; 0 ; j &lt; n-1-i;++j)&#123;
            if(a[j]&gt;a[j+1])&#123;
                swap(a[j], a[j + 1]);
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="2插入排序">2.插入排序</span></h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;2.插入排序
void InsertSort(vector&lt;int&gt;&amp;a,size_t n)&#123;
    int i, j;
    for (i &#x3D; 1; i &lt; n;++i)&#123;
        int key &#x3D; a[i];  &#x2F;&#x2F;保存无序区第一个元素为key
        int j &#x3D; i - 1;
        while(!(j&lt;0) &amp;&amp; a[j]&gt;key)&#123;
            a[j + 1] &#x3D; a[j];
            --j;
        &#125;
        a[j + 1] &#x3D; key;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="3希尔排序">3.希尔排序</span></h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;3.希尔排序
void SheelSort(vector&lt;int&gt;&amp;a,size_t n)&#123;
    int gap &#x3D; n;

    &#x2F;&#x2F;当gap等于1的时候终止
    while(gap &#x3D; gap&#x2F;2)&#123;
        &#x2F;&#x2F;增量
        cout &lt;&lt; &quot;每列待排序元素:&quot; &lt;&lt; endl;
        for (int i &#x3D; gap; i &lt; n;++i)&#123;
            cout &lt;&lt; i &lt;&lt; &quot; &quot;;
            int key &#x3D; a[i]; &#x2F;&#x2F;待排序元素
            int j &#x3D; i - gap;
            for (; j + 1 &gt; 0 &amp;&amp; a[j] &gt; key;j -&#x3D; gap)&#123;
                a[j + gap] &#x3D; a[j];
            &#125;
            a[j + gap] &#x3D; key;
        &#125;
        cout &lt;&lt; endl;
        cout &lt;&lt; &quot;增量&quot; &lt;&lt; gap &lt;&lt; &quot;的排序结果：&quot; &lt;&lt; endl;
        if(gap!&#x3D;1)&#123;
            for (int i &#x3D; 0; i &lt; n;++i)&#123;
                cout &lt;&lt; &quot; &quot; &lt;&lt; a[i];
            &#125;
            cout &lt;&lt; endl;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="4选择排序">4.选择排序</span></h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void SelectSort(vector&lt;int&gt;&amp;a ,size_t n)&#123;
    int index, tmp;
    for (int i &#x3D; 0; i &lt; n; ++i)
    &#123;
        &#x2F;&#x2F;每次遍历一遍寻找最小元素放在头部 下次遍历到的最小元素放在头部的下一个位置
        index &#x3D; i;
        for (int j &#x3D; i + 1; j &lt; n;++j)&#123;
            if(a[j]&lt;a[index])&#123;
                index &#x3D; j;
            &#125;
        &#125;
        if(index !&#x3D; i)&#123;
            swap(a[i], a[index]);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="5快速选择排序">5.快速选择排序</span></h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void QuickSort(vector&lt;int&gt;&amp;a,size_t low,size_t high)&#123;
    if(low&lt;high)&#123;
        int i &#x3D; low - 1;
        int j &#x3D; low;
        int key &#x3D; a[high];
        for (int j &#x3D; low; j &lt;&#x3D; high; ++j)
        &#123;
            if(a[j] &lt;&#x3D; key)&#123;
                ++i;
                swap(a[i], a[j]);
            &#125;
        &#125;
        QuickSort(a, low, i - 1);
        QuickSort(a, i + 1, high);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="6堆排序">6.堆排序</span></h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Heap(vector&lt;int&gt;&amp;a,int node,int n)&#123;
    for (int i &#x3D; 2 * node + 1; i &lt; n;++i)&#123;
        if(i+1 &lt;n &amp;&amp; a[i+1]&gt;a[i])&#123;
            ++i;
            &#x2F;&#x2F;找到子节点中较大的一个和根节点交换
        &#125;
        if(a[i]&gt;a[node])&#123;
            swap(a[i], a[node]);
        &#125;
    &#125;
&#125;

void HeapSort(vector&lt;int&gt;&amp;a ,int n)&#123;
    for (int node &#x3D; n &#x2F; 2 - 1; node &gt;&#x3D; 0;--node)&#123;
        &#x2F;&#x2F;构建大顶堆 node向下取整
        Heap(a, node, n);
    &#125;

    &#x2F;&#x2F;堆顶元素和堆底元素交换 剩余元素继续构建大顶堆
    for (int i &#x3D; n - 1; i &gt; 0;--i)&#123;
        swap(a[0], a[i]);
        Heap(a, 0, i);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="7归并排序自顶向下">7.归并排序(自顶向下)</span></h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void _merge(vector&lt;int&gt;&amp;a,int l,int q,int r)&#123;
    int n &#x3D; r - l + 1; &#x2F;&#x2F;临时数组合并后的有序序列
    vector&lt;int&gt; tmp(n,0);
    int i &#x3D; 0;
    int left &#x3D; l;
    int right &#x3D; q + 1; &#x2F;&#x2F;分割的第二个数组的首元素位置
    while(left&lt;&#x3D;q &amp;&amp; right&lt;&#x3D;r)&#123;
        &#x2F;&#x2F;两个数组依次遍历比较 将较小元素放入输出数组
        tmp[i++] &#x3D; a[left] &lt;&#x3D; a[right] ? a[left++] : a[right++];

    &#125;
    &#x2F;&#x2F;当其中一个数组遍历完成 则依次按顺序输出另一个数组元素
    while(left&lt;&#x3D;q)&#123;
        tmp[i++] &#x3D; a[left++];
    &#125;
    while(right&lt;&#x3D;r)&#123;
        tmp[i++] &#x3D; a[right++];
    &#125;
    &#x2F;&#x2F;重新赋值原数组
    for (int j &#x3D; 0; j &lt; n;++j)&#123;
        a[l + j] &#x3D; tmp[j];
    &#125;
&#125;

void MergeSort(vector&lt;int&gt;&amp;a,int l,int r)&#123;
    if(l&#x3D;&#x3D;r)&#123;
        return;
    &#125;
    int q &#x3D; l + (r - l) &#x2F; 2;
    MergeSort(a, l, q);
    MergeSort(a, q + 1, r);
    _merge(a, l, q, r);
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="8计数排序">8.计数排序</span></h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void CountSort(vector&lt;int&gt; &amp;a ,size_t n)&#123;
    int i, j, k;
    vector&lt;int&gt; C(n, 0);
    int maxres &#x3D; 0;
    for (int i &#x3D; 0; i &lt; n; ++i)
    &#123;
        cout &lt;&lt; &quot;a[i]:&quot; &lt;&lt; a[i] &lt;&lt; endl;
        C[a[i]]++;
        maxres &#x3D; max(maxres, a[i]);
    &#125;
    k &#x3D; 0;
    cout &lt;&lt; &quot;maxres:&quot; &lt;&lt; maxres &lt;&lt; endl;
    for (j &#x3D; 0; j &lt;&#x3D; maxres; j++)
    &#123;
        for (i &#x3D; 1; i &lt;&#x3D; C[j];i++)&#123;
            &#x2F;&#x2F;从0开始递增 如果遇到的元素的计数大于等于1 则加入数组
            a[k++] &#x3D; j;
            cout &lt;&lt;&quot;j:&quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;&quot;k:&quot; &lt;&lt; k &lt;&lt; endl;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>计数排序：</p>
<p>当增加随机数组元素个数的时候 ，会出现错误提示</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">munmap_chunk(): invalid pointer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>需要改进。</p>
<h2><span id="附加信息">附加信息：</span></h2><h3><span id="sorth-头文件">‘sort.h’  头文件</span></h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#pragma once
#include&lt;iostream&gt;
using namespace std;
#include&lt;time.h&gt;
#include&lt;assert.h&gt;
#include&lt;stack&gt;
#include&lt;vector&gt;
#define M 1 &#x2F;&#x2F;执行次数
#define N 50 &#x2F;&#x2F;数组大小
void menu(); &#x2F;&#x2F;菜单函数
void BubbleSort(vector&lt;int&gt; &amp;a, size_t n);              &#x2F;&#x2F;1.冒泡排序
void InsertSort(vector&lt;int&gt; &amp;a, size_t n);        &#x2F;&#x2F;  2.插入排序
void SheelSort(vector&lt;int&gt; &amp;a, size_t n);               &#x2F;&#x2F;  3.希尔排序
void SelectSort(vector&lt;int&gt; &amp;a, size_t n);             &#x2F;&#x2F;  4.选择排序
void QuickSort(vector&lt;int&gt; &amp;a, size_t left,size_t right);             &#x2F;&#x2F;  5.快速排序
void HeapSort(vector&lt;int&gt; &amp;a, int n);             &#x2F;&#x2F;  6.堆排序
void MergeSort(vector&lt;int&gt; &amp;a, int l,int r);            &#x2F;&#x2F; 7.归并排序
void CountSort(vector&lt;int&gt; &amp;a, size_t n);           &#x2F;&#x2F; 8.计数排序
void LSDSort(vector&lt;int&gt; &amp;a, size_t n);             &#x2F;&#x2F;9.基数排序
void QuickSort2(vector&lt;int&gt; &amp;a, size_t low, size_t high);  &#x2F;&#x2F; 10.快速排序
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h3><span id="计时设计">计时设计</span></h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&quot;sort.h&quot;
template&lt;typename T &gt;
void displayFunction(T &amp;input)&#123;
    for (auto iterator &#x3D; input.begin(); iterator !&#x3D; input.end();++iterator)
        cout &lt;&lt; *iterator &lt;&lt; &quot; &quot; ;
        cout &lt;&lt; endl;
&#125;

void datanum(vector&lt;int&gt;&amp;a)&#123;
        for (int j &#x3D; 0; j &lt; M; j++)
        &#123;
            for (int i &#x3D; 0; i &lt; N; ++i)&#123;
                a[i] &#x3D; rand()%100;
            &#125;
        &#125;   
&#125;
int main()&#123;
    vector&lt;int&gt; a(N);
    int i, j, p;
    menu();
    datanum(a);
    displayFunction(a);
    do
    &#123;
        cin &gt;&gt; p;
        double start, finish; &#x2F;&#x2F;定义开始和结束时间
        start &#x3D; (double)clock();
        switch (p) &#123;
            case 1:
                BubbleSort(a, N);
                break;
            case 2:
                InsertSort(a, N);
                break;
            case 3:
                SheelSort(a, N);
                break;
            case 4:
                SelectSort(a, N);
                break;
            case 5:
                QuickSort(a,0,N-1);
                break;
            case 6:
                HeapSort(a, N);
                break;

            case 7:
                MergeSort(a,0,N);
                break;
                            
            case 8:
                CountSort(a, N);
                break;
            
            
            case 0:
                break;
            
            default :
                break; 

        &#125;  
        displayFunction(a);

        finish &#x3D; (double)clock();
        printf(&quot;%.4fms\n&quot;, (finish - start));

    &#125; while (p !&#x3D; 0);
    return 0;

&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>深层学习方法总结</title>
    <url>/2021/04/16/%E6%B7%B1%E5%B1%82%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>深层学习方法<br><a href="https://zhuanlan.zhihu.com/p/25913410">https://zhuanlan.zhihu.com/p/25913410</a></p>
<h2><span id="蒙特卡罗方法英语monte-carlo-method">蒙特卡罗方法（英语：Monte Carlo method）</span></h2><p>也称统计模拟方法，是1940年代中期由于科学技术的发展和电子计算机的发明，而提出的一种以概率统计理论为指导的数值计算方法。是指使用随机数（或更常见的伪随机数）来解决很多计算问题的方法。<br>蒙特卡罗的方法需要等到每次试验结束才能估计当前的值函数</p>
<h2><span id="bootstrapping算法">Bootstrapping算法</span></h2><p>1977年美国Standford大学统计学教授Efron提出了一种新的增广样本的统计方法，就是Bootstrap方法，为解决小子样试验评估问题提供了很好的思路。Bootstrapping算法指的就是利用有限的样本资料经由多次重复抽样，重新建立起足以代表母体样本分布的新样本。bootstrapping的运用基于很多统计学假设，因此假设的成立与否影响采样的准确性。<br>统计学中，bootstrapping可以指依赖于重置随机抽样的一切试验。bootstrapping可以用于计算样本估计的准确性。对于一个采样，我们只能计算出某个统计量(例如均值)的一个取值，无法知道均值统计量的分布情况。但是通过自助法(自举法)我们可以模拟出均值统计量的近似分布。</p>
<h2><span id="时间差分方法td">时间差分方法TD</span></h2><p>结合了蒙特卡罗的采样方法和动态规划方法的bootstrapping(利用后继状态的值函数估计当前值函数)使得他可以适用于model-free的算法并且是单步更新，速度更快。</p>
<p>时间差分方法结合了蒙特卡罗的采样方法（即做试验）和动态规划方法的bootstrapping(利用后继状态的值函数估计当前值函数)，学习效率高于蒙特卡罗</p>
<h2><span id="qlearning">Qlearning</span></h2><p>异策略：是指执行的策略和要评估的策略不是同一个策略，通常使用ε−greedy策略。<br>时间差分：是指利用时间差分目标来更新当前状态动作值函数</p>
<h2><span id="dqn是在qlearning的基础上做了如下修改">DQN是在Qlearning的基础上做了如下修改：</span></h2><p>1.DQN利用深度卷积神经网络逼近值函数。<br>采用CNN逼近值函数，网络结构为3个卷基层，2个全连接层。</p>
<p>2.DQN利用了经验回放训练强化学习模型。<br>在训练神经网络时，假设训练数据是独立同分布的，但是强化学习数据采集过程中的数据是具有关联性的，利用这些时序关联的数据训练时，神经网络无法稳定，利用经验回放打破了数据间的关联性。在强化学习的过程中，智能体将数据保存到一个数据库中，再利用均匀随机采样的方法从数据库中抽取数据，然后利用抽取到的数据训练神经网络。</p>
<p>3.DQN独立设置了目标网络来单独处理时间差分算法中的TD误差。</p>
<p><a href="https://zhuanlan.zhihu.com/p/26052182">https://zhuanlan.zhihu.com/p/26052182</a></p>
<p>这里值函数利用神经网络进行逼近，属于非线性逼近。虽然逼近方法不同，但都是参数逼近。请记住，这里的值函数对应着一组参数，在神经网络里参数是每层网络的权重，我们用Q(s,a,theta)表示。用公式表示的话值函数为：Q(s,a,theta)，注意，我们这时候对值函数进行更新时其实更新的是参数Q(s,a,theta)，当网络结构确定时，Q(s,a,theta)就代表值函数。</p>
<p>DQN无法解决Qlearning的固有缺点——过估计。过估计是指估计的值函数比真实的值函数偏大，如果过估计在所有状态都是均匀的，那么根据贪心策略，依然能够找到值函数最大的动作，但是往往过估计在各个状态不是均匀的，因此过估计会影响到策略决策，从而导致获取的不是最优策略。</p>
<p>过估计的产生的原因是在参数更新或值函数迭代过程中采用的max操作导致的</p>
<h2><span id="ddqn">DDQN</span></h2><p>DDQN中有两组不同的参数，和θ和θ-。θ用于选择对应最大Q值的动作，θ-用于评估最优动作的Q值。这两组参数将动作选择和策略评估分离，降低了过高估计Q值的风险。DDQN 使用当前值网络的参数θ选择最优动作，用目标值网络的参数θ-评估该最优动作。实验结果证明，DDQN能更准确的估计Q函数值，使得训练算法和训练得到的策略更为稳定。</p>
<h2><span id="duelingwork">duelingwork</span></h2><p>Dueling的这种结构的优势在于学习效率，Value[V(s)]的更新将会触及到所有的动作跟着<br>value[V(s)]一起更新，如果是Q的话，你只能更新当前状态下的状态-动作值函数。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习</title>
    <url>/2021/02/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="迷路问题">迷路问题</span></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt
<span class="token operator">%</span>matplotlib inline<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
ax <span class="token operator">=</span> plt<span class="token punctuation">.</span>gca<span class="token punctuation">(</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>color <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">,</span>linewidth<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>color <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">,</span>linewidth<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>color <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">,</span>linewidth<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>color <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">,</span>linewidth<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>

plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">2.5</span><span class="token punctuation">,</span><span class="token string">'s0'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">1.5</span><span class="token punctuation">,</span><span class="token number">2.5</span><span class="token punctuation">,</span><span class="token string">'s1'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">2.5</span><span class="token punctuation">,</span><span class="token number">2.5</span><span class="token punctuation">,</span><span class="token string">'s2'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">1.5</span><span class="token punctuation">,</span><span class="token string">'s3'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">1.5</span><span class="token punctuation">,</span><span class="token number">1.5</span><span class="token punctuation">,</span><span class="token string">'s4'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">2.5</span><span class="token punctuation">,</span><span class="token number">1.5</span><span class="token punctuation">,</span><span class="token string">'s5'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token string">'s6'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">1.5</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token string">'s7'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">2.5</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token string">'s8'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">2.3</span><span class="token punctuation">,</span><span class="token string">'Start'</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">2.5</span><span class="token punctuation">,</span><span class="token number">0.3</span><span class="token punctuation">,</span><span class="token string">'goal'</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>

ax<span class="token punctuation">.</span>set_xlim<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
ax<span class="token punctuation">.</span>set_ylim<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>tick_params<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token string">'both'</span><span class="token punctuation">,</span>which<span class="token operator">=</span><span class="token string">'both'</span><span class="token punctuation">,</span>bottom<span class="token operator">=</span><span class="token string">'off'</span><span class="token punctuation">,</span>top<span class="token operator">=</span><span class="token string">'off'</span><span class="token punctuation">,</span>labelbottom<span class="token operator">=</span><span class="token string">'off'</span><span class="token punctuation">,</span>right<span class="token operator">=</span><span class="token string">'off'</span><span class="token punctuation">,</span>left<span class="token operator">=</span><span class="token string">'off'</span><span class="token punctuation">,</span>labelleft<span class="token operator">=</span><span class="token string">'off'</span><span class="token punctuation">)</span>

line<span class="token punctuation">,</span> <span class="token operator">=</span> ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>marker<span class="token operator">=</span><span class="token string">"o"</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">"g"</span><span class="token punctuation">,</span>markersize<span class="token operator">=</span><span class="token number">60</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/image/output_1_0.png" alt="png"></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">theta_0 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">simple_convert_into_pi_from_theta</span><span class="token punctuation">(</span>theta<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token punctuation">[</span>m<span class="token punctuation">,</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> theta<span class="token punctuation">.</span>shape
    pi <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>
        pi<span class="token punctuation">[</span>i<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">=</span>theta<span class="token punctuation">[</span>i<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">/</span>np<span class="token punctuation">.</span>nansum<span class="token punctuation">(</span>theta<span class="token punctuation">[</span>i<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    pi <span class="token operator">=</span> np<span class="token punctuation">.</span>nan_to_num<span class="token punctuation">(</span>pi<span class="token punctuation">)</span>
    <span class="token keyword">return</span> pi
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">pi_0 <span class="token operator">=</span> simple_convert_into_pi_from_theta<span class="token punctuation">(</span>theta_0<span class="token punctuation">)</span>
pi_0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<pre><code>[[0.         0.5        0.5        0.        ]
 [0.         0.5        0.         0.5       ]
 [0.         0.         0.5        0.5       ]
 [0.33333333 0.33333333 0.33333333 0.        ]
 [0.         0.         0.5        0.5       ]
 [1.         0.         0.         0.        ]
 [1.         0.         0.         0.        ]
 [0.5        0.5        0.         0.        ]]
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_next_s</span><span class="token punctuation">(</span>pi<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
    direction <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"up"</span><span class="token punctuation">,</span><span class="token string">"right"</span><span class="token punctuation">,</span><span class="token string">"down"</span><span class="token punctuation">,</span><span class="token string">"left"</span><span class="token punctuation">]</span>
    next_direction <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>direction<span class="token punctuation">,</span>p <span class="token operator">=</span> pi<span class="token punctuation">[</span>s<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> next_direction <span class="token operator">==</span> <span class="token string">"up"</span><span class="token punctuation">:</span>
        s_next <span class="token operator">=</span> s<span class="token operator">-</span><span class="token number">3</span>
    <span class="token keyword">elif</span> next_direction <span class="token operator">==</span> <span class="token string">"right"</span><span class="token punctuation">:</span>
        s_next <span class="token operator">=</span> s<span class="token operator">+</span><span class="token number">1</span>
    <span class="token keyword">elif</span> next_direction <span class="token operator">==</span> <span class="token string">"down"</span><span class="token punctuation">:</span>
        s_next <span class="token operator">=</span> s<span class="token operator">+</span><span class="token number">3</span>
    <span class="token keyword">elif</span> next_direction <span class="token operator">==</span> <span class="token string">"left"</span><span class="token punctuation">:</span>
        s_next <span class="token operator">=</span> s<span class="token operator">-</span><span class="token number">1</span>
    <span class="token keyword">return</span> s_next
<span class="token keyword">def</span> <span class="token function">goal_maze</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span class="token punctuation">:</span>
    s <span class="token operator">=</span> <span class="token number">0</span>
    state_history <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        next_s <span class="token operator">=</span> get_next_s<span class="token punctuation">(</span>pi<span class="token punctuation">,</span>s<span class="token punctuation">)</span>
        state_history<span class="token punctuation">.</span>append<span class="token punctuation">(</span>next_s<span class="token punctuation">)</span>
        <span class="token keyword">if</span> next_s <span class="token operator">==</span> <span class="token number">8</span><span class="token punctuation">:</span>
            <span class="token keyword">break</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            s <span class="token operator">=</span> next_s
    <span class="token keyword">return</span> state_history  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">state_history <span class="token operator">=</span> goal_maze<span class="token punctuation">(</span>pi_0<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>state_history<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"迷路问题解决step："</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>state_history<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre><code>[0, 3, 0, 1, 2, 1, 2, 5, 2, 1, 0, 3, 4, 7, 8]
迷路问题解决step：14
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> animation
<span class="token keyword">from</span> IPython<span class="token punctuation">.</span>display <span class="token keyword">import</span> HTML  
<span class="token comment"># IPython这是是大写</span>
<span class="token keyword">def</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    line<span class="token punctuation">.</span>set_data<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  
    <span class="token keyword">return</span> <span class="token punctuation">(</span>line<span class="token punctuation">,</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">animate</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
    state <span class="token operator">=</span> state_history<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>state<span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">0.5</span><span class="token punctuation">)</span>
    y <span class="token operator">=</span> <span class="token number">2.5</span> <span class="token operator">-</span> <span class="token builtin">int</span><span class="token punctuation">(</span>state<span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span>
    line<span class="token punctuation">.</span>set_data<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>line<span class="token punctuation">,</span><span class="token punctuation">)</span>
anim <span class="token operator">=</span> animation<span class="token punctuation">.</span>FuncAnimation<span class="token punctuation">(</span>fig<span class="token punctuation">,</span>animate<span class="token punctuation">,</span>init_func <span class="token operator">=</span> init<span class="token punctuation">,</span>frames <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>state_history<span class="token punctuation">)</span><span class="token punctuation">,</span>interval <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">,</span>repeat <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span>
HTML<span class="token punctuation">(</span>anim<span class="token punctuation">.</span>to_jshtml<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/image/11.gif" alt="gif"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员面试题</title>
    <url>/2021/02/07/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%A2%98-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1491221473&auto=1&height=66"></iframe>

<h2><span id="c风格字符串和字符数组">C风格字符串和字符数组</span></h2><h3><span id="字符串常量">字符串常量</span></h3><p>以双引号括起来的字符序列是字符串常量，通常编译器会在末尾自动添加一个空字符</p>
<p>//字符常量‘A’表示单个字符A<br>–”A“是字符串常量表示单个字符A和空字符null<br>–！!C风格字符串末尾必须有一个’\0’<br>–char ca1[]={‘1’,’C’,’+’} —–不是C风格字符串因为不是0结尾<br>–”a”                      —–不是字符常量，因为是双引号</p>
<h3><span id="字符数组">字符数组</span></h3><p>–const char ch[6]=”Daniel”——错误，因为这个C风格字符串包含<br>–D a n i e l null共七个字符</p>
<p>–char c[5]={‘a’,’b’,’\0’,’c’,’\0’};<br>–print (“%s”,c);<br>–这里的输出结果为ab 因为字符串输出遇到\0终止</p>
<h2><span id="二维数组">二维数组</span></h2><h3><span id="二维数组的声明和初始化">二维数组的声明和初始化</span></h3><p>例子<br>指定其初始化式 int ia[3][4]={ {1,2,3,4}, {5,6,7,8}，{ 9,10,11,12 } };<br>顺序初始化式   int ia[3][4]={ 1,2,3,4,5,6,7,8,9,10,11,12 };</p>
<p><img src="/image/0.jpg"></p>
<h3><span id="二维数组的省略">二维数组的省略</span></h3><h4><span id="第一维可以省略">第一维可以省略</span></h4><p>二维数组的所有元素都赋值的情况下，可以省略<br>int array[][3]={ 1,2,3,4,5,6};<br>int array[2][3]={ 1,2,3,4,5,6};</p>
<h3><span id="逗号运算符">逗号运算符</span></h3><p>逗号运算符：多个表达式用逗号分开，其中用逗号分开的表达式的值分别结算，但整个表达的值是最后一个表达式的值</p>
<p><img src="/image/1.JPG"></p>
<p>对于语句1来说，最终的值是最后一个表达式的值，也就是d＋３ a1=8;</p>
<p>对于语句2来说，最终表达式的值为8，但a2=4；</p>
<h4><span id="问题">问题</span></h4><p>赋值运算符比逗号运算符的优先级高<br>因为“，”所以最终表达式的值是最后一个值d＋３，但a2的值是a2=＋＋b=4</p>
<h3><span id="行优先存储和列优先存储">行优先存储和列优先存储</span></h3><h4><span id="c中数组是采用行优先存储">C＋＋中数组是采用行优先存储</span></h4><p><img src="/image/2.JPG"></p>
<h4><span id="二位数组向一维数组转化">二位数组向一维数组转化</span></h4><p>a[x][y]=b[x* 列数＋y]</p>
<p><img src="/image/3.JPG"><br>p[i]=* (p+i)<br>根据上述式子 i= N* x+y 代入<br>得到 p[i]= * （p+i* N+j)</p>
<h4><span id="练习题">练习题</span></h4><p><img src="/image/4.JPG"><br>一个二维数组 a[1…100] [1…65],行数M 100，列数N 65<br> p[i]= * （p+i* N+j)<br>首地址* p为10000 a[56] [22]<br>注意下标是从1开始 因此<br>a[56] [22]= 10000+(65* 55+21)* 2=17912</p>
<h3><span id="指针运算和操作">指针运算和操作</span></h3><h4><span id="指针运算">指针运算</span></h4><p><img src="/image/5.JPG"></p>
<p>p指向i，p不能修改i的值，p本身不是const类型，<br>这里可以修改。p＋＋的时候，指针p跳过i指向下一个内存单元（32位机器为4个字节），此内存单元未定义，所以这里是垃圾值。</p>
<h4><span id="算数运算">算数运算</span></h4><p>加法运算</p>
<p>减法运算</p>
<p><img src="/image/6.JPG"></p>
<p>两个指针都指向同一个数组中的元素时，才允许从一个指针减去另一个指针<br>p2-p1 =3<br>p1-p2 =-3</p>
<h4><span id="关系运算">关系运算</span></h4><p><img src="/image/7.JPG"></p>
<p>这个代码用于清除一个数组中的全部元素</p>
<h3><span id="指针数组和数组指针">指针数组和数组指针</span></h3><h4><span id="指针数组">指针数组</span></h4><p>指针数组是数组<br>一个有十个指针的数组 int * a[10],每个指针指向一个整型数<br><img src="/image/8.JPG"></p>
<h4><span id="数组指针">数组指针</span></h4><p>数组指针是指针<br>数组指针是一个指向数组的指针<br>一个指向有10个元素整型数组的指针的定义为 int (* p) [10]<br>二维数组的数组名是数组指针<br>代码1<br>int a[4] [10];<br>int  (* p)[10];<br>p=a; a的类型是int （ * ）p [ 10 ]<br>p可被替换为a 这里的a是常量不可以进行赋值操作</p>
<p><img src="/image/9.JPG"><br>代码2</p>
<p>int a[ 10 ];<br>int ( * p) [10]=&amp; a;<br>//<br> 这里是&amp;a不是a 。 a的类型是int * .&amp; a的类型是 int （ * ）[10]<br>//<br>int * q=a;</p>
<p><img src="/image/10.JPG"></p>
<hr>
<p>未完结</p>
<hr>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础1</title>
    <url>/2021/02/14/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="模板">模板</span></h2><h3><span id="函数模板">函数模板</span></h3><p>语法形式：<br>template&lt;模板参数表&gt;<br>函数定义<br>模板参数表的内容<br>类型参数 class(或typename)标识符<br>常量参数 类型说明符 标识符<br>模板参数 template&lt;参数表&gt;class标识符</p>
<p>函数模板示例：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
using namespace std;
template &lt;class T&gt;
void outputArray(const T *array,int count)&#123;
    for (int i&#x3D;0;i&lt;count;i++)&#123;
        cout&lt;&lt;array[i]&lt;&lt;&quot; &quot;;
    &#125;
    cout&lt;&lt;endl;
&#125;
int main()&#123;
    const int A_COUNT&#x3D;8,B_COUNT&#x3D;8,C_COUNT&#x3D;20;
    int a[A_COUNT]&#x3D;&#123;1,2,3,4,5,6,7,8&#125;;
    double b[B_COUNT]&#x3D;&#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8&#125;;
    char c[C_COUNT]&#x3D;&quot;welcome!&quot;;
    cout&lt;&lt;&quot;a array contains:&quot;&lt;&lt;endl;
    outputArray(a,A_COUNT);
    cout&lt;&lt;&quot;b array contains:&quot;&lt;&lt;endl;
    outputArray(b,B_COUNT);
    cout&lt;&lt;&quot;c array contains:&quot;&lt;&lt;endl;
    outputArray(c,C_COUNT);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="类模板">类模板</span></h3><p>类模板的声明<br>类模板<br>template&lt;模板参数表&gt;<br>class类名<br>{类成员声明}<br>如果需要在类模板以外定义其成员函数，则要采用以下的形式:<br>template&lt;模板参数表&gt;<br>类型名 类名&lt;模板参数标识符列表&gt;：：函数名(参数表)<br>void Store<t>::putElem(const T &amp;x)<br>例子：</t></p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#include&lt;cstdlib&gt;
using namespace std;
struct Student
&#123;
    int id;
    float gpa;
&#125;;
template &lt;class T&gt;
class Store&#123;
    &#x2F;&#x2F;类模板实现对任意数据进行存取
private:
    T item;&#x2F;&#x2F;用于存放任意类型数据
    bool haveValue;&#x2F;&#x2F;标记item是否已被存入内容
public:
    Store();
    T &amp;getElem();&#x2F;&#x2F;提取数据函数
    void putElem(const T &amp;x);&#x2F;&#x2F;存入数据函数
&#125;;
template&lt;class T&gt;
Store&lt;T&gt;::Store():haveValue(false)&#123;&#125;
template &lt;class T&gt;
T&amp;Store&lt;T&gt;::getElem()&#123;
    &#x2F;&#x2F;如果试图提取未初始化的数据，则终止程序
    if(!haveValue)&#123;
        cout&lt;&lt;&quot;No item present!&quot;&lt;&lt;endl;
        exit(1);&#x2F;&#x2F;退出程序返回操作系统
    &#125;
    return item;&#x2F;&#x2F;返回item中存放的数据
&#125;
template &lt;class T&gt;
void Store&lt;T&gt;::putElem(const T &amp;x)&#123;
    haveValue&#x3D;true;
    item&#x3D;x;
&#125;
int main()&#123;
    Store&lt;int&gt; s1,s2;
    s1.putElem(3);
    s2.putElem(-7);
    cout&lt;&lt;s1.getElem()&lt;&lt;&quot; &quot;&lt;&lt;s2.getElem()&lt;&lt;endl;
    Student g&#x3D;&#123;1000,23&#125;;
    Store&lt;Student&gt; s3;
    s3.putElem(g);
    cout&lt;&lt;&quot;The Student id is &quot;&lt;&lt;s3.getElem().id&lt;&lt;endl;

    Store&lt;double&gt;d;
    cout&lt;&lt;&quot;Retrieving object D..&quot;;
    cout&lt;&lt;d.getElem()&lt;&lt;endl;&#x2F;&#x2F;d未初始化，执行函数D.getElement()时导致程序终止
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="线性群体">线性群体</span></h2><p>线性群体中的元素次序与其逻辑位置关系是对应的。在线性群体中又可以按照访问元素的不同方法分为直接访问，顺序访问和索引访问<br>在这里结合扫直接访问和顺序访问</p>
<h3><span id="链表类">链表类</span></h3><p>链表是一种动态数据结构，可以用来表示顺序访问的线性群体<br>链表是由系列结点组成的，结点可以在运行时动态生成<br>每一个结点包括数据域和指向链表中下一个结点的指针<br>（即下一个结点的地址).如果链表每个结点中只有一个指向后继结点的指针，则该链表称为单链表</p>
<h3><span id="栈">栈</span></h3><p>栈空<br>栈满<br>一般状态</p>
<h4><span id="栈的基本操作">栈的基本操作</span></h4><p>初始化<br>入栈<br>出栈<br>清空栈<br>访问栈顶元素<br>检测栈的状态（满，空）</p>
<h3><span id="队列">队列</span></h3><p>只能向一端添加元素，从另一端删除元素的线性群体<br>先进先出<br>队列的基本状态<br>队空<br>队满<br>一般状态</p>
<h2><span id="排序">排序</span></h2><p>数据元素：数据的基本单位。在计算机中通常作为一个整体进行考虑。一个数据元素可由若干数据项组成<br>关键字： 数据元素中某个数据项的值，用它可以标识一个数据元素<br>在排序过程中需要完成两种基本操作：<br>    比较两个数的大小<br>    调整元素在序列中的位置</p>
<p>内部排序：待排序的数据元素存放在计算机内存中，内存足够容纳所有元素的情况下 内部排序比较。<br>外部排序：数据规模较大的情况分批次比较，需要对外存进行访问的排序过程。</p>
<h3><span id="选择排序">选择排序</span></h3><p>选择排序的基本思想<br>每次从待排序序列中选择一个关键字最小的元素，<br>（当需要按关键字升序排列时），<br>顺序排在已排序序列的最后，直到全部排完</p>
<p>简单选择排序函数模板</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;class T&gt;
void myswap(T &amp;x,T &amp;y)&#123;
    T temp &#x3D;x;
    x &#x3D; y;
    y &#x3D;temp;
&#125;
template&lt;class T&gt;
void selectionSort(T a[],int n)&#123;
    for (int i &#x3D;0;i&lt;n-1;i++)&#123;
        int leastIndex &#x3D; i;
        for (int j&#x3D;i+1;j&lt;n;j++)
            if (a[j]&lt;a[leastIndex])&#123;
                leastIndex &#x3D; j;
            &#125;
        myswap(a[i],a[leastIndex]);
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="交换排序">交换排序</span></h3><p>最简单的交换排序方法–起泡排序</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;class T&gt;
void myswap(T &amp;x,T &amp;y)&#123;
    T temp &#x3D;x;
    x &#x3D; y;
    y &#x3D;temp;
&#125;
void bubbleSort(T a[],int n)&#123;
    int i &#x3D; n-1;
    while(i&gt;0)&#123;
        int lastExchangeIndex &#x3D; 0;
        for (int j &#x3D;0;j&lt;i;j++)
            if(a[j+1]&lt;a[j])&#123;
                myswap(a[j],a[j+1]);
                lastExchangeIndex &#x3D; j;
            &#125; 
            i&#x3D; lastExchangeIndex;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="顺序查找">顺序查找</span></h3><p>从序列的首元素开始，逐个元素与代查找的关键字进行比较，直到找到相等的。若整个序列没有与待查找关键字相等的元素，就是查找不成功。</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;class T&gt;
&#x2F;&#x2F;子函数调用时，并没有申请一个空间来存放形参key，也不用将实参的值传给形参key，因此使程序运行更简化。
int seqSearch(const T list[],int n,const T&amp;key)&#123;
    for (int i&#x3D; 0;i&lt;n;i++)
        if(list[i] &#x3D;&#x3D; key)
            return i;
    return -1;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="二分法查找">二分法查找</span></h3><p>对于已按关键字排序的序列，经过一次比较，可将序列分割成两部分，然后只在有可能包含待查元素的一部分中继续查找，并根据试探结果继续分割，逐步缩小查找范围，直到找到或找不到为止。<br>实现代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">
template&lt;class T&gt;
int binSearch(const T list[],int n,const T &amp;key)&#123;
    int low &#x3D;0;
    int high &#x3D; n-1;
    while(low &lt;&#x3D; high)&#123;
        int mid &#x3D; (low + high)&#x2F;2;
        if (key &#x3D;&#x3D; list[mid])
            return mid;
        else if(key &lt; list)
            high &#x3D; mid -1
        else
            low &#x3D; mid +1

    &#125;
    return -1;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>算法面试2-表格</title>
    <url>/2021/03/21/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%952/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>算法2</p>
<h2><span id="查找问题">查找问题</span></h2><p>查找有无<br>-元素”a”是否存在？set 集合<br>查找对应关系(键值对应)<br>-元素”a”出现了几次？map 字典</p>
<p>set和map<br>通常语言的标准库都内置set和map<br>-容器类<br>-屏蔽实现细节<br>-了解语言中标准库常见容器类的使用</p>
<p>常见操作<br>-insert<br>-find<br>-erase<br>-change(map)</p>
<p>例题349:<br>给定两个数组nums，求两个数组的公共元素<br>-如nums1=[1,2,2,1],nums=[2，2]<br>-结果为[2]<br>-结果中每个元素只能出现一次<br>-出现的顺序可以是任意的</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
using namespace std;
class Solution&#123;
public:
    vector&lt;int&gt;intersection(vector&lt;int&gt;&amp;nums1,vector&lt;int&gt;&amp;nums2)&#123;
        for(int i &#x3D;0;i&lt;nums1.size();i++)
            record.insert(nums[i])
        set&lt;int&gt;resultSet
        for(int i &#x3D;0;i&lt;nums2.size();i++)
            if(record.find(nums2[i]) !&#x3D; record.end())
            &#x2F;&#x2F;find查找元素，如果查找到record.end()为止发现元素，则存在。
            &#x2F;&#x2F;如果&#x3D;record.end()说明没有找到。说明nums2[i]存在
                resultSet.insert(nums2[i])
        vector&lt;int&gt;resultVector;
        for(set&lt;int&gt;::iterator iter &#x3D; resultSet.begin();iter!&#x3D;resultSet.end();iter++)
            resultVector.push_back(* iter);
        return resultVector;

    &#125;
&#125;;
int main()&#123;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以使用容器类的构造方法</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
using namespace std;
class Solution&#123;
public:
    vector&lt;int&gt;intersection(vector&lt;int&gt;&amp;nums1,vector&lt;int&gt;&amp;nums2)&#123;
        set&lt;int&gt; record(nums1.begin(),nums1.end()); &#x2F;&#x2F;简化
        set&lt;int&gt;resultSet;
        for(int i &#x3D;0;i&lt;nums2.size();i++)
            if(record.find(nums2[i]) !&#x3D; record.end())
            &#x2F;&#x2F;find查找元素，如果查找到record.end()为止发现元素，则存在。
            &#x2F;&#x2F;如果&#x3D;record.end()说明没有找到。说明nums2[i]存在
                resultSet.insert(nums2[i])
        return vector&lt;int&gt;(resultSet.begin(),resultSet.end());&#x2F;&#x2F;简化

    &#125;
&#125;;
int main()&#123;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题350：<br>给定两个数组nums,求两个数组的交集<br>如nums1=[1,2,2,1],nums2=[2,2]<br>结果为[2,2]<br>出现的顺序可以是任意的</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
public:
    vector&lt;int&gt;intersection(vector&lt;int&gt;&amp;nums1,vector&lt;int&gt;&amp;nums2)&#123;
        map&lt;int,int&gt;record;
        for(int i &#x3D;0;i&lt;nums1.size();i++)
            record[nums1[i]]++; &#x2F;&#x2F;记录频次
        vector&lt;int&gt;resultVector;
        for(int i &#x3D;0;i&lt;nums2.size();i++)
            if(record[nums2[i]]&gt;0)&#123;
                resultVector.push_back(nums2[i]);
                    &#x2F;&#x2F;nums2[i]);&#x2F;&#x2F;如果发现在nums2中某以元素的频次也大于0，则记录下来
                    record[nums2[i]--];
            &#125;
        return resultVector;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>C++中map的默认值为0<br>换种写法风格</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
public:
    vector&lt;int&gt;intersection(vector&lt;int&gt;&amp;nums1,vector&lt;int&gt;&amp;nums2)&#123;
        map&lt;int,int&gt;record;
        for(int i &#x3D;0;i&lt;nums1.size();i++)
            if(record.find(nums1[i])&#x3D;&#x3D; record.end())
                record.insert(make_pair(nums1[i],1));&#x2F;&#x2F;初始键值为1
            record[nums1[i]]++; &#x2F;&#x2F;如果存在某一元素则记录频次
        vector&lt;int&gt;resultVector;
        for(int i &#x3D;0;i&lt;nums2.size();i++)
            if(record.find(nums2[i])!&#x3D;record.end()&amp;&amp;record[nums2[i]]&gt;0)&#123;
                resultVector.push_back(nums2[i]);
                    &#x2F;&#x2F;nums2[i]);&#x2F;&#x2F;如果发现在nums2中某以元素的频次也大于0，则记录下来
                    record[nums2[i]--];
                    if(record[nums2[i]]&#x3D;&#x3D;0)
                        record.erase(nums2[i]);&#x2F;&#x2F;每求一次交集将这个元素抹去
            &#125;
        return resultVector;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于两个问题，如果数组有序？<br>set和map有不同的底层实现</p>
<h2><span id="哈希表">哈希表</span></h2><p>哈希表的缺点是失去了数据的顺序性<br>map和set的底层实现为平衡二叉树，时间复杂度为O(nlogn)<br>unordered_map 和 unordered_set 的底层实现为哈希表</p>
<h3><span id="数据的顺序性">数据的顺序性</span></h3><p>-数据集中的最大值和最小值<br>-某个元素的前驱和后置<br>-某个元素的floor和ceil<br>-某个元素的排位rank<br>-选择某个排位的元素select</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;unordered_set&gt;
using namespace std;
&#x2F;&#x2F;时间复杂度O(n)
&#x2F;&#x2F;空间复杂度O(n)
class Solution&#123;
public:
    vector&lt;int&gt;intersection(vector&lt;int&gt;&amp;nums1,vector&lt;int&gt;&amp;nums2)&#123;
        unordered_set&lt;int&gt; record(nums1.begin(),nums1.end()); &#x2F;&#x2F;简化
        unordered_set&lt;int&gt;resultSet;
        for(int i &#x3D;0;i&lt;nums2.size();i++)
            if(record.find(nums2[i]) !&#x3D; record.end())
            &#x2F;&#x2F;find查找元素，如果查找到record.end()为止发现元素，则存在。
            &#x2F;&#x2F;如果&#x3D;record.end()说明没有找到。说明nums2[i]存在
                resultSet.insert(nums2[i])
        return vector&lt;int&gt;(resultSet.begin(),resultSet.end());&#x2F;&#x2F;简化

    &#125;
&#125;;
int main()&#123;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>unordered_map 哈希表底层实现为O(1)</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;时间复杂度O(n)
&#x2F;&#x2F;空间复杂度O(n)
class Solution&#123;
public:
    vector&lt;int&gt;intersection(vector&lt;int&gt;&amp;nums1,vector&lt;int&gt;&amp;nums2)&#123;
        unordered_map&lt;int,int&gt;record;
        for(int i &#x3D;0;i&lt;nums1.size();i++)
            record[nums1[i]]++; &#x2F;&#x2F;记录频次
        vector&lt;int&gt;resultVector;
        for(int i &#x3D;0;i&lt;nums2.size();i++)
            if(record[nums2[i]]&gt;0)&#123;
                resultVector.push_back(nums2[i]);
                    &#x2F;&#x2F;nums2[i]);&#x2F;&#x2F;如果发现在nums2中某以元素的频次也大于0，则记录下来
                    record[nums2[i]--];
            &#125;
        return resultVector;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题：242 Valid Anagram<br>判断字符串t是否是字符串s变换字符顺序后得到的结果<br>如s = “anagram” ,t = “nagaram”，则返回true<br>如s = “rat”, t = “car” ，则返回false</p>
<p>例题： 202 Happy number<br>判断一个数是否为happy number。happy number是指，一个数，将其替换为其各位数字的平方和，重复这个过程，如果最终能得到1，这是happy number，如果这个过程陷入了一个不包含1的循环，则不是happy number<br>如：数字19：<br>1^2+9^2 = 82<br>8^2+2^2 = 68<br>6^2+8^2 = 100<br>1^2+0^2+0^2 = 1  Happy number!   </p>
<p>例题： 290 word pattern<br>给定一个模式和一个字符串，判断字符串是否符合模式</p>
<p>例题: 205 Isomorphic Strings<br>判断两个字符串是否同构？</p>
<p>例题： 251<br>给定一个字符串，按照字母出现频率的倒序重组整个字符串</p>
<h2><span id="一个使用查找表的经典问题">一个使用查找表的经典问题</span></h2><p>例题： 1 Two Sum</p>
<p>给定一个整型数组nums。返回这个数组两个数字的索引值i和j<br>使得nums[i]+nums[j] = 一个给定的target<br>-索引从0开始<br>-没有解怎么办<br>-有多个解怎么办 ,保证有唯一解</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
public:
    vector&lt;int&gt;twoSum(vector&lt;int&gt;&amp;nums,int target)&#123;
        unordered_map&lt;int,int&gt;record;
        for(int i &#x3D; 0;i&lt;num.size();i++)
            record[nums[i]] &#x3D; i;
            int complement &#x3D; target - nums[i];
            if(record.find(complement)!&#x3D; record.end())&#123;
                int res[2] &#x3D; &#123;i,record[complement]&#125;;
                return vector&lt;int&gt;(res,res+2);
            &#125;
            record[nums[i]] &#x3D; i;
    &#125;
    throw invalid_arguement(&quot;the input has no solution&quot;)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题： 219<br>给出一个整型数组nums和一个整数k，是否存在索引i和j，使得nums[i] == nums[j]<br>且i,j之间的差不超过k</p>
<p>这个问题也是使用滑动窗口查找表</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;时间复杂度O(n)
&#x2F;&#x2F;空间复杂度O(k)

class Solution&#123;
    public:
        bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums,int k)&#123;
            unordered_set&lt;int&gt;record;
            for (int i &#x3D; 0;i&lt;nums.size();i++)&#123;
                if(record.find(nums[i])!&#x3D;record.end()) &#x2F;&#x2F;如果新的元素在原窗口中找得到，返回true
                    return true;
                record.insert(nums[i]);
                &#x2F;&#x2F;如果新的元素原窗口中不存在，则添加该元素
                if(record.size()&#x3D;&#x3D;k+1)  &#x2F;&#x2F;保持record最多k个元素
                    record.erase(nums[i-k]);
            &#125;
            return false;
        &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题：217 Contains Duplicate</p>
<p>例题：220<br>给出一个整型数组nums和一个整数k，是否存在索引i和j，使得nums[i]和nums[j]之间的差别不超过给定整数t，且i,j之间的差不超过整数k</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;时间复杂度O(n)
&#x2F;&#x2F;空间复杂度O(k)
#include&lt;vector&gt;
#include&lt;set&gt;
using namespace std;
class Solution&#123;
    public:
        bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums,int k,int t)&#123;
            set&lt;int&gt;record;
            for (int i &#x3D; 0;i&lt;nums.size();i++)&#123;
                if(record.lower_bound(nums[i]-t)!&#x3D;record.end() &amp;&amp; *record.lower_bound(nums[i]-t)&lt;&#x3D;nums[i]+t)
                &#x2F;&#x2F;确保寻找的元素在[v-t,v+t]的范围内
                    return true;

                record.insert(nums[i]);
                &#x2F;&#x2F;如果新的元素原窗口中不存在，则添加该元素
                if(record.size()&#x3D;&#x3D;k+1)  &#x2F;&#x2F;保持record最多k个元素
                    record.erase(nums[i-k]);
            &#125;
            return false;
        &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法面试</tag>
      </tags>
  </entry>
  <entry>
    <title>算法面试1-数组</title>
    <url>/2021/03/15/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>算法</p>
<h2><span id="什么是大o">什么是大O</span></h2><p>n表示数据规模<br>O(f(n))表示运行算法所需要执行的指令数，和f(n)成正比<br>二分查找法O(logn)       所需执行指令数：a<em>logn<br>寻找数组中的最大/最小值  所需执行指令数：b</em>n<br>归并排序算法O(nlogn)    所需指令数：c<em>nlogn<br>选择排序法O(n^2)        所需指令数：d</em>n^2</p>
<p>算法A： O(n)         所需指令数：10000<em>n<br>算法B： O(n^2)         所需指令数: 10</em>n^2</p>
<p>在学术界，严格来讲，O(f(n))表示算法执行的上界<br>归并排序算法的时间复杂度是O(nlogn)的，同时也是O(n^2)</p>
<p>在业界，我们使用O来表示算法执行的最低上界<br>对邻接表实现的图进行遍历：<br>时间复杂度： O(V+E)<br>！在这里V是图中顶点个数，E是图中边的个数 V和E没有关系 不能替换<br>插入排序算法 O(n^2)               快速排序算法O(nlogn)<br>最差情况：   O(n^2)              最差情况O(n^2)<br>最好情况：   O(n)                最好情况：O(nlogn)<br>平均情况：   O(n^2)              平均情况：O(nlogn)</p>
<h3><span id="例题1">例题1</span></h3><p>一个时间复杂度的问题<br>有一个字符串数组，将数组中的每一个字符串按照字母序进行排序；之后再将整个字符串数组按照字典序排序。整个操作的时间复杂度？<br>假设最长的字符串长度为s；数组中有n个字符串<br>对每个字符串排序：O(slogs)<br>将数组中的每一个字符串按照字母序: O(n<em>slog(s)+)<br>将整个字符串数组按照字典序排序： O(s</em>nlog(n))<br> O(n<em>slog(s)) + O(s</em>nlog(n)) = O(n<em>slog(s)+s</em>nlog(n))</p>
<h2><span id="数据规模的概念">数据规模的概念</span></h2><p>如果想要在1s内解决问题：<br>O(n^2)的算法可以处理大约10^4级别的数据<br>O(n)的算法可以处理大约10^8级别的数据<br>O(nlogn)的算法可以处理大约10^7级别的数据</p>
<h2><span id="空间复杂度">空间复杂度</span></h2><p>多开一个辅助的数组： O(n)<br>多开一个辅助的二维数组： O(n^2)<br>多开常数空间： O(1)<br>递归调用是有空间代价的</p>
<h2><span id="复杂度">复杂度</span></h2><p>O(1)</p>
<pre class="line-numbers language-none"><code class="language-none">void swapTwoInts(int &amp;a,int &amp;b)&#123;
    int temp &#x3D; a;
    a &#x3D; b;
    b &#x3D; temp
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>O(n)</p>
<pre class="line-numbers language-none"><code class="language-none">int sum(int n)&#123;
    int ret &#x3D; 0;
    for(int i &#x3D; 0;i&lt;&#x3D;n;i++)
        ret +&#x3D;i;
    return ret;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>O(n)</p>
<pre class="line-numbers language-none"><code class="language-none">void reverse(string &amp;s)&#123;
    int n &#x3D; s.size();
    for(int i &#x3D; 0;i&lt;n&#x2F;2;i++)
        swap(s[i],s[n-1-i]);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>1/2* n次swap操作： O(n)</p>
<p>O(n^2)</p>
<pre class="line-numbers language-none"><code class="language-none">void  selectionSort(int arr[],int n)&#123;
    for (int i &#x3D;0;i&lt;n;i++)&#123;
        int minIndex &#x3D; i;
        for (int j &#x3D;i+1;j&lt;n;k++)
            if (arr[j] &lt;arr[minIndex])
                minIndex &#x3D; j;
        swap(arr[i],arr[minIndex])
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>(n-1)+(n-2)+…+0<br>1/2* n^2 -1/2* n =O(n^2)</p>
<p>O(n^2)?</p>
<pre class="line-numbers language-none"><code class="language-none">void printInformation(int n)&#123;
    for(int i &#x3D;1;i&lt;&#x3D;n;i++)
        for(int j &#x3D;1;j&lt;&#x3D;30;j++)
            cout&lt;&lt;&quot;class&quot;&lt;&lt;i&lt;&lt;&quot;-&quot;&lt;&lt;&quot;NO.&quot;&lt;&lt;j&lt;&lt;endl;
        return;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>30n次基本操作：O(n)</p>
<p>O(logn)</p>
<pre class="line-numbers language-none"><code class="language-none">int binarySearch(int arr[],int n;int target)&#123;
    int l &#x3D;0,r &#x3D; n-1;
    while(l&lt;&#x3D;r)&#123;
        int mid &#x3D; l+(r-l)&#x2F;2;
        if(arr[mid] &#x3D;&#x3D; target)
            return mid;
        if(arr[mid] &gt; target)
            r &#x3D; mid - 1;
        else 
            l &#x3D; mid + 1;
    &#125;
    return -1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>n<br>n/2<br>n/4<br>.<br>.<br>.<br>1<br>n经过几次除以2操作后，等于1<br>log2 n = O(logn)</p>
<p>O(logn)</p>
<pre class="line-numbers language-none"><code class="language-none">string inToString(int sum)&#123;
    string s &#x3D; &quot; &quot;;
    while(num)&#123;
        s +&#x3D; &#39;0&#39;+num%10; &#x2F;&#x2F;int类型变成char类型，就需要加上一个’0’了
        num &#x2F;&#x3D;10;
        &#125;
        reverse(s);
        return s;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>n经过几次除以10操作后，等于0<br>?num为负数的情况下？</p>
<p>O(n^2)</p>
<pre class="line-numbers language-none"><code class="language-none">void hello(int n)&#123;
    for(int sz &#x3D; 1;sz &lt; n;sz +&#x3D; sz)
        for(int i &#x3D;1;i&lt;n;i++)
            cout&lt;&lt;&quot;Hello,Algorithm&quot;&lt;&lt;endl;
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第一层循环中 ，实际上sz每次增加为2* sz<br>换种理解方式第一层循环执行的次数 = n经过几次除以2之后等于1<br>所以执行数为O(logn)<br>总执行数为O(nlogn)</p>
<p>O(sqrt(n))<br>判断一个数是否为素数</p>
<pre class="line-numbers language-none"><code class="language-none">bool isPrime(int n)&#123;
    for(int x &#x3D;2;x*x&lt;&#x3D;n;x++)
        if(n%x &#x3D;&#x3D; 0)
            return false;
        return true;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="递归算法的复杂度分析">递归算法的复杂度分析</span></h3><pre class="line-numbers language-none"><code class="language-none">double pow(double x,int n)&#123;
    assert(n &gt;&#x3D;0 );
    if (n &#x3D;&#x3D; 0)
        return 1.0;
    double t &#x3D; pow(x,n&#x2F;2);
    if(n%2) &#x2F;&#x2F;判断是否能被2整除
        return x*t*t;
    return t*t;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果一个一个相乘计算，时间复杂度为O(n)<br>这里通过递归调用 降低了时间复杂度<br>递归深度： logn<br>时间复杂度: O(logn)</p>
<h4><span id="递归中进行多次递归调用">递归中进行多次递归调用</span></h4><pre class="line-numbers language-none"><code class="language-none">int f(int n)&#123;
    assert(n&gt;&#x3D;0);
    if(n&#x3D;&#x3D;0)
        return 1;
    return f(n-1)+f(n-1);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>多次递归调用，实际上是算树的有多少节点<br>时间复杂度O(2^n)<br>指数级算法计算效果非常差</p>
<p>主定理？</p>
<h3><span id="均摊复杂度分析-amortized-time">均摊复杂度分析 Amortized Time</span></h3><p>动态数组(vector)</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
using namespace std;
template&lt;typename T&gt;
class Myvector&#123;
private:
    T *data;
    int capacity;
    int size;

    void resize(int newCapacity)&#123;
        T *newData &#x3D; new T[newCapacity];
        for(int i &#x3D;0;i&lt;size;i++)
            newData[i] &#x3D; data[i];
        delete[]data;
        data &#x3D; newData;
        capacity &#x3D; newCapacity;
    &#125;
public:
    Myvector()&#123;
        data &#x3D; new T[10];
        capacity &#x3D; 10;
        size &#x3D; 0;
    &#125;
    ~Myvector()&#123;
        delete[] data;
    &#125;
    &#x2F;&#x2F;average : O(1)
    void push_back(T e)&#123;
        if(size&#x3D;&#x3D;capacity)
            resize(2*capacity);
        data[size++] &#x3D; e;
    &#125;
    &#x2F;&#x2F;O(1)
    T pop_back()&#123;
        assert(size&gt;0);
        T ret &#x3D; data[size-1];
        size--; &#x2F;&#x2F;没有真正的把最后一个元素删除，而是把整个元素放在合法范围外
        if(size &#x3D;&#x3D; capacity&#x2F;4)  &#x2F;&#x2F;这里在某一临界值，程序处于连续增大内存空间与删除内存空间的操作，所以为了避免时间复杂度的震荡，在这里把临界值改为1&#x2F;4 capacity
            resize (capacity&#x2F;2);

        return ret;
    &#125;

&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>动态数组<br>动态栈<br>动态队列</p>
<h2><span id="数组算法问题">数组算法问题</span></h2><p>如何写出正确的程序<br>明确变量的含义<br>循环不变量<br>小数据量调试<br>大数据量调试</p>
<h3><span id="二分查找法">二分查找法</span></h3><p>对于有序数列，才能使用二分查找法（排序的作用）</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cassert&gt;
#include&lt;ctime&gt;
using namespace std;
template&lt;typename T&gt;
int binarySearch(T arr[],int n,T target)&#123;
    int l &#x3D; 0,r &#x3D; n-1; &#x2F;&#x2F;在[l,r]范围 里寻找target
    while(l&lt;&#x3D;r)&#123; &#x2F;&#x2F;当l&#x3D;&#x3D;r时，区间[l.....r]依然是有效的
    int mid &#x3D; (l+r)&#x2F;2; &#x2F;&#x2F;为了防止整型溢出 mid &#x3D; l + (r-l)&#x2F;2
    if (arr[mid] &#x3D;&#x3D; target)
        return mid;
    if(target&gt;arr[mid])
        l &#x3D; mid +1; &#x2F;&#x2F;target在[mid+1...r]中
    else 
        r &#x3D; mid -1;&#x2F;&#x2F;targer在[l...mid-1]中
    &#125;

    return -1;

&#125;
int main()&#123;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="真实面试问题">真实面试问题</span></h2><h3><span id="问题283">问题283：</span></h3><p>给定一个数组nums,写一个函数，将数组中的所有的0挪到数组的末尾，而维持其他所有非0元素的相对位置。<br>举例：<br>nums = [0,1,0,3,12]，函数运行后的结果为[1,3,12,0,0]</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
public:
    &#x2F;&#x2F;时间复杂度：O(n)
    &#x2F;&#x2F;空间复杂度：O(n)
    void moveZeroes(vector &lt;int&gt;&amp; nums)&#123;
        vector &lt;int&gt; nonZeroElements; 
        for(i &#x3D;0;i&lt;nums.size();i++)
            if(nums[i])  &#x2F;&#x2F;判断数组是否非0
                nonZeroElements.push_back(num[i]);&#x2F;&#x2F;pushback压入非零数组
        for(int i &#x3D;0;i&lt;nonZeroElements.size();i++) &#x2F;&#x2F;遍历一边非零数组 将其再赋值给原数组
            num[i] &#x3D; nonZeroElements[i];
        for(int i &#x3D; nonZeroElements.size();i&lt;num.size();i++) &#x2F;&#x2F;在数组后面空余位置补充0
            num[i] &#x3D; 0;
    &#125;
&#125;
int main()&#123;
    int arr[0,1,0,3,12];
    vector&lt;int&gt; vec(arr,arr+sizeof(arr)&#x2F;sizeof(int));
    Solution().moveZeroes(vec);
    for(int i&#x3D;0;i&lt;vec.size();i++)
        cout&lt;&lt;vec[i]&lt;&lt;&quot; &quot;;
    cout&lt;&lt;endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>优化:不用辅助空间</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
public:
    &#x2F;&#x2F;时间复杂度：O(n)
    &#x2F;&#x2F;空间复杂度 :O(1)
    void moveZeroes(vector &lt;int&gt;&amp; nums)&#123;
        int k &#x3D;0; &#x2F;&#x2F;索引k  nums中,[0,k)的元素均为非0元素
        &#x2F;&#x2F;遍历到第i个元素后，保证[0...i]中所有非0元素
        &#x2F;&#x2F;都按照顺序排列在[0..k]中
        for(i &#x3D;0;i&lt;nums.size();i++)
            if(nums[i])  &#x2F;&#x2F;判断数组是否非0
                nums[k++] &#x3D; nums[i];
        for(int i &#x3D;0;i&lt;num.size();i++) 
            num[i] &#x3D; 0;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>继续优化：<br>交换排序比一个个赋值香</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
public:
    &#x2F;&#x2F;时间复杂度：O(n)
    &#x2F;&#x2F;空间复杂度 :O(1)
    void moveZeroes(vector &lt;int&gt;&amp; nums)&#123;
        int k &#x3D;0; &#x2F;&#x2F;索引k  nums中,[0,k)的元素均为非0元素
        &#x2F;&#x2F;遍历到第i个元素后，保证[0...i]中所有非0元素
        &#x2F;&#x2F;都按照顺序排列在[0..k]中
        &#x2F;&#x2F;同时[k...i]为0

        for(i &#x3D;0;i&lt;nums.size();i++)
            if(nums[i])  &#x2F;&#x2F;判断数组是否非0
                swap(nums[k++],nums[i]);
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我TM再优化:<br>当元素都为0的时候交换消耗时间<br>再增加一个条件语句</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
public:
    &#x2F;&#x2F;时间复杂度：O(n)
    &#x2F;&#x2F;空间复杂度 :O(1)
    void moveZeroes(vector &lt;int&gt;&amp; nums)&#123;
        int k &#x3D;0; &#x2F;&#x2F;索引k  nums中,[0,k)的元素均为非0元素
        &#x2F;&#x2F;遍历到第i个元素后，保证[0...i]中所有非0元素
        &#x2F;&#x2F;都按照顺序排列在[0..k]中
        &#x2F;&#x2F;同时[k...i]为0

        for(i &#x3D;0;i&lt;nums.size();i++)
            if(nums[i])  &#x2F;&#x2F;判断数组是否非0
                if(i!&#x3D;k)
                    swap(nums[k++],nums[i]);
                else &#x2F;&#x2F;i&#x3D;&#x3D;k
                    k++;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Remove Element<br>问题27：<br>给定一个数组nums和一个数值val,将数组中所有等于val的元素删除，并返回剩余的元素个数<br>如何定义删除？从数组中删除？还是放在数组末尾？<br>剩余元素的排列是否要保证原有的相对顺序？<br>是否有空间复杂度的要求？</p>
<p>问题26：<br>给定一个有序数组，对数组中的元素去重，使得原数组的每个元素只有一个，并返回去重后数组的长度值</p>
<p>问题80：<br>给定一个有序数组，对数组中的元素去重，使得原数组的每个元素最多保留两个。返回去重后的长度值<br>如nums = [1,1,1,2,2,3]<br>结果返回应为5，返回的元素1,1,2,2,3</p>
<h3><span id="基础算法思路的应用">基础算法思路的应用</span></h3><p>问题75：<br>给定一个有n个元素的数组，数组中元素的取值只有0，1，2三种可能，为这个数组排序<br>-可以使用任意一种排序算法<br>-没有使用上题目中给出的特殊条件</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;cassert&gt;
#include&lt;vector&gt;
using namespace std;
class Solution&#123;
public:
    void SortColors(vector &lt;int&gt; &amp;nums)&#123;
        int count[3] &#x3D; &#123;0&#125;; &#x2F;&#x2F;存放0，1，2的频率
        for (int i &#x3D; 0; i &lt; nums.size();i++)
            assert(num[i] &gt;&#x3D; 0 &amp;&amp; num[i] &lt;&#x3D; 2);
            count[nums[i]]++; &#x2F;&#x2F;计算频率 
    &#125;
    int index &#x3D; 0;
    for (int i &#x3D; 0;i&lt;count[0],i++)
        nums[index++] &#x3D; 0;
    for (int i &#x3D; 0; i &lt; count[1];i++)
        nums[index++] &#x3D; 1;
    for (int i &#x3D; 0; i &lt; count[2];i++)
        nums[i] &#x3D; 2;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>前者多次遍历数组，进行优化</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
    &#x2F;&#x2F;时间复杂度O(n)
    &#x2F;&#x2F;空间复杂度O(1)
    &#x2F;&#x2F;只遍历一遍
public:
    void  SortColors(vector &lt;int&gt; &amp;nums)&#123;
        int zero &#x3D; -1;&#x2F;&#x2F;nums[0...zero] &#x3D;&#x3D; 0 前后闭区间，这样当zero等于-1的时候区间无效不会算为0
        int two &#x3D; nums.size() &#x2F;&#x2F;nums[two...n-1] &#x3D;&#x3D; 2
                  for (int i &#x3D; 0; i &lt; two;) &#123;
                    if (nums[i] &#x3D;&#x3D; 1)
                        i++;
                    else if (nums[i] &#x3D;&#x3D; 2)
                        swap(nums[i], nums[--two]);
                    else if(nums[i]&#x3D;&#x3D;0)
                        zero++;
                        swap(nums[zero], nums[i]);&#x2F;&#x2F;swap(nums[++zero],nums[i++])简写
                        i++;
    &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>问题88：<br>给定两个有序整型数组nums1,nums2,将nums2的元素归并到nums1</p>
<p>问题215:<br>在一个整数序列中寻找第k大的元素<br>-如给定数组[3,2,1,5,6,4],k=2,结果为5<br>利用快排partition,将pivot放置在了其正确的位置上的性质</p>
<p>问题167:<br>给定一个有序整型数组和一个整数target，在其中寻找两个元素，使其和为target,返回这两个数的索引。<br>如numbers = [2,7,11,15],target = 9;<br>返回数字2，7的索引1，2 （索引从1开始计算）<br>-如果没有解的情况下？<br>-如果有多个解的情况？返回任意解</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;

public:
    vector &lt;int&gt; twoSum(vector &amp;numbers,int target)&#123;
        int l &#x3D;0;,r&#x3D;number.size()-1;
        while(l&lt;r)&#123;
            if(numbers[r]&#x3D;&#x3D;target)&#123;
                int res[2] &#x3D; &#123;l +1 ,r+ 1&#125;;
                return vector&lt;int&gt; (res,res+2);

            &#125;
            else if(numbers[l]+numbers[r]&lt;target)
                l++;
            else
                r--;
    &#125;
    throw invalid_argument(&quot;The input has no solution.&quot;)
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>问题125：<br>给定一个字符串，只看其中的数字和字母，忽略大小写，判断这个字符串是否为回文串？<br>-空字符串如何看<br>-字符的定义<br>-大小写问题</p>
<p>问题344：<br>给定一个字符串，返回这个字符串的倒序字符串<br>如hello，返回olleh<br>类似：翻转一个数组</p>
<p>问题345:<br>给定一个字符串，将该字符串中的元音字母翻转<br>如hello，返回holle<br>原因不包含y</p>
<p>问题11：<br>给出一个非负整数数组a1…an;每一个整数表示一个竖立在坐标轴x位置的一堵高度为ai的墙，选择两堵墙，和x轴构成的容器容纳最多的水</p>
<p>问题：209<br>双索引技术 Facebook<br>给定一个数组和一个数字s，找到数组中最短的一个连续子数组，使得连续子数组的数字和sum&gt;=s,返回这个最短的连续子数组的长度值</p>
<ul>
<li>如 给定数组[2,3,1,2,4,3]，s=7</li>
<li>答案为[4,3] 返回2<br>什么叫子数组<br>子数组可以不连续，此题中强调连续子数组<br>如果没有解怎么办 返回0？<br>暴力解：遍历所有的连续子数组[i…j]<br>计算其和sum 验证sum&gt;=s<br>时间复杂度为O(n^3)<br>优化暴力解 O(n^2)？</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
    &#x2F;&#x2F;时间复杂度O(n)
    &#x2F;&#x2F;空间复杂度O(1)
public:
    int minSubArrayLen(int s,vector&lt;int&gt; &amp;nums)&#123;
        int l &#x3D;0,r&#x3D;-1; &#x2F;&#x2F;这里的关键是设置滑动窗口，初始范围为nums[l,r] r&#x3D;-1初始值无效
        int sum &#x3D; 0;
        int res &#x3D; nums.size()+1;
        while(l&lt;nums.size())&#123;
            if(r+1&lt;nums.size()&amp;&amp;sum&lt;s)&#123;
                r++;
                sum+&#x3D;nums[r];
            else
                sum-&#x3D;nums[l++];
            if(sum&#x3D;&#x3D;s)
                res &#x3D; min(res,l-r+1);&#x2F;&#x2F;闭区间
            &#125;
        if(res &#x3D; nums.size()+1) &#x2F;&#x2F;当遍历一遍之后没有解，则返回0
            return 0;
        return res;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题3：<br>在一个字符串中寻找没有重复字母的最长子串<br>如“abcccaa” abc<br>字符集，只有字母？数字+字母？ASCII？<br>大小写是否敏感？</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution()&#123;
public:
    int lengthOfLongestSubstring(string s)&#123;
        int freq[256] &#x3D; &#123;0&#125;;
        int l &#x3D;0,r&#x3D;-1; &#x2F;&#x2F;滑动窗口为s[l...r]
        int res &#x3D; 0;
        while(l&lt;s.size())&#123;
            if (r+1&lt;s.size()&amp;&amp;freq[s[r+1]] &#x3D;&#x3D; 0)
                freq[s[++r]]++；
            else
                freq[s[l++]]--;&#x2F;&#x2F;如果重复了，这里将频率-1，左边界右移
            res &#x3D; max(res,r-l+1);
        &#125;
        return res;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题438：<br>给定一个字符串s和一个非空字符串p,找出p中所有是s的anagrams字符串的子串，返回这些字串的起始索引。<br>如s=”cbaebabacd” p=”abc” 索引[0,6]<br>字符集范围？英文小写字母<br>返回解的顺序？任意</p>
<p>例题 76:<br>给定一个字符串S和T，在S中寻找最短的子串，包含T中的所有字符<br>如S=”ADOBECODEBANC” T=”ABC”<br>结果为”BANC”</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法面试</tag>
      </tags>
  </entry>
  <entry>
    <title>算法面试3-链表</title>
    <url>/2021/04/04/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%953-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>算法3 链表</p>
<h2><span id="链表">链表</span></h2><p>例题：206 Reverse Linked List<br>反转一个链表</p>
<pre class="line-numbers language-none"><code class="language-none">struct ListNode&#123;
    int val;
    ListNode *next;
    ListNode (int x):val(x),next(NULL)&#123;&#125;

&#125;;
class Solution&#123;
public:
    ListNode*reverselist(ListNode *head)
        ListNode *pre &#x3D; NULL;
        ListNode *cur &#x3D; head;
        while(cur!&#x3D;NULL)&#123;
            ListNode*next &#x3D; cur-&gt;next;
            cur-&gt;next &#x3D; pre; &#x2F;&#x2F;链表指向反转，指向前面的pre
            &#x2F;&#x2F;链表后移 pre 变成cur cur编程next
            pre &#x3D; cur;
            cur &#x3D; next;
        &#125;
        return pre;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题：83<br>例题：328</p>
<p>例题：2 Add Two Numbers</p>
<h3><span id="设立链表的虚拟头结点">设立链表的虚拟头结点</span></h3><p>例题：203 Remove Linked List Elements</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
public:
    ListNode*removeElements(ListNode *head,int val)&#123;
        while(head !&#x3D; NULL&amp;&amp;head-&gt;val &#x3D;&#x3D; val)&#123;
            ListNode *delNode &#x3D; head;
            head &#x3D; delNode-&gt;next
        &#125;
        if(head &#x3D;&#x3D;NULL)
            return NULL;
        ListNode * cur &#x3D; head;
        while(cur-&gt;next !&#x3D; NULL)&#123;
            if(cur-&gt;next-&gt;val &#x3D;&#x3D; val)&#123;
                &#x2F;&#x2F;删除cur-&gt;next
                ListNode *delNode &#x3D; cur-&gt;next; &#x2F;&#x2F;给要删除的节点存储一下
                cur-&gt;next &#x3D; delNode-&gt;next;
                delete delNode;
                &#x2F;&#x2F;delnode-&gt;next &#x3D; NULL;
            &#125;
            else
                cur &#x3D; cur-&gt;next;
        &#125;       
        return head;
&#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里采用虚拟头节点的方法来简化代码<br>在head前创建一个dummyhead</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
public:
    ListNode*removeElements(ListNode *head,int val)&#123;
        ListNode *dummyHead &#x3D; new ListNode(0);
        dummyHead-&gt;next &#x3D; head;
        ListNode * cur &#x3D; dummyHead;
        while(cur-&gt;next !&#x3D; NULL)&#123;
            if(cur-&gt;next-&gt;val &#x3D;&#x3D; val)&#123;
                &#x2F;&#x2F;删除cur-&gt;next
                ListNode *delNode &#x3D; cur-&gt;next; &#x2F;&#x2F;给要删除的节点存储一下
                cur-&gt;next &#x3D; delNode-&gt;next;
                delete delNode;
                &#x2F;&#x2F;delnode-&gt;next &#x3D; NULL;
            &#125;
            else
                cur &#x3D; cur-&gt;next;
        &#125;       
        ListNode *retNode &#x3D; dummyHead-&gt;next;
        delete dummyHead;
        return retNode;
        &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题：24 Swap Nodes in pairs</p>
<p>leetcode 已完成</p>
<p>例题： 148 sort list</p>
<p>例题： 237 Delete node in a linked list<br>删除某一个指定的节点</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
public:
    void deleteNode(ListNode * node)&#123;
        if(node &#x3D;&#x3D; NULL)
            return;
        if(node-&gt;next &#x3D;&#x3D; NULL)&#123;
            delete node;
            node &#x3D; NULL; &#x2F;&#x2F;这里node在最后，他的前一个节点指向NULL
            return;

        &#125;
        node-&gt;val &#x3D; node-&gt;next-&gt;val;
        ListNode *delnode &#x3D; node-&gt;next;
        node-&gt;next &#x3D; delNode-&gt;next; &#x2F;&#x2F;跳过这个节点指向下一个节点
        delete delnode;
        return;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="双指针技术">双指针技术</span></h3><p>例题： 19 remove Nth Node from end of list<br>如1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,n=2<br>返回1-&gt;2-&gt;3-&gt;5<br>n是从0开始还是从1开始<br>n不合法怎么办？<br>解法1：先遍历一边计算链表长度；再遍历一边删除倒数第n个节点<br>能不能只遍历一边链表？</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
public:
    ListNode *removeNthFromEnd(ListNode *head,int n)&#123;
        assert(n&gt;&#x3D;0);
        ListNode *dummyHead &#x3D; new ListNode(0);
        dummyHead -&gt;next &#x3D; head;
        ListNode *p &#x3D; dummyHead;
        ListNode *q &#x3D; dummyHead;
        for(int i &#x3D; 0;i&lt;n+1;i++)&#123;
            assert(q);
            q &#x3D; q-&gt;next;&#x2F;&#x2F;q向后移动到正数第n个位置，使得pq位置长度为n
        &#125;
        while(q!&#x3D;NULL)&#123;
            p &#x3D; p-&gt;next;
            q &#x3D; q-&gt;next; &#x2F;&#x2F;滑动双索引
            ListNode *delNode &#x3D; p-&gt;next;&#x2F;&#x2F;删除p后面的节点
            p-&gt;next &#x3D; delNode-&gt;next;
            delete delNode;
            ListNode *retNode &#x3D; dummyHead-&gt;next;
            delete dummyHead;
            return retNode;
        &#125;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题61 rotate list<br>例题143 Reorder List<br>链表无法随机访问数据，如何获得中间的元素<br>两次遍历？一次遍历？<br>例题: 234 palindrome linked list<br>能否使用O(1)的空间复杂度解决问题？</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法面试</tag>
      </tags>
  </entry>
  <entry>
    <title>经验回放原理</title>
    <url>/2021/04/16/%E7%BB%8F%E9%AA%8C%E5%9B%9E%E6%94%BE%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="时序差分学习temporal-difference-learning">时序差分学习（Temporal Difference Learning）</span></h2><p>强化学习中常用时序差分学习来更新模型，时序差分学习的一般流程是：</p>
<p>1.模型根据获取到的状态 st 决定采取动作 at 。</p>
<p>2.环境在执行动作 at 后会给出对应的奖励 rt 和新的状态 st+1 。</p>
<p>3.根据 TD target 计算出 TD error ， 然后使用 梯度下降 等方法更新模型来降低 TD error 的值。</p>
<p>4.回到1重复。</p>
<h2><span id="经验回放experience-replay">经验回放（Experience Replay）</span></h2><p>原始的时序差分学习在实际的应用中有两个缺点：</p>
<p>1.经验浪费<br> 从上面的流程可以看出，经验 (sr,at,rt,st+1) 在使用一次后就会被丢掉。但是事实上，这些经验可以重复利用的。这也是需要做经验回放的主要原因。</p>
<p>2.经验相关性太强<br> 前后相邻的经验的相关性太强了。比如对游戏来说，上一帧的画面和下一帧的画面变化很小。实验证明这种相关性是有害的，不利于模型的训练。</p>
<p>经验回放则可以有效的解决上面的两个缺点。</p>
<p>经验回放的原理就是只保留最近的 n 条经验，每次训练时 随机均匀的 从这些经验中 不重复的 选取一条或多条经验来训练。</p>
<p>n 的大小通常在十万到百万之间，视情况而定。这个值对训练影响较大。<br>经验回放现在是深度强化学习的标准技巧之一。</p>
<h2><span id="优先经验回放prioritized-experience-replay">优先经验回放（Prioritized Experience Replay）</span></h2><p>对经验回放改进有很多，其中一个常见的是优先经验回放。</p>
<p>优先经验回放的原理是 用非均匀抽样代替均匀抽样 来抽取经验。</p>
<h3><span id="31-经验的重要性不同">3.1 经验的重要性不同</span></h3><p>模型在和环境交互时，获得的经验的重要性是不同的。</p>
<p>比如：在一个打怪升级的游戏中，大多数经验都是和小兵战斗，只有很少的经验是和BOSS战斗。这样就容易导致训练出来的模型容易战胜小兵，但是很难打赢BOSS。所以和BOSS战斗的经验比和小兵战斗的经验更为重要。</p>
<h3><span id="32-经验的抽样概率">3.2 经验的抽样概率</span></h3><p>对于越不熟悉的状态，模型预测出的 TD error 的绝对值就会越大，所以可以根据 TD error 的绝对值的大小来判断一条经验的重要性。即 TD error 的绝对值越大越重要。</p>
<p>将 TD error 对应到抽样概率的方式有两种：</p>
<p>1.经验抽样的概率 pt 正比于 TD error δt 的绝对值加上一个很小的数 ϵ （避免概率为0）。</p>
<p>pt∝|δt|+ϵ</p>
<p>2.将所有经验的 TD error 的绝对值进行排序，大的靠前，小的靠后。 经验抽样的概率反比于排序后经验所处的位置。</p>
<p>pt∝1rank(t)</p>
<h3><span id="33-调整学习率">3.3 调整学习率</span></h3><p>因为抽样时是非均匀的，所以需要调整学习率来抵消不同抽样概率造成的偏差。</p>
<p>如果一条经验的抽样概率很大，那么它就会经常的被抽到用于更新模型，所以需要调小这条经验的学习率。反之亦然。</p>
<p>每条经验的学习率都需要乘以系数 (n⋅pt)−β，其中 n 是经验回放池中经验的总条数， pt 是每条经验的抽验概率， β 是一个超参数，值在0到1之间， β∈(0,1)。</p>
<p>对于均匀抽样来说，每条经验概率相同，p1=⋯=pn=1n ，学习率系数 (n⋅pt)−β 值的和为1。</p>
<p>对于非均匀抽样来说，抽样概率 pt 越大，学习率系数 (n⋅pt)−β 的值越小。论文中推荐开始时 β 值很小，后面逐步增长到1。</p>
<h3><span id="34-实现细节">3.4 实现细节</span></h3><p>需要将所有的经验 (sr,at,rt,st+1) 都计算出对应的 TD error。</p>
<p>对于刚刚收集到的经验，可以将其 TD error 的值设置为最大值。</p>
<p>每次使用经验后都需要更新对应的 TD error 。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>研究总体流程</title>
    <url>/2021/06/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E5%B1%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>研究目前基础物理模型已建立。<br>需要验证代码与建立运动方程式的正确性与一致性。<br>数值计算运用常微分方程与python程序plot所画图进行对比。</p>
<p>以下是当前所处状态的可视化流程图。</p>
<p><img src="/image/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0.png" alt="png"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>算法面试8-贪心算法</title>
    <url>/2021/05/15/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="贪心算法">贪心算法</span></h2><p>例题455</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
public:
    int findContentChildren(vector&lt;int&gt; &amp;g,vector&lt;int&gt; &amp;s)&#123;
        &#x2F;&#x2F; 从大到小的排序
        sort(g.begin(),g.end(),greater&lt;int&gt;());
        sort(s.begin(),s.end(),greater&lt;int&gt;());
        int si &#x3D; 0,gi &#x3D; 0;
        int res &#x3D; 0;
        while(gi &lt;g.size() &amp;&amp; si &lt;s.size())
        &#123;
            if(s[si] &gt;&#x3D; g[gi])&#123;
                res ++;
                si++;
                gi++;
            &#125;
            else
                gi++;
            &#x2F;&#x2F;满足不了最贪心的，寻找下一个次贪心的
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题 392<br>给定两个字符串s，t,问s是不是t的子序列</p>
<p>例题435<br>给定一组区间，问最少删除多少个区间，可以让这些区间互相不重叠<br>给定区间的七十点永远小于终止点<br>[1,2],[2,3]不算重叠</p>
<h3><span id="动态规划">动态规划</span></h3><pre class="line-numbers language-none"><code class="language-none">
class Solution&#123;

public:
    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt; &amp; intervals)&#123;
        if(intervals.size() &#x3D;&#x3D; 0)
            return 0;
        sort(intervals.begin(),intervals.end(),[](const vector &amp;a, const vector&lt;int&gt; &amp;b)&#123;
            return a[1] &lt; b[1];
            &#125;);
        &#x2F;&#x2F; memo[i] 表示使用intervals[0..i]的区间能构成的最长不重叠区间序列
        vector&lt;int&gt; memo(intervals.size(),1);
        for(int i &#x3D;1;i&lt;intervals.size();i++)   
            for(int j &#x3D; 0;j&lt;i;j++)
                if(intervals[i].start &gt;&#x3D; intervals[j].end)
                    memo[i] &#x3D; max(memo[i],1+memo[j]);
                    &#x2F;&#x2F;以索引[i]结尾的最长序列
        int res &#x3D; 0;
        for(int i &#x3D;0;i&lt;memo.size();i++)
            res &#x3D; max(res,memo[i]);
        return intervals.size() -res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="贪心算法">贪心算法：</span></h3><p>按照区间的结尾排序，每次选择结尾最早的，且和前一个区间不重叠的区间</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution&#123;

public:
    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt; &amp; intervals)&#123;
        if(intervals.size() &#x3D;&#x3D; 0)
            return 0;
        sort(intervals.begin(),intervals.end(),[](const vector&lt;int&gt; &amp;a ,const vector&lt;int&gt; &amp;b) 
        &#123; 
            return a[1] &lt; b[1];

        &#125;);
        &#x2F;&#x2F; 按照end 升序排序
        int res &#x3D;1;
        int pre &#x3D; 0;
        for(int i &#x3D;1;i&lt;intervals.size();i++)
                if(intervals[i].start &gt;&#x3D; intervals[pre].end)&#123;
                    res ++;
                    pre &#x3D; i;
                &#125;
        return intervals.size() - res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="贪心选择性质">贪心选择性质</span></h2><p>如果无法举出反例，如何证明贪心算法的正确性<br>反证法</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法面试</tag>
      </tags>
  </entry>
  <entry>
    <title>迷路问题方案优化</title>
    <url>/2021/02/21/%E8%BF%B7%E8%B7%AF%E9%97%AE%E9%A2%98%E6%96%B9%E6%A1%88%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>计算每个状态下 执行某一动作的概率<br>将最初的概率表更新<br>直到概率表的变化微乎其微时终止<br>从而得到最优路线<br>这里介绍以下softmax函数：<br>特征对概率的影响是乘性的<br>假设有一个数组V,Vi表示V中的第i个元素，那么这个元素的softmax数值为：<br>$$<br>S_{i}=\frac{e^{i}}{\sum_{j} e^{j}}<br>$$</p>
<p>价值迭代（马尔科夫决策过程）</p>
<p><img src="/image/%E5%85%AC%E5%BC%8F1.png" alt="png"></p>
<p>Q学习和sarsa学习的区别参考以上公式</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt
<span class="token operator">%</span>matplotlib inline<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
ax <span class="token operator">=</span> plt<span class="token punctuation">.</span>gca<span class="token punctuation">(</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>color <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">,</span>linewidth<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>color <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">,</span>linewidth<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>color <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">,</span>linewidth<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>color <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">,</span>linewidth<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>

plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">2.5</span><span class="token punctuation">,</span><span class="token string">'s0'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">1.5</span><span class="token punctuation">,</span><span class="token number">2.5</span><span class="token punctuation">,</span><span class="token string">'s1'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">2.5</span><span class="token punctuation">,</span><span class="token number">2.5</span><span class="token punctuation">,</span><span class="token string">'s2'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">1.5</span><span class="token punctuation">,</span><span class="token string">'s3'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">1.5</span><span class="token punctuation">,</span><span class="token number">1.5</span><span class="token punctuation">,</span><span class="token string">'s4'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">2.5</span><span class="token punctuation">,</span><span class="token number">1.5</span><span class="token punctuation">,</span><span class="token string">'s5'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token string">'s6'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">1.5</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token string">'s7'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">2.5</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token string">'s8'</span><span class="token punctuation">,</span>size <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">2.3</span><span class="token punctuation">,</span><span class="token string">'Start'</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">2.5</span><span class="token punctuation">,</span><span class="token number">0.3</span><span class="token punctuation">,</span><span class="token string">'goal'</span><span class="token punctuation">,</span>ha <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">)</span>

ax<span class="token punctuation">.</span>set_xlim<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
ax<span class="token punctuation">.</span>set_ylim<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>tick_params<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token string">'both'</span><span class="token punctuation">,</span>which<span class="token operator">=</span><span class="token string">'both'</span><span class="token punctuation">,</span>bottom<span class="token operator">=</span><span class="token string">'off'</span><span class="token punctuation">,</span>top<span class="token operator">=</span><span class="token string">'off'</span><span class="token punctuation">,</span>labelbottom<span class="token operator">=</span><span class="token string">'off'</span><span class="token punctuation">,</span>right<span class="token operator">=</span><span class="token string">'off'</span><span class="token punctuation">,</span>left<span class="token operator">=</span><span class="token string">'off'</span><span class="token punctuation">,</span>labelleft<span class="token operator">=</span><span class="token string">'off'</span><span class="token punctuation">)</span>

line<span class="token punctuation">,</span> <span class="token operator">=</span> ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>marker<span class="token operator">=</span><span class="token string">"o"</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">"g"</span><span class="token punctuation">,</span>markersize<span class="token operator">=</span><span class="token number">60</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/image/output_1_0.png" alt="png"></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">theta_0 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">softmax_convert_into_pi_from_theta</span><span class="token punctuation">(</span>theta<span class="token punctuation">)</span><span class="token punctuation">:</span>
    beta <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token comment">#beta为逆温度（日语） beta的数值越小则行动越random随机</span>
    <span class="token punctuation">[</span>m<span class="token punctuation">,</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> theta<span class="token punctuation">.</span>shape
    pi <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
    exp_theta <span class="token operator">=</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>beta  <span class="token operator">*</span> theta<span class="token punctuation">)</span>
    
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>
        pi<span class="token punctuation">[</span>i<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> exp_theta<span class="token punctuation">[</span>i<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">/</span>np<span class="token punctuation">.</span>nansum<span class="token punctuation">(</span>exp_theta<span class="token punctuation">[</span>i<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    pi <span class="token operator">=</span> np<span class="token punctuation">.</span>nan_to_num<span class="token punctuation">(</span>pi<span class="token punctuation">)</span>
    <span class="token keyword">return</span> pi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">pi_0 <span class="token operator">=</span> softmax_convert_into_pi_from_theta<span class="token punctuation">(</span>theta_0<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>pi_0<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>softmax函数计算中 np.nansum()中nan的数值忽略，不放入计算</p>
<pre><code>[[0.         0.5        0.5        0.        ]
 [0.         0.5        0.         0.5       ]
 [0.         0.         0.5        0.5       ]
 [0.33333333 0.33333333 0.33333333 0.        ]
 [0.         0.         0.5        0.5       ]
 [1.         0.         0.         0.        ]
 [1.         0.         0.         0.        ]
 [0.5        0.5        0.         0.        ]]
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_action_and_next_s</span><span class="token punctuation">(</span>pi<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
    direction <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"up"</span><span class="token punctuation">,</span><span class="token string">"right"</span><span class="token punctuation">,</span><span class="token string">"down"</span><span class="token punctuation">,</span><span class="token string">"left"</span><span class="token punctuation">]</span>
    next_direction <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>direction<span class="token punctuation">,</span>p <span class="token operator">=</span> pi<span class="token punctuation">[</span>s<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> next_direction <span class="token operator">==</span> <span class="token string">"up"</span><span class="token punctuation">:</span>
        action <span class="token operator">=</span> <span class="token number">0</span>
        s_next <span class="token operator">=</span> s<span class="token operator">-</span><span class="token number">3</span>
    <span class="token keyword">elif</span> next_direction <span class="token operator">==</span> <span class="token string">"right"</span><span class="token punctuation">:</span>
        action <span class="token operator">=</span> <span class="token number">1</span>
        s_next <span class="token operator">=</span> s<span class="token operator">+</span><span class="token number">1</span>
    <span class="token keyword">elif</span> next_direction <span class="token operator">==</span> <span class="token string">"down"</span><span class="token punctuation">:</span>
        action <span class="token operator">=</span> <span class="token number">2</span>
        s_next <span class="token operator">=</span> s<span class="token operator">+</span><span class="token number">3</span>
    <span class="token keyword">elif</span> next_direction <span class="token operator">==</span> <span class="token string">"left"</span><span class="token punctuation">:</span>
        action <span class="token operator">=</span> <span class="token number">3</span>
        s_next <span class="token operator">=</span> s<span class="token operator">-</span><span class="token number">1</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>action<span class="token punctuation">,</span>s_next<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">goal_maze_ret_s_a</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span class="token punctuation">:</span>
    s <span class="token operator">=</span> <span class="token number">0</span>
    s_a_history <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token punctuation">[</span>action<span class="token punctuation">,</span>next_s<span class="token punctuation">]</span> <span class="token operator">=</span> get_action_and_next_s<span class="token punctuation">(</span>pi<span class="token punctuation">,</span>s<span class="token punctuation">)</span>
        s_a_history<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> action
        <span class="token comment"># [-1]是表示最后一行</span>
        s_a_history<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>next_s<span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> next_s <span class="token operator">==</span> <span class="token number">8</span><span class="token punctuation">:</span>
            <span class="token keyword">break</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            s <span class="token operator">=</span> next_s
    <span class="token comment">#注意缩进</span>
    <span class="token keyword">return</span> s_a_history<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">s_a_history <span class="token operator">=</span> goal_maze_ret_s_a<span class="token punctuation">(</span>pi_0<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>s_a_history<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"迷路问题结局需要step："</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>s_a_history<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre><code>[[0, 2], [3, 2], [6, 0], [3, 0], [0, 1], 
[1, 3], [0, 1], [1, 1], [2, 3], [1, 1], 
[2, 3], [1, 1], [2, 2], [5, 0], [2, 3], 
[1, 3], [0, 1], [1, 3], [0, 1], [1, 1], 
[2, 3], [1, 3], [0, 2], [3, 1], [4, 2], 
[7, 1], [8, nan]]
迷路问题结局需要step：26
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">update_theta</span><span class="token punctuation">(</span>theta<span class="token punctuation">,</span>pi<span class="token punctuation">,</span>s_a_history<span class="token punctuation">)</span><span class="token punctuation">:</span>
    eta <span class="token operator">=</span> <span class="token number">0.1</span>
    T <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>s_a_history<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>
    <span class="token punctuation">[</span>m<span class="token punctuation">,</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> theta<span class="token punctuation">.</span>shape
    delta_theta <span class="token operator">=</span> theta<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token punctuation">(</span>np<span class="token punctuation">.</span>isnan<span class="token punctuation">(</span>theta<span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># i状态下的操作取出？ 数组SA[]括号里只有一个数字的时候代表行？</span>
                <span class="token comment"># 列表推导式 [表达式 for 变量 in 列表]</span>
                <span class="token comment"># [表达式 for 变量 in 列表 if 条件]</span>
                SA_i <span class="token operator">=</span> <span class="token punctuation">[</span>SA <span class="token keyword">for</span> SA <span class="token keyword">in</span> s_a_history <span class="token keyword">if</span> SA<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> i<span class="token punctuation">]</span>
                <span class="token comment"># i 状态下的动作j执行次数 是SA 不是SA[0]</span>
                SA_ij <span class="token operator">=</span> <span class="token punctuation">[</span>SA <span class="token keyword">for</span> SA <span class="token keyword">in</span> s_a_history <span class="token keyword">if</span> SA <span class="token operator">==</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span>
                N_i <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>SA_i<span class="token punctuation">)</span>
                N_ij <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>SA_ij<span class="token punctuation">)</span>
                delta_theta<span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>N_ij <span class="token operator">-</span> pi<span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token punctuation">]</span><span class="token operator">*</span>N_i<span class="token punctuation">)</span><span class="token operator">/</span>T

    new_theta <span class="token operator">=</span> theta <span class="token operator">+</span> eta <span class="token operator">*</span> delta_theta
    <span class="token keyword">return</span> new_theta
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">new_theta <span class="token operator">=</span> update_theta<span class="token punctuation">(</span>theta_0<span class="token punctuation">,</span> pi_0<span class="token punctuation">,</span> s_a_history<span class="token punctuation">)</span>
pi <span class="token operator">=</span> softmax_convert_into_pi_from_theta<span class="token punctuation">(</span>new_theta<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre><code>[[0.         0.50192307 0.49807693 0.        ]
 [0.         0.5        0.         0.5       ]
 [0.         0.         0.49711542 0.50288458]
 [0.33333333 0.33333333 0.33333333 0.        ]
 [0.         0.         0.50096154 0.49903846]
 [1.         0.         0.         0.        ]
 [1.         0.         0.         0.        ]
 [0.49903846 0.50096154 0.         0.        ]]
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">stop_epsilon <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">**</span><span class="token operator">-</span><span class="token number">4</span>
theta <span class="token operator">=</span> theta_0
pi <span class="token operator">=</span> pi_0
is_continue <span class="token operator">=</span> <span class="token boolean">True</span>
count <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">while</span> is_continue<span class="token punctuation">:</span>
    s_a_history <span class="token operator">=</span> goal_maze_ret_s_a<span class="token punctuation">(</span>pi<span class="token punctuation">)</span>
    new_theta <span class="token operator">=</span> update_theta<span class="token punctuation">(</span>theta<span class="token punctuation">,</span>pi<span class="token punctuation">,</span>s_a_history<span class="token punctuation">)</span>
    new_pi <span class="token operator">=</span> softmax_convert_into_pi_from_theta<span class="token punctuation">(</span>new_theta<span class="token punctuation">)</span>
    <span class="token comment"># 方策 pi的变化输出 np.abs 差值的绝对值</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span>new_pi <span class="token operator">-</span> pi<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"迷路问题解决需要step:"</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>s_a_history<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment"># 在这里当方案pi的变化非常小的时候 这里设定为小数点4位后终止</span>
    <span class="token keyword">if</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span>new_pi <span class="token operator">-</span> pi<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> stop_epsilon<span class="token punctuation">:</span>
        is_continue <span class="token operator">=</span> <span class="token boolean">False</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        theta <span class="token operator">=</span> new_theta
        pi <span class="token operator">=</span> new_pi
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  0.009063800389401577<br>  迷路问题解决需要step:38<br>  0.02818744894750541</p>
<p>   优化过程步进行运算次数很多这里省略<br>   .<br>   .<br>   .<br>   0.0004803718650859268<br>   迷路问题解决需要step:4<br>   0.00047881784079845113<br>   迷路问题解决需要step:4<br>   0.0004772712904493638<br>   迷路问题解决需要step:4<br>   0.0004757321664344491<br>   迷路问题解决需要step:4<br>   0.0022237054467947846<br>   迷路问题解决需要step:6<br>   0.00047977332401702433<br>   迷路问题解决需要step:4<br>   0.0004782214782191284<br>   迷路问题解决需要step:4<br>   0.0004766770960367636<br>   迷路问题解决需要step:4<br>   0.00047514012992791455<br>   迷路问题解决需要step:4<br>   0.0004736105327279652<br>   迷路问题解决需要step:4<br>   0.00047208825764356865<br>   迷路问题解决需要step:4<br>   0.0004705732582512903<br>   迷路问题解决需要step:4<br>   0.00046906548849294863<br>   迷路问题解决需要step:4<br>   0.0004675649026737866<br>   迷路问题解决需要step:4<br>   0.0004660714554580933<br>   迷路问题解决需要step:4<br>   0.0004645851018637709<br>   迷路问题解决需要step:4<br>   0.00046310579726372564<br>   迷路问题解决需要step:4<br>   0.00046163349737722917<br>   迷路问题解决需要step:4<br>   0.0022164095549151615<br>   迷路问题解决需要step:6<br>   0.002469026834838472<br>   迷路问题解决需要step:6<br>   0.0004725170614619835<br>   迷路问题解决需要step:4<br>   0.0004709960188524001<br>   迷路问题解决需要step:4</p>
<p>   .<br>   .<br>   .<br>   迷路问题解决需要step:4<br>   0.00010171860551497561<br>   迷路问题解决需要step:4<br>   0.00010156167609453107<br>   迷路问题解决需要step:4<br>   0.00010140511295706964<br>   迷路问题解决需要step:4<br>   0.0010352497734007326<br>   迷路问题解决需要step:6<br>   0.0001026577982205408<br>   .<br>   .<br>   .<br>   0.00010000526452905167<br>   迷路问题解决需要step:4<br>   9.985247147614555e-05<br>   迷路问题解决需要step:4里设定的终止值是在10**-4以下<br>途虽然已经找到最优路线4step，偶尔也会走其他路线6step</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 有效数字保留3位 不显示指数</span>
np<span class="token punctuation">.</span>set_printoptions<span class="token punctuation">(</span>precision <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>suppress <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre><code>[[0.    0.012 0.988 0.   ]
 [0.    0.31  0.    0.69 ]
 [0.    0.    0.403 0.597]
 [0.009 0.98  0.011 0.   ]
 [0.    0.    0.985 0.015]
 [1.    0.    0.    0.   ]
 [1.    0.    0.    0.   ]
 [0.018 0.982 0.    0.   ]]
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> animation
<span class="token keyword">from</span> IPython<span class="token punctuation">.</span>display <span class="token keyword">import</span> HTML  
<span class="token comment"># IPython这是是大写</span>
<span class="token keyword">def</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    line<span class="token punctuation">.</span>set_data<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  
    <span class="token keyword">return</span> <span class="token punctuation">(</span>line<span class="token punctuation">,</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">animate</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
    state <span class="token operator">=</span> s_a_history<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>state<span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">0.5</span><span class="token punctuation">)</span>
    y <span class="token operator">=</span> <span class="token number">2.5</span> <span class="token operator">-</span> <span class="token builtin">int</span><span class="token punctuation">(</span>state<span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span>
    line<span class="token punctuation">.</span>set_data<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>line<span class="token punctuation">,</span><span class="token punctuation">)</span>
anim <span class="token operator">=</span> animation<span class="token punctuation">.</span>FuncAnimation<span class="token punctuation">(</span>fig<span class="token punctuation">,</span>animate<span class="token punctuation">,</span>init_func <span class="token operator">=</span> init<span class="token punctuation">,</span>frames <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>s_a_history<span class="token punctuation">)</span><span class="token punctuation">,</span>interval <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">,</span>repeat <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span>
HTML<span class="token punctuation">(</span>anim<span class="token punctuation">.</span>to_jshtml<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/image/22.gif" alt="gif"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>算法面试6-递归和回溯</title>
    <url>/2021/04/27/%E9%80%92%E5%BD%92%E5%92%8C%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="递归和回溯">递归和回溯</span></h2><p>例题17：<br>给你一个数字的字符串，返回这个数字字符串能表示的所有字母组合<br>如对数字字符串“2，3”<br>{a,b,c} {d,e,f}<br>-字符串的合法性<br>-空字符串<br>-多个解的顺序</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
private:
    const string letterMap[10]&#x3D; &#123;
        &quot; &quot;, &#x2F;&#x2F;0
        &quot;&quot;, &#x2F;&#x2F;1
        &quot;abc&quot;, &#x2F;&#x2F;2
        &quot;def&quot;,&#x2F;&#x2F;3
        &quot;ghi&quot;,
        &quot;jkl&quot;,
        &quot;mno&quot;,
        &quot;pqrs&quot;,
        &quot;tuv&quot;,
        &quot;wxyz&quot;
    &#125;;
    vector &lt;string&gt; res;
    void findCombination(const string &amp;digits,int index,const string &amp;s)&#123;
        &#x2F;&#x2F;s中保存了此时从digits[0...index-1]翻译得到的一个字母字符串
        &#x2F;&#x2F;寻找和digits[index]匹配的字母，获得digits[0....index]翻译得到的解
        if(index&#x3D;&#x3D;digits.size())&#123;
            &#x2F;&#x2F;保存s
            res.push_back(s);
            return;
        &#125;
        char c &#x3D; digits[index];
        &#x2F;&#x2F;每次处理数字字符串中的一位，赋值给char c
        assert(c&gt;&#x3D;&#39;0&#39;&amp;&amp;c&lt;&#x3D;&#39;9&#39;&amp;&amp;c!&#x3D;&#39;1&#39;);
        string letters &#x3D; letterMap[c -&#39;0&#39;];
        &#x2F;&#x2F;为ASCII字符中的数字（‘123456’）想转换为纯数字（1,2,3,4...）就要减去48（ASCII单位），
        &#x2F;&#x2F;而‘0’的ASCII单位正好等于48。
        for(int i &#x3D; 0;i&lt;letters.size();i++)
            findCombination(digits,index+1,s+letters[i]);
        &#x2F;&#x2F;这里也是递归思想，假设数字为“3，2”，所对应for循环三次，下一次递归的“2”也对应for循环三次
        return;
&#125;
public:
    vector&lt;string&gt; letterCombinations(string digits)&#123;
        res.clear();
        if(digits &#x3D;&#x3D; &quot;&quot;)
            return res;
        findCombination(digits,0,&quot;&quot;);&#x2F;&#x2F;初始化
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题93<br>例题131</p>
<h2><span id="回溯算法的应用">回溯算法的应用</span></h2><p>例题46<br>给定一个整型数组。其中每一个元素都各不相同，返回这些元素所有排列的可能</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt;res;
    vector&lt;bool&gt; used;
    &#x2F;&#x2F;bool类型的数组使得每个index的元素只能使用一次
    void generatePermutation(const vector&lt;int&gt;nums,int index,vector &lt;int&gt; &amp;p)&#123;
        if(index &#x3D;&#x3D; nums.size())&#123;
            res.push_back(p);
            return;
        &#125;
        for(int i &#x3D;0;i&lt;nums.size();i++)
            if(!used[i])&#123;
                p.push_back(nums[i]);
                used[i] &#x3D; true;
                generatePermutation(nums,index+1,p);
                &#x2F;&#x2F;这里当num[i]作为排列组合的首位元素，所进行的全部组合完成时需要弹出这个元素，让这个元素之后也可以在排列组合的其他位置继续使用
                p.pop_back();
                used[i] &#x3D; false;
            &#125;
        return;
    &#125;
public:
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt; &amp;nums)&#123;
        res.clear();
        if(nums.size() &#x3D;&#x3D; 0)
            return res;
        vector&lt;int&gt;p;
        used &#x3D; vector&lt;bool&gt;(nums.size(),false);
        &#x2F;&#x2F;初始化使得nums.size()个数的元素都为false
        generatePermutation(nums,0,p);
        return res;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题47<br>例题77</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt;res;
    &#x2F;&#x2F;排列组合C(n,k) 
    void generateCombinations(int n,int k,int start,vector&lt;int&gt; &amp;c)&#123;
        if(c.size() &#x3D;&#x3D; k)&#123;
            res.push_back(c);
            return;
        &#125;
        for(int i &#x3D; start;i&lt;&#x3D;n;i++)&#123;
            c.push_back(i);
            generateCombinations(n,k,i+1,c);
            c.pop_back();

        &#125;
        return;
    &#125;
public:
    vector&lt;vector&lt;int&gt;&gt;combine(int n,int k)&#123;
        res.clear();
        if(n&lt;&#x3D;0||k&lt;&#x3D;0||k&gt;n)
            return res;
        vector&lt;int&gt; c;
        generateCombinations(n,k,1,c);
        return res;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="回溯法的剪支">回溯法的剪支</span></h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt;res;
    &#x2F;&#x2F;排列组合C(n,k) 
    void generateCombinations(int n,int k,int start,vector&lt;int&gt; &amp;c)&#123;
        if(c.size() &#x3D;&#x3D; k)&#123;
            res.push_back(c);
            return;
        &#125;

        for(int i &#x3D; start;i&lt;&#x3D;n-(k-c.size())+1;i++)&#123;
            c.push_back(i);
            generateCombinations(n,k,i+1,c);
            c.pop_back();

        &#125;
        return;
    &#125;
public:
    vector&lt;vector&lt;int&gt;&gt;combine(int n,int k)&#123;
        res.clear();
        if(n&lt;&#x3D;0||k&lt;&#x3D;0||k&gt;n)
            return res;
        vector&lt;int&gt; c;
        generateCombinations(n,k,1,c);
        return res;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题39：Combination Sum<br>例题40：Combination Sum II<br>例题216<br>例题78<br>例题401<br>例题79 Word Search</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
private:
    int d[4][2] &#x3D; &#123;&#123;-1,0&#125;,&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;&#125;;
    &#x2F;&#x2F;偏移数组 ，类似深度学习
    int m,n;
    vector&lt;vector&lt;bool&gt;&gt; visited;
    bool inArea(int x,int y)&#123;
        return x&gt;&#x3D;0 &amp;&amp; x&lt;m &amp;&amp; y&gt;&#x3D;0 &amp;&amp; y&lt;n;
    &#125;
    bool searchWord(const vector&lt;vector&lt;char&gt;&gt; &amp;board,const string &amp;word,int index,int startx,int starty)&#123;
        if(index &#x3D;&#x3D; word.size()-1) &#x2F;&#x2F;索引index到达要求的字符串末尾
            return board[startx][starty] &#x3D;&#x3D; word[index];
            &#x2F;&#x2F;直接去比较二维数组和word[index]
        if(board[startx][starty] &#x3D;&#x3D; word[index])&#123;
            visited[startx][starty] &#x3D; true;&#x2F;&#x2F;初始化为true
            &#x2F;&#x2F;从startx,starty出发，四个方向寻 找
            for(int i&#x3D;0;i&lt;4;i++)&#123;
                int newx  &#x3D; startx +d[i][0];
                int newy &#x3D; starty +d[i][1];
                if(inArea(newx,newy) &amp;&amp; !visited[newx][newy])
                    if(searchWord(board,word,index+1,newx,newy))
                        return true;
            &#125;
            &#x2F;&#x2F;回溯
            visited[startx][starty] &#x3D; false;
        &#125;
        return false;
    &#125;
public:

    bool exist(vector&lt;vector&lt;char&gt;&gt; &amp;board,string word)&#123;
        m &#x3D; board.size(); &#x2F;&#x2F;行
        assert(m&gt;0);
        n &#x3D; board[0].size(); &#x2F;&#x2F;列
        &#x2F;&#x2F; 初始化visited 制作一个m行n列的bool vector
        visited &#x3D; vector&lt;vector&lt;bool&gt;&gt;(m,vector&lt;bool&gt;(n,false));    
        for(int i &#x3D;0;i&lt;board.size();i++)
            for(int j&#x3D;0;j&lt;board[i].size();j++)
                if(searchWord(board,word,0,i,j)) &#x2F;&#x2F;bool函数有返回值，根据返回值 判断最终的true or False
                    return true;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="floodfill-算法">floodfill 算法</span></h3><p>例题200</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
private:
    int d[4][2] &#x3D; &#123;&#123;-1,0&#125;,&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;&#125;;
    &#x2F;&#x2F;偏移数组 ，类似深度学习
    int m,n;
    vector&lt;vector&lt;bool&gt;&gt; visited;
    bool inArea(int x,int y)&#123;
        return x&gt;&#x3D;0 &amp;&amp; x&lt;m &amp;&amp; y&gt;&#x3D;0 &amp;&amp; y&lt;n;
    &#125;
    &#x2F;&#x2F; 保证(x,y)合法 grid[x][y]时未访问的
    void dfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid,int x,int y)&#123;
        visited[x][y] &#x3D; true;
        for(int i &#x3D; 0;i&lt;4;i++)&#123;
            int newx &#x3D; x+d[i][0];
            int newy &#x3D; y+d[i][1];
            if(inArea(newx,newy) &amp;&amp; !visited[newx][newy]&amp;&amp; grid[newx][newy] &#x3D;&#x3D; &#39;1&#39;)
                dfs(grid,newx,newy);
        &#125;
        return;
    &#125;

public:

    int numIslands(vector&lt;vector&lt;char&gt;&gt; &amp;grid)&#123;
        m &#x3D; grid.size();
        if(m &#x3D;&#x3D; 0)
            return 0;
        n &#x3D; grid[0].size();
        visited &#x3D; vector&lt;vector&lt;bool&gt;&gt;(m,vector&lt;bool&gt;(n,false));
        int res &#x3D; 0;
        for(int i &#x3D; 0;i&lt;m;i++)
            for(int j &#x3D; 0;j&lt;n;j++)
                if(grid[i][j] &#x3D;&#x3D; &#39;1&#39; &amp;&amp; !visited[i][j])&#123;
                    res++;
                    &#x2F;&#x2F;找到一个陆地，假设这是一个独立的岛屿，然后根据dfs去将和它相连的陆地都标记为true。这样在寻找下一个岛屿的时候，这些标记为true的陆地不会被选择
                    dfs(grid,i,j);
                &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题130<br>例题417</p>
<h3><span id="回溯法是经典人工智能的基础">回溯法是经典人工智能的基础</span></h3><p>例题51 N-queens</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
private:
    vector&lt;bool&gt;col,dia1,dia2;
    &#x2F;&#x2F;去给定界定条件，列，对角线
    vector&lt;vector&lt;string&gt;&gt; res;
    void putQueen(int n,int index,vector&lt;int&gt; &amp;row)&#123;
        if(index &#x3D;&#x3D; n)&#123;
        res.push_back(generateBoard(n,row));
        return ;
    &#125;
        for(int i&#x3D;0;i&lt;n;i++)
        &#x2F;&#x2F;尝试将index行的皇后摆放在第i列
        &#x2F;&#x2F;如果满足皇后条件
            if(!col[i] &amp;&amp; !dia1[index+i] &amp;&amp; !dia2[index-i+n-1])&#123;
                row.push_back(i); 
                &#x2F;&#x2F;将每行的列位置推进row
                col[i] &#x3D; true;
                dia1[index+i] &#x3D; true;
                dia2[index-i+n-1] &#x3D; true;
                putQueen(n,index+1,row);
                &#x2F;*
                递进循环到某一个位置时如果寻找不到有效位置，则进行回溯，尝试将之前某index行的皇后换成其他位置摆放
                *&#x2F;
                col[i] &#x3D; false;
                dia1[index+i] &#x3D; false;
                dia2[index-i+n-1] &#x3D; false;
                row.pop_back();


            &#125;
            return;
    &#125;
    vector&lt;string&gt; generateBoard(int n,vector&lt;int&gt; &amp;row)&#123;
            assert(row.size() &#x3D;&#x3D; n);
            vector&lt;string&gt;board(n,string(n,&#39;.&#39;));
            for(int i &#x3D; 0;i&lt;n;i++)
                board[i][row[i]] &#x3D; &#39;Q&#39;;
                &#x2F;&#x2F;row[]是4个数字，对应四个列方向的索引，board[][]替换成Q
            return board;
    &#125;
public:
    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n)&#123;
        res.clear();
        col &#x3D; vector&lt;bool&gt;(n,false);
        dia1 &#x3D; vector&lt;bool&gt;(2*n-1,false); &#x2F;&#x2F;对角线个数2n-1
        dia2 &#x3D; vector&lt;bool&gt;(2*n-1,false);
        vector&lt;int&gt; row;
        putQueen(n,0,row);
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题52<br>例题37<br>求解数独</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法面试</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL第三部分</title>
    <url>/2021/02/06/MySQL%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1296271984&auto=1&height=66"></iframe>


<h2><span id="sql-的四种连接查询">SQL 的四种连接查询</span></h2><p>1.内连接<br>2.外连接<br>  -左连接<br>  -右连接<br>  -完全外连接</p>
<h2><span id="创建两个表格">创建两个表格</span></h2><h3><span id="peson表格">peson表格</span></h3><p>–person表</p>
<p>id,name,cardID<br>create table person(<br>id int,<br>name varchar(20),<br>cardID int);</p>
<h3><span id="card表格">card表格</span></h3><p>–card表<br>id ,name<br>create table card(<br>id int,<br>name varchar(20));</p>
<h2><span id="插入数据">插入数据</span></h2><h3><span id="card数据">card数据</span></h3><p>insert into card values(1,’饭卡’);<br>insert into card values(2,’建行卡’);<br>insert into card values(3,’农行卡’);<br>insert into card values(4,’工商卡’);<br>insert into card values(5,’邮政卡’);</p>
<h3><span id="person数据">person数据</span></h3><p>insert into person values(1,’张三’,1);<br>insert into person values(2,’李四’,3);<br>insert into person values(3,’王五’,6);</p>
<h2><span id="连接实战">“连接”实战</span></h2><p>select * from person;<br>+——+——–+——–+<br>| id   | name   | cardID |<br>+——+——–+——–+<br>|    1 | 张三   |      1 |<br>|    2 | 李四   |      3 |<br>|    3 | 王五   |      6 |<br>+——+——–+——–+</p>
<p>–并没有创建外键，</p>
<h3><span id="内连接">内连接</span></h3><p>inner join<br>内联查询，就是两张表中的数据通过某个字段相对，查询出相关记录数据<br>– inner join 查询</p>
<p>select * from person inner join card on person.cardId=card.id;<br>+——+——–+——–+——+———–+<br>| id   | name   | cardID | id   | name      |<br>+——+——–+——–+——+———–+<br>|    1 | 张三   |      1 |    1 | 饭卡      |<br>|    2 | 李四   |      3 |    3 | 农行卡    |<br>+——+——–+——–+——+———–+</p>
<h3><span id="外连接">外连接</span></h3><h4><span id="1左外连接">1.左外连接</span></h4><p>left join或者left outer join<br>select * from person left join card on person.cardId=card.id;</p>
<p>左外连接，会把左边表里面的所有数据取出来，而右边表中的数据，如果有相等的，就会显示出来<br>如果没有，就会补NULL</p>
<p>+——+——–+——–+——+———–+<br>| id   | name   | cardID | id   | name      |<br>+——+——–+——–+——+———–+<br>|    1 | 张三   |      1 |    1 | 饭卡      |<br>|    2 | 李四   |      3 |    3 | 农行卡    |<br>|    3 | 王五   |      6 | NULL | NULL      |<br>+——+——–+——–+——+———–+</p>
<h4><span id="2右外连接">2.右外连接</span></h4><p>right或者right outer join<br>select * from person right join card on person.cardId=card.id;<br>右外连接，会把右边表里面的所有数据取出来，而左边表中的数据，如果有相等的，就显示出来<br>如果没有，就会补NULL<br>select * from person right outer join card on person.cardId=card.id;</p>
<p>+——+——–+——–+——+———–+<br>| id   | name   | cardID | id   | name      |<br>+——+——–+——–+——+———–+<br>|    1 | 张三   |      1 |    1 | 饭卡      |<br>| NULL | NULL   |   NULL |    2 | 建行卡    |<br>|    2 | 李四   |      3 |    3 | 农行卡    |<br>| NULL | NULL   |   NULL |    4 | 工商卡    |<br>| NULL | NULL   |   NULL |    5 | 邮政卡    |<br>+——+——–+——–+——+———–+</p>
<h4><span id="2完全外连接">2.完全外连接</span></h4><p>full join或者full outer join<br>select * from person full join card on person.cardId=card.id;</p>
<p>mysql&gt; select * from person full join card on person.cardId=card.id;<br>ERROR 1054 (42S22): Unknown column ‘person.cardId’ in ‘on clause’</p>
<p>mysql不支持全外连接，原因不知，下节课再议<br>集合考虑：<br>全外连接=左连接union右连接<br>select * from person left join card on person.cardId=card.id<br>union<br>select * from person right join card on person.cardId=card.id;</p>
<p>+——+——–+——–+——+———–+<br>| id   | name   | cardID | id   | name      |<br>+——+——–+——–+——+———–+<br>|    1 | 张三   |      1 |    1 | 饭卡      |<br>|    2 | 李四   |      3 |    3 | 农行卡    |<br>|    3 | 王五   |      6 | NULL | NULL      |<br>| NULL | NULL   |   NULL |    2 | 建行卡    |<br>| NULL | NULL   |   NULL |    4 | 工商卡    |<br>| NULL | NULL   |   NULL |    5 | 邮政卡    |<br>+——+——–+——–+——+———–+</p>
<h2><span id="mysql事务">mysql事务</span></h2><p>mysql中，事务其实是一个最小的不可分割的工作单元。事务能够保证一个业务的完整性<br>比如我们的银行转账：<br>    a-&gt;100<br>    update user set money =money-100 where name=’a’<br>    b-&gt;<br>    update user set money=money+100 where name=’b’<br>–实际的程序中，如果只有一条语句执行成功了，而另外一条没有执行成功？<br>–出现数据前后不一致<br>     update user set money =money-100 where name=’a’<br>     update user set money=money+100 where name=’b’<br>–多条sql语句，可能会有同时成功的要求，要么就同时失败<br>–mysql如何控制事务</p>
<h3><span id="mysql默认是开启事务的自动提交">mysql默认是开启事务的(自动提交)</span></h3><p>mysql&gt; select @@autocommit;<br>+————–+<br>| @@autocommit |<br>+————–+<br>|            1 |<br>+————–+<br>–默认事务开启的作用是什么？<br>–当我们区执行sql语句的时候，效果就会立即体现出来，且不能回滚<br>create database bank;<br>create table user(<br>id int primary key,<br>name varchar(20),<br>money int);</p>
<p>insert into user values(1,’a’,1000);</p>
<p>–事务回滚：撤销sql语句</p>
<p>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |  1000 |<br>+—-+——+——-+<br>1 row in set (0.00 sec)</p>
<p>–设置自动提交为false</p>
<p>set @@autocommit=0</p>
<p>mysql&gt; select @@autocommit;<br>+————–+<br>| @@autocommit |<br>+————–+<br>|            0 |<br>+————–+</p>
<p>–上面的操作关闭了mysql的自动提交（commit)<br>insert into user values(2,’b’,1000);</p>
<p>mysql&gt; insert into user values(2,’b’,1000);<br>Query OK, 1 row affected (0.00 sec)</p>
<p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+—-+——+——-+<br>2 rows in set (0.00 sec)</p>
<p>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |  1000 |<br>+—-+——+——-+<br>1 row in set (0.00 sec)</p>
<p>–再一次插入数据<br>mysql&gt; insert into user values(2,’b’,1000);<br>Query OK, 1 row affected (0.00 sec)<br>–手动提交数据<br>mysql&gt; commit;<br>Query OK, 0 rows affected (0.01 sec)</p>
<p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+—-+——+——-+<br>2 rows in set (0.01 sec)<br>–再撤销，是不可以撤销的（持久性）</p>
<p>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+—-+——+——-+<br>2 rows in set (0.00 sec)</p>
<p>–自动提交？<br>@@autocommit=1<br>–手动提交？<br>commit;<br>–事务回滚？<br>rollback;<br>–如果说这个时候转账</p>
<h3><span id="转账实际操作">转账实际操作</span></h3><p>如果要执行成功撤销操作 需要@@autocommit=0</p>
<p>mysql&gt; set @@autocommit=0;<br>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; select @@autocommit;<br>+————–+<br>| @@autocommit |<br>+————–+<br>|            0 |<br>+————–+</p>
<p>update user set money =money+100 where name=’a’;<br>update user set money=money-100 where name=’b’;</p>
<p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |  1100 |<br>|  2 | b    |   900 |<br>+—-+——+——-+<br>2 rows in set (0.00 sec)</p>
<p>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.01 sec)</p>
<p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+—-+——+——-+</p>
<p>–事务给我们提供了一个反悔的机会</p>
<p>begin;<br>–或者<br>start transaction;<br>–都可以帮我们手动开启一个事务</p>
<h4><span id="手动开启事务1">手动开启事务1</span></h4><p>begin;<br>update user set money =money+100 where name=’a’;<br>update user set money=money-100 where name=’b’;</p>
<p>mysql&gt; update user set money=money-100 where name=’b’;<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0</p>
<p>mysql&gt; update user set money =money+100 where name=’a’;<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0</p>
<p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |  1200 |<br>|  2 | b    |   800 |<br>+—-+——+——-+<br>2 rows in set (0.00 sec)</p>
<p>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.01 sec)</p>
<p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |  1100 |<br>|  2 | b    |   900 |<br>+—-+——+——-+</p>
<p>####手动开启事务2<br>start transaction<br>update user set money =money+100 where name=’a’;<br>update user set money=money-100 where name=’b’;</p>
<p>与上述同理<br>begin<br>start transaction<br>这两条命令相当于小开关手动开启事务<br>@@autocommit属于总开关</p>
<h3><span id="事务的四大特性">事务的四大特性</span></h3><p>A 原子性：事务是最小的单位，不可以再分割<br>B 一致性：事务要求，同一事务中的sql语句u，必须保证同时成功或者同时失败<br>C 隔离性：事务1和事务2 之间具有隔离性<br>D 持久性：事务一旦结束（commit，rollback），就不可以返回</p>
<p>事务开启：<br>1.修改默认提交 set @@autocommit=0;<br>2.begin<br>3.start transaction</p>
<p>事务手动提交：<br>commit;</p>
<p>事务手动回滚：<br>rollback;</p>
<h3><span id="事务的隔离性">事务的隔离性</span></h3><p>1.read uncommitted;—读未提交的<br>2.read committed;—读已经提交的<br>3.repeatable read;—可以重复读<br>4.serializable;—-串行化</p>
<h4><span id="1-read-uncommitted">1-read uncommitted</span></h4><p>如果存在事务a和事务b<br>a 事务对数据进行操作，在操作过程中，事务没有被提交，但b可以看见a</p>
<p>bank数据库user表<br>insert into user values(3,’小明’,1000);<br>insert into user values(4,’淘宝店’,1000);</p>
<p>mysql&gt; select * from user;<br>+—-+———–+——-+<br>| id | name      | money |<br>+—-+———–+——-+<br>|  1 | a         |  1100 |<br>|  2 | b         |   900 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>+—-+———–+——-+</p>
<p>–如何查看数据库的隔离级别<br>–系统级别<br> select @@global.transaction_isolation;<br>–会话级别<br>select @@transaction_isolation;</p>
<p>//查看数据库隔离级别需要退回到最初的databases</p>
<p>mysql&gt; select @@global.transaction_isolation;<br>+——————————–+<br>| @@global.transaction_isolation |<br>+——————————–+<br>| REPEATABLE-READ                |<br>+——————————–+<br>–如何修改隔离级别<br>set global transaction isolation level read uncommitted;</p>
<p>mysql&gt; select @@global.transaction_isolation;<br>+——————————–+<br>| @@global.transaction_isolation |<br>+——————————–+<br>| READ-UNCOMMITTED               |<br>+——————————–+</p>
<p>–转账： 小明在淘宝店买鞋子：800块<br>小明-》成都<br>淘宝点-》广州<br>start transaction;<br>update user set money=money-800 where name=’小明’;<br>update user set money=money+800 where name=’淘宝店’;</p>
<p>mysql&gt; select * from user;<br>+—-+———–+——-+<br>| id | name      | money |<br>+—-+———–+——-+<br>|  1 | a         |  1100 |<br>|  2 | b         |   900 |<br>|  3 | 小明      |   200 |<br>|  4 | 淘宝店    |  1800 |<br>+—-+———–+——-+<br>–给淘宝店打电话，说你去查一下是不是到账了<br>–淘宝店在广州查账</p>
<p>mysql&gt; select * from user;<br>+—-+———–+——-+<br>| id | name      | money |<br>+—-+———–+——-+<br>|  1 | a         |  1100 |<br>|  2 | b         |   900 |<br>|  3 | 小明      |   200 |<br>|  4 | 淘宝店    |  1800 |<br>+—-+———–+——-+</p>
<p>–发货<br>–晚上请女朋友吃好吃的（呸！）<br>–1800</p>
<p>–小明-》成都</p>
<p>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; select * from user;<br>+—-+———–+——-+<br>| id | name      | money |<br>+—-+———–+——-+<br>|  1 | a         |  1100 |<br>|  2 | b         |   900 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>+—-+———–+——-+</p>
<p>–结帐的时候发现钱不够</p>
<p>mysql&gt; select * from user;<br>+—-+———–+——-+<br>| id | name      | money |<br>+—-+———–+——-+<br>|  1 | a         |  1100 |<br>|  2 | b         |   900 |<br>|  3 | 小明      |   200 |<br>|  4 | 淘宝店    |  1800 |<br>+—-+———–+——-+</p>
<p>–如果两个不同的地方都在进行操作，如果事务a开启以后，他的数据可以被其他事务读取到<br>–这样就会出现“脏读”<br>–脏读：一个事务读到另外一个事务没有提交的数据，就叫做脏读<br>–实际开发是不允许脏读出现的</p>
<h4><span id="2read-committed-读已经提交的">2.read committed; 读已经提交的</span></h4><p>set global transaction isolation level read committed;</p>
<p>bank 数据库 user表<br>小张：银行的会计<br>start transaction;<br>select * from user;</p>
<p>+—-+———–+——-+<br>| id | name      | money |<br>+—-+———–+——-+<br>|  1 | a         |  1100 |<br>|  2 | b         |   900 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>+—-+———–+——-+<br>小张出去了。</p>
<p>小王：<br>start transaction;<br>insert into user values(5,’c’,100);</p>
<p>–小张回来了<br>select avg(money) from user;</p>
<p>mysql&gt; select avg(money) from user;<br>+————+<br>| avg(money) |<br>+————+<br>|   820.0000 |<br>+————+</p>
<p>–money的平均值不是1000，变少了？<br>–虽然我只能读到另一个事务提交的数据，但还是会出现问题，就是<br>–读取同一个表中的数据，发现前后不一致<br>–不可重复读现象：read committed</p>
<h4><span id="3repeatable-read">3.repeatable read</span></h4><p>可以重复读，数据库默认也是这个<br>set global transaction isolation level repeatable read;</p>
<p>–在repeatable-read隔离级别下会出现什么问题<br>select * from user;<br>mysql&gt; select * from user;<br>+—-+———–+——-+<br>| id | name      | money |<br>+—-+———–+——-+<br>|  1 | a         |  1100 |<br>|  2 | b         |   900 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>|  5 | c         |   100 |<br>+—-+———–+——-+</p>
<p>–张全蛋-成都</p>
<p>start transaction;</p>
<p>–王尼玛-北京</p>
<p>start transaction;</p>
<p>–张全蛋-成都<br>insert into user values(6,’d’,1000);</p>
<p>mysql&gt; select * from user;<br>+—-+———–+——-+<br>| id | name      | money |<br>+—-+———–+——-+<br>|  1 | a         |  1100 |<br>|  2 | b         |   900 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>|  5 | c         |   100 |<br>|  6 | d         |  1000 |<br>+—-+———–+——-+</p>
<p>–王尼玛-北京<br>insert into user values(6,’d’,1000);</p>
<p>mysql&gt; select * from user;<br>+—-+———–+——-+<br>| id | name      | money |<br>+—-+———–+——-+<br>|  1 | a         |  1100 |<br>|  2 | b         |   900 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>|  5 | c         |   100 |<br>+—-+———–+——-+<br>mysql&gt; insert into user values(6,’d’,1000);<br>ERROR 1062 (23000): Duplicate entry ‘6’ for key ‘user.PRIMARY’</p>
<p>–这种现象叫做幻读<br>–事务a和事务b同时操作一张表，事务a提交的数据，也不能被事务b读到<br>意思就是两人操作同一个表格的时候，操作的数据并不会实时更新，所以王尼玛当时看不到d的数据，<br>如果重新查看可以查看到。在不知道d的数据已经被插入的情况下再次插入d的数据就会出现错误!</p>
<h4><span id="4serializable-read">4.serializable read</span></h4><p>//<br>这个示例如果想实际操作演示的话，需要同时开启两个终端窗口<br>然后进行视频中的操作<br>//</p>
<p>串行化<br>set global transaction isolation level serializable;<br>修改成功</p>
<p>mysql&gt; select @@global.transaction_isolation;<br>+——————————–+<br>| @@global.transaction_isolation |<br>+——————————–+<br>| SERIALIZABLE                   |<br>+——————————–+</p>
<p>mysql&gt; select * from user;<br>+—-+———–+——-+<br>| id | name      | money |<br>+—-+———–+——-+<br>|  1 | a         |  1100 |<br>|  2 | b         |   900 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>|  5 | c         |   100 |<br>|  6 | d         |  1000 |<br>+—-+———–+——-+</p>
<p>–小张-成都<br>start transaction;</p>
<p>insert into user values(7,’小赵’,1000);<br>mysql&gt; select * from user;<br>+—-+———–+——-+<br>| id | name      | money |<br>+—-+———–+——-+<br>|  1 | a         |  1100 |<br>|  2 | b         |   900 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>|  5 | c         |   100 |<br>|  6 | d         |  1000 |<br>|  7 | 小赵      |  1000 |<br>+—-+———–+——-+</p>
<p>–小王-北京</p>
<p>–小王查询信息发现小赵的信息已经存在<br>mysql&gt; select * from user;<br>+—-+———–+——-+<br>| id | name      | money |<br>+—-+———–+——-+<br>|  1 | a         |  1100 |<br>|  2 | b         |   900 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>|  5 | c         |   100 |<br>|  6 | d         |  1000 |<br>|  7 | 小赵      |  1000 |<br>+—-+———–+——-+</p>
<p>–小张<br>start transaction;<br>insert into user values(8,’小王’,1000);</p>
<p>–sql语句卡住？<br>这个时候小张进行操作想要输入新的数据发现卡住<br>–当user表被另外一个事务操作的时候，其他事务写操作，是不可以被进行的<br>（银行效率低的原因发现！！）<br>–进入排队状态（串行化），指导小王那边的事务结束之后（commit）之后<br>小张的写入操作才会执行<br>–在没有等待超时的情况下。</p>
<p>小王：<br>mysql&gt; commit;<br>Query OK, 0 rows affected (0.00 sec)</p>
<p>小张：<br>Query OK, 1 row affected (25.70 sec)</p>
<p>mysql&gt;<br>mysql&gt;<br>mysql&gt;<br>mysql&gt;<br>mysql&gt; </p>
<p>–串行化问题是，性能特差<br>read—committed&gt;read committed&gt;repeatable read&gt;serializable;<br>–隔离级别越高，性能越查<br>mysql语句默认隔离级别是repeatable</p>
<hr>
<p>完结散花！！！<br>小希同学加油！<br>正好一周<br>2021.2.7</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>DQN</title>
    <url>/2021/03/26/DQN/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt
<span class="token operator">%</span>matplotlib inline
<span class="token keyword">import</span> gym
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> JSAnimation<span class="token punctuation">.</span>IPython_display <span class="token keyword">import</span> display_animation
<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> animation
<span class="token keyword">from</span> IPython<span class="token punctuation">.</span>display <span class="token keyword">import</span> display

<span class="token keyword">def</span> <span class="token function">display_frames_as_gif</span><span class="token punctuation">(</span>frames<span class="token punctuation">)</span><span class="token punctuation">:</span>

    plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize <span class="token operator">=</span> <span class="token punctuation">(</span>frames<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">72.0</span><span class="token punctuation">,</span>frames<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">72.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dpi <span class="token operator">=</span> <span class="token number">72</span><span class="token punctuation">)</span>
    patch <span class="token operator">=</span> plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>frames<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    plt<span class="token punctuation">.</span>axis<span class="token punctuation">(</span><span class="token string">'off'</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">animate</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
    patch<span class="token punctuation">.</span>set_data<span class="token punctuation">(</span>frame<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    anmi <span class="token operator">=</span> animation<span class="token punctuation">.</span>FuncAnimation<span class="token punctuation">(</span>plt<span class="token punctuation">.</span>gcf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>animate<span class="token punctuation">,</span>frames <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>frames<span class="token punctuation">)</span><span class="token punctuation">,</span>interval <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">)</span>
    anim<span class="token punctuation">.</span>save <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'movie_cartpole_DQN.mp4'</span><span class="token punctuation">)</span>
    display<span class="token punctuation">(</span>display_animation<span class="token punctuation">(</span>anmi<span class="token punctuation">,</span>default_mode <span class="token operator">=</span> <span class="token string">'loop'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> namedtuple
Tr <span class="token operator">=</span> namedtuple<span class="token punctuation">(</span><span class="token string">'tr'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'name_a'</span><span class="token punctuation">,</span><span class="token string">'value_b'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Tr_object <span class="token operator">=</span> Tr<span class="token punctuation">(</span><span class="token string">'名称'</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>Tr_object<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>Tr_object<span class="token punctuation">.</span>value_b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>tr(name_a=&#39;名称&#39;, value_b=100)
100
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># namedtupleを生成</span>
<span class="token keyword">from</span> collections <span class="token keyword">import</span> namedtuple
Transition <span class="token operator">=</span> namedtuple<span class="token punctuation">(</span>
    <span class="token string">'Transition'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'state'</span><span class="token punctuation">,</span> <span class="token string">'action'</span><span class="token punctuation">,</span> <span class="token string">'next_state'</span><span class="token punctuation">,</span> <span class="token string">'reward'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

ENV <span class="token operator">=</span> <span class="token string">'CartPole-v0'</span>
GAMMA <span class="token operator">=</span> <span class="token number">0.99</span>
MAX_STEPS <span class="token operator">=</span> <span class="token number">200</span>
NUM_EPISODES <span class="token operator">=</span> <span class="token number">500</span>

<span class="token comment"># 保存经验的内存定义</span>

<span class="token keyword">class</span> <span class="token class-name">ReplayMemory</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>CAPACITY<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>capacity <span class="token operator">=</span> CAPACITY
        self<span class="token punctuation">.</span>memory <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">#保存经验的变量</span>
        self<span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment">#保存的index展示变量</span>
    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>state<span class="token punctuation">,</span>action<span class="token punctuation">,</span>state_next<span class="token punctuation">,</span>reward<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>memory<span class="token punctuation">)</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>capacity<span class="token punctuation">:</span>    <span class="token comment">#确保内存没有超过容量</span>
            self<span class="token punctuation">.</span>memory<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>memory<span class="token punctuation">[</span>self<span class="token punctuation">.</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> Transition<span class="token punctuation">(</span>state<span class="token punctuation">,</span>action<span class="token punctuation">,</span>state_next<span class="token punctuation">,</span>reward<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span> self<span class="token punctuation">.</span>capacity  <span class="token comment">#这里index的值向后移动一位 +1</span>
    <span class="token keyword">def</span> <span class="token function">sample</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>self<span class="token punctuation">.</span>memory<span class="token punctuation">,</span>batch_size<span class="token punctuation">)</span> <span class="token comment">#随机取出一定数量的数据</span>
    <span class="token keyword">def</span> <span class="token function">__len__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>memory<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> random 
<span class="token keyword">import</span> torch
<span class="token keyword">from</span> torch <span class="token keyword">import</span> nn
<span class="token keyword">from</span> torch <span class="token keyword">import</span> optim
<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>functional <span class="token keyword">as</span> F

BATCH_SIZE <span class="token operator">=</span> <span class="token number">32</span>
CAPACITY <span class="token operator">=</span> <span class="token number">10000</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Brain</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>num_states<span class="token punctuation">,</span>num_actions<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>num_actions <span class="token operator">=</span> num_actions <span class="token comment">#取得cartpole的行动</span>

        self<span class="token punctuation">.</span>memory <span class="token operator">=</span> ReplayMemory<span class="token punctuation">(</span>CAPACITY<span class="token punctuation">)</span> 
        <span class="token comment"># 构建神经网络</span>
        self<span class="token punctuation">.</span>model <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>model<span class="token punctuation">.</span>add_module<span class="token punctuation">(</span><span class="token string">'fc1'</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>num_states<span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#nn.Linear ?</span>
        self<span class="token punctuation">.</span>model<span class="token punctuation">.</span>add_module<span class="token punctuation">(</span><span class="token string">'relu1'</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>model<span class="token punctuation">.</span>add_module<span class="token punctuation">(</span><span class="token string">'fc2'</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>model<span class="token punctuation">.</span>add_module<span class="token punctuation">(</span><span class="token string">'relu2'</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>model<span class="token punctuation">.</span>add_module<span class="token punctuation">(</span><span class="token string">'fc3'</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span>num_actions<span class="token punctuation">)</span><span class="token punctuation">)</span>

        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>model<span class="token punctuation">)</span>

        self<span class="token punctuation">.</span>optimizer <span class="token operator">=</span> optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>self<span class="token punctuation">.</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>lr <span class="token operator">=</span> <span class="token number">0.0001</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">replay</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>

        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>memory<span class="token punctuation">)</span> <span class="token operator">&lt;</span> BATCH_SIZE<span class="token punctuation">:</span>
            <span class="token keyword">return</span> 

        transitions <span class="token operator">=</span> self<span class="token punctuation">.</span>memory<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>BATCH_SIZE<span class="token punctuation">)</span>

        batch <span class="token operator">=</span> Transition<span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">zip</span><span class="token punctuation">(</span><span class="token operator">*</span>transitions<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#?</span>
        <span class="token comment">#C=torch.cat((A,B),0)就表示按维数0（行）拼接A和B，也就是竖着拼接，A上B下。此时需要注意：列数必须一致，即维数1数值要相同，这里都是3列，方能列对齐。拼接后的C的第0维是两个维数0数值和，即2+4=6.</span>
        <span class="token comment">#C=torch.cat((A,B),1)就表示按维数1（列）拼接A和B，也就是横着拼接，A左B右。此时需要注意：行数必须一致，即维数0数值要相同，这里都是2行，方能行对齐。拼接后的C的第1维是两个维数1数值和，即3+4=7.</span>
        state_batch <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span>batch<span class="token punctuation">.</span>state<span class="token punctuation">)</span>
        action_batch <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span>batch<span class="token punctuation">.</span>action<span class="token punctuation">)</span>
        reward_batch <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span>batch<span class="token punctuation">.</span>reward<span class="token punctuation">)</span>
        non_final_next_states <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>s <span class="token keyword">for</span> s <span class="token keyword">in</span> batch<span class="token punctuation">.</span>next_state <span class="token keyword">if</span> s <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

        self<span class="token punctuation">.</span>model<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#推理模式</span>
        state_action_values <span class="token operator">=</span> self<span class="token punctuation">.</span>model<span class="token punctuation">(</span>state_batch<span class="token punctuation">)</span><span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>action_batch<span class="token punctuation">)</span>
        <span class="token comment"># 检查next_state 是否存在</span>
        non_final_mask <span class="token operator">=</span> torch<span class="token punctuation">.</span>ByteTensor<span class="token punctuation">(</span><span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> s<span class="token punctuation">:</span> s <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">,</span>batch<span class="token punctuation">.</span>next_state<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

        next_state_values <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>BATCH_SIZE<span class="token punctuation">)</span>
        <span class="token comment">#torch.tensor.detach()用法介绍：</span>
        <span class="token comment">#返回一个新的从当前图中分离的Variable。</span>
        <span class="token comment">#返回的 Variable 不会梯度更新。</span>
        <span class="token comment">#被detach 的Variable volatile=True， detach出来的volatile也为True。</span>
        <span class="token comment">#返回的Variable和被detach的Variable指向同一个tensor。</span>
        next_state_values<span class="token punctuation">[</span>non_final_mask<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>model<span class="token punctuation">(</span>non_final_next_states<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#？</span>
        <span class="token comment"># Q学习</span>
        expected_state_action_values <span class="token operator">=</span> reward_batch <span class="token operator">+</span> GAMMA<span class="token operator">*</span>next_state_values
        self<span class="token punctuation">.</span>model<span class="token punctuation">.</span>train<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">#损失函数计算</span>
        
        <span class="token comment">#返回一个新的张量，对输入的指定位置插入维度 1</span>

        <span class="token comment">#注意： 返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。</span>

        <span class="token comment">#如果dim为负，则将会被转化dim+input.dim()+1dim+input.dim()+1</span>
        
        <span class="token comment">#tensor (Tensor) – 输入张量</span>
        <span class="token comment">#dim (int) – 插入维度的索引（从0开始）</span>
        <span class="token comment">#out (Tensor, optional) – 结果张量</span>

        <span class="token comment">#import torch</span>
        <span class="token comment">#x = torch.ones(4)</span>
        <span class="token comment">#print(x)</span>
        <span class="token comment">#print(x.size())</span>

        <span class="token comment">#y = torch.unsqueeze(x, 0)</span>
        <span class="token comment">#print(y)</span>
        <span class="token comment">#print(y.size())</span>
        <span class="token comment">#z = torch.unsqueeze(x, 1)</span>
        <span class="token comment">#print(z)</span>
        <span class="token comment">#print(z.size())</span>
        <span class="token comment">#插入维度之前：</span>
        <span class="token comment">#[ 1, 1, 1, 1 ]</span>

        <span class="token comment">#在第0维插入一个维度，使其变成（1，4），即在最外层插入一个中括号即可：</span>

        <span class="token comment">#[ [ 1, 1, 1, 1 ] ]</span>

        <span class="token comment">#在第1维插入一个维度，使其变成（4，1）</span>

        <span class="token comment">#[ [1], [1], [1], [1] ]</span>
        loss <span class="token operator">=</span> F<span class="token punctuation">.</span>smooth_l1_loss<span class="token punctuation">(</span>state_action_values<span class="token punctuation">,</span>expected_state_action_values<span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">#[minibatch*1]</span>

        <span class="token comment">#更新結合パラメータ</span>
        self<span class="token punctuation">.</span>optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 重置梯度</span>
        loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#反向传播计算</span>
        self<span class="token punctuation">.</span>optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#更新parameter</span>

    <span class="token keyword">def</span> <span class="token function">decide_action</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>state<span class="token punctuation">,</span>episode<span class="token punctuation">)</span><span class="token punctuation">:</span>
        epsilon <span class="token operator">=</span> <span class="token number">0.5</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token punctuation">(</span>episode <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

        <span class="token keyword">if</span> epsilon <span class="token operator">&lt;=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>model<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                action <span class="token operator">=</span> self<span class="token punctuation">.</span>model<span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
                <span class="token comment">#torch.max()[0]， 只返回最大值的每个数</span>
                <span class="token comment">#troch.max()[1]， 只返回最大值的每个索引</span>
                <span class="token comment">#torch.max()[1].data 只返回variable中的数据部分（去掉Variable containing:）</span>
                <span class="token comment">#torch.max()[1].data.numpy() 把数据转化成numpy ndarry</span>
                <span class="token comment">#torch.max()[1].data.numpy().squeeze() 把数据条目中维度为1 的删除掉</span>

                <span class="token comment">#view(1,1)</span>
                <span class="token comment">#在函数的参数中经常可以看到-1例如x.view(-1, 4)</span>
                <span class="token comment">#这里-1表示一个不确定的数，就是你如果不确定你想要reshape成几行，但是你很肯定要reshape成4列，那不确定的地方就可以写成-1</span>
                <span class="token comment">#例如一个长度的16向量x，</span>
                <span class="token comment">#x.view(-1, 4)等价于x.view(4, 4)</span>
                <span class="token comment">#x.view(-1, 2)等价于x.view(8，2)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            action <span class="token operator">=</span> torch<span class="token punctuation">.</span>LongTensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>random<span class="token punctuation">.</span>randrange<span class="token punctuation">(</span>self<span class="token punctuation">.</span>num_actions<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

        <span class="token keyword">return</span> action<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Agent</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>num_states<span class="token punctuation">,</span>num_actions<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>brain <span class="token operator">=</span> Brain<span class="token punctuation">(</span>num_states<span class="token punctuation">,</span>num_actions<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">update_q_function</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>brain<span class="token punctuation">.</span>replay<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#这里Brain()赋值给self.brain，所以可以调用replay()?</span>

    <span class="token keyword">def</span> <span class="token function">get_action</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>state<span class="token punctuation">,</span>episode<span class="token punctuation">)</span><span class="token punctuation">:</span>
        action <span class="token operator">=</span> self<span class="token punctuation">.</span>brain<span class="token punctuation">.</span>decide_action<span class="token punctuation">(</span>state<span class="token punctuation">,</span>episode<span class="token punctuation">)</span>
        <span class="token keyword">return</span> action
    <span class="token keyword">def</span> <span class="token function">memorize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>state<span class="token punctuation">,</span>action<span class="token punctuation">,</span>state_next<span class="token punctuation">,</span>reward<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>brain<span class="token punctuation">.</span>memory<span class="token punctuation">.</span>push<span class="token punctuation">(</span>state<span class="token punctuation">,</span>action<span class="token punctuation">,</span>state_next<span class="token punctuation">,</span>reward<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Environment</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>env <span class="token operator">=</span> gym<span class="token punctuation">.</span>make<span class="token punctuation">(</span>ENV<span class="token punctuation">)</span>
        <span class="token comment">#初始化设定状态和行动的个数</span>
        num_states <span class="token operator">=</span> self<span class="token punctuation">.</span>env<span class="token punctuation">.</span>observation_space<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> 
        num_actions <span class="token operator">=</span> self<span class="token punctuation">.</span>env<span class="token punctuation">.</span>action_space<span class="token punctuation">.</span>n
        <span class="token comment">#生成环境内行动的Agent</span>
        self<span class="token punctuation">.</span>agent <span class="token operator">=</span> Agent<span class="token punctuation">(</span>num_states<span class="token punctuation">,</span>num_actions<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        episode_10_list <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
        complete_episodes <span class="token operator">=</span> <span class="token number">0</span>
        episode_final <span class="token operator">=</span> <span class="token boolean">False</span>
        frames <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> episode <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>NUM_EPISODES<span class="token punctuation">)</span><span class="token punctuation">:</span>
            observation <span class="token operator">=</span> self<span class="token punctuation">.</span>env<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#环境初始化</span>
            state <span class="token operator">=</span> observation <span class="token comment">#初始化的环境直接当作状态s使用</span>
            <span class="token comment">#起初state是numpy类型 这里通过torch.from_numpy().type转换成向量型</span>
            state <span class="token operator">=</span> torch<span class="token punctuation">.</span>from_numpy<span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">(</span>
                torch<span class="token punctuation">.</span>FloatTensor<span class="token punctuation">)</span>
            <span class="token comment">#print(state)</span>
            <span class="token comment">#FloatTensorof size 4 ->1*4？</span>
            state <span class="token operator">=</span> torch<span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span>state<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token comment">#print(state)</span>

            <span class="token keyword">for</span> step <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>MAX_STEPS<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> episode_final <span class="token keyword">is</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
                    frames<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>env<span class="token punctuation">.</span>render<span class="token punctuation">(</span>mode <span class="token operator">=</span> <span class="token string">'rgb_array'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token comment"># 这步所求的action预测 是在agent中进行</span>
                action <span class="token operator">=</span> self<span class="token punctuation">.</span>agent<span class="token punctuation">.</span>get_action<span class="token punctuation">(</span>state<span class="token punctuation">,</span>episode<span class="token punctuation">)</span>
                <span class="token comment">#这里不使用reward和info所以 _</span>
                observation_next<span class="token punctuation">,</span>_<span class="token punctuation">,</span>done<span class="token punctuation">,</span>_ <span class="token operator">=</span> self<span class="token punctuation">.</span>env<span class="token punctuation">.</span>step<span class="token punctuation">(</span>action<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#env源代码？</span>
                <span class="token keyword">if</span> done<span class="token punctuation">:</span>
                    state_next <span class="token operator">=</span> <span class="token boolean">None</span>
                    episode_10_list <span class="token operator">=</span> np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>episode_10_list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>step<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#?这里是寻找</span>
                    <span class="token comment">#沿着水平方向将数组堆叠起来</span>
                    <span class="token comment">#arr1 = np.array([[1, 2], [3, 4], [5, 6]])</span>
                    <span class="token comment">#arr2 = np.array([[7, 8], [9, 0], [0, 1]])</span>
                    <span class="token comment">#[[1 2 7 8]</span>
                     <span class="token comment">#[3 4 9 0]</span>
                     <span class="token comment">#[5 6 0 1]]</span>

                    <span class="token keyword">if</span> step <span class="token operator">&lt;</span> <span class="token number">195</span><span class="token punctuation">:</span>
                        reward <span class="token operator">=</span> torch<span class="token punctuation">.</span>FloatTensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> 
                        complete_episodes <span class="token operator">=</span> <span class="token number">0</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        reward <span class="token operator">=</span> torch<span class="token punctuation">.</span>FloatTensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                        complete_episodes <span class="token operator">=</span> complete_episodes <span class="token operator">+</span><span class="token number">1</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    reward <span class="token operator">=</span> torch<span class="token punctuation">.</span>FloatTensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                    state_next <span class="token operator">=</span>observation_next
                    state_next <span class="token operator">=</span> torch<span class="token punctuation">.</span>from_numpy<span class="token punctuation">(</span>state_next<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>FloatTensor<span class="token punctuation">)</span>
                    state_next <span class="token operator">=</span> torch<span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span>state_next<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>

                <span class="token comment">#给内存增加经验</span>
                self<span class="token punctuation">.</span>agent<span class="token punctuation">.</span>memorize<span class="token punctuation">(</span>state<span class="token punctuation">,</span>action<span class="token punctuation">,</span>state_next<span class="token punctuation">,</span>reward<span class="token punctuation">)</span>
                <span class="token comment">#通过replay()更新Q函数</span>
                self<span class="token punctuation">.</span>agent<span class="token punctuation">.</span>update_q_function<span class="token punctuation">(</span><span class="token punctuation">)</span>
                state <span class="token operator">=</span> state_next
                <span class="token keyword">if</span> done<span class="token punctuation">:</span>
                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%d Episode: Finished after %d steps: 10次试行的平均step数 = %.1lf'</span> <span class="token operator">%</span><span class="token punctuation">(</span>episode<span class="token punctuation">,</span>step<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>episode_10_list<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">break</span>
            <span class="token keyword">if</span> episode_final <span class="token keyword">is</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
                display_frames_as_gif<span class="token punctuation">(</span>frames<span class="token punctuation">)</span>
                <span class="token keyword">break</span>
            <span class="token keyword">if</span> complete_episodes <span class="token operator">>=</span> <span class="token number">10</span><span class="token punctuation">:</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'连续成功10次'</span><span class="token punctuation">)</span>
                episode_final <span class="token operator">=</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">cartpole_env <span class="token operator">=</span> Environment<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre><code>Sequential(
  (fc1): Linear(in_features=4, out_features=32, bias=True)
  (relu1): ReLU()
  (fc2): Linear(in_features=32, out_features=32, bias=True)
  (relu2): ReLU()
  (fc3): Linear(in_features=32, out_features=2, bias=True)
)
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">cartpole_env<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">0 Episode: Finished after 10 steps: 10次试行的平均step数 &#x3D; 1.0
1 Episode: Finished after 13 steps: 10次试行的平均step数 &#x3D; 2.3
2 Episode: Finished after 9 steps: 10次试行的平均step数 &#x3D; 3.2
3 Episode: Finished after 10 steps: 10次试行的平均step数 &#x3D; 4.2
4 Episode: Finished after 9 steps: 10次试行的平均step数 &#x3D; 5.1
5 Episode: Finished after 9 steps: 10次试行的平均step数 &#x3D; 6.0
6 Episode: Finished after 10 steps: 10次试行的平均step数 &#x3D; 7.0
7 Episode: Finished after 9 steps: 10次试行的平均step数 &#x3D; 7.9
8 Episode: Finished after 9 steps: 10次试行的平均step数 &#x3D; 8.8
9 Episode: Finished after 10 steps: 10次试行的平均step数 &#x3D; 9.8
10 Episode: Finished after 12 steps: 10次试行的平均step数 &#x3D; 10.0
11 Episode: Finished after 11 steps: 10次试行的平均step数 &#x3D; 9.8
12 Episode: Finished after 13 steps: 10次试行的平均step数 &#x3D; 10.2
13 Episode: Finished after 10 steps: 10次试行的平均step数 &#x3D; 10.2
14 Episode: Finished after 10 steps: 10次试行的平均step数 &#x3D; 10.3
15 Episode: Finished after 10 steps: 10次试行的平均step数 &#x3D; 10.4
16 Episode: Finished after 15 steps: 10次试行的平均step数 &#x3D; 10.9
17 Episode: Finished after 16 steps: 10次试行的平均step数 &#x3D; 11.6
18 Episode: Finished after 22 steps: 10次试行的平均step数 &#x3D; 12.9
19 Episode: Finished after 21 steps: 10次试行的平均step数 &#x3D; 14.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre><code>&lt;ipython-input-6-55bc7a6f3a6f&gt;:43: UserWarning: indexing with dtype torch.uint8 is now deprecated, 
please use a dtype torch.bool instead. 
(Triggered internally at  ..\aten\src\ATen/native/IndexingUtils.h:30.)
  next_state_values[non_final_mask] = self.model(non_final_next_states).max(1)[0].detach() #？
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">20 Episode: Finished after 23 steps: 10次试行的平均step数 &#x3D; 15.1
21 Episode: Finished after 36 steps: 10次试行的平均step数 &#x3D; 17.6
22 Episode: Finished after 28 steps: 10次试行的平均step数 &#x3D; 19.1
23 Episode: Finished after 35 steps: 10次试行的平均step数 &#x3D; 21.6
24 Episode: Finished after 23 steps: 10次试行的平均step数 &#x3D; 22.9
25 Episode: Finished after 39 steps: 10次试行的平均step数 &#x3D; 25.8
26 Episode: Finished after 29 steps: 10次试行的平均step数 &#x3D; 27.2
27 Episode: Finished after 29 steps: 10次试行的平均step数 &#x3D; 28.5
28 Episode: Finished after 24 steps: 10次试行的平均step数 &#x3D; 28.7
29 Episode: Finished after 80 steps: 10次试行的平均step数 &#x3D; 34.6
30 Episode: Finished after 26 steps: 10次试行的平均step数 &#x3D; 34.9
31 Episode: Finished after 25 steps: 10次试行的平均step数 &#x3D; 33.8
32 Episode: Finished after 32 steps: 10次试行的平均step数 &#x3D; 34.2
33 Episode: Finished after 25 steps: 10次试行的平均step数 &#x3D; 33.2
34 Episode: Finished after 31 steps: 10次试行的平均step数 &#x3D; 34.0
35 Episode: Finished after 34 steps: 10次试行的平均step数 &#x3D; 33.5
36 Episode: Finished after 45 steps: 10次试行的平均step数 &#x3D; 35.1
37 Episode: Finished after 40 steps: 10次试行的平均step数 &#x3D; 36.2
38 Episode: Finished after 50 steps: 10次试行的平均step数 &#x3D; 38.8
39 Episode: Finished after 11 steps: 10次试行的平均step数 &#x3D; 31.9
40 Episode: Finished after 56 steps: 10次试行的平均step数 &#x3D; 34.9
41 Episode: Finished after 23 steps: 10次试行的平均step数 &#x3D; 34.7
42 Episode: Finished after 16 steps: 10次试行的平均step数 &#x3D; 33.1
43 Episode: Finished after 19 steps: 10次试行的平均step数 &#x3D; 32.5
44 Episode: Finished after 12 steps: 10次试行的平均step数 &#x3D; 30.6
45 Episode: Finished after 29 steps: 10次试行的平均step数 &#x3D; 30.1
46 Episode: Finished after 13 steps: 10次试行的平均step数 &#x3D; 26.9
47 Episode: Finished after 20 steps: 10次试行的平均step数 &#x3D; 24.9
48 Episode: Finished after 14 steps: 10次试行的平均step数 &#x3D; 21.3
49 Episode: Finished after 14 steps: 10次试行的平均step数 &#x3D; 21.6
50 Episode: Finished after 11 steps: 10次试行的平均step数 &#x3D; 17.1
51 Episode: Finished after 13 steps: 10次试行的平均step数 &#x3D; 16.1
52 Episode: Finished after 14 steps: 10次试行的平均step数 &#x3D; 15.9
53 Episode: Finished after 31 steps: 10次试行的平均step数 &#x3D; 17.1
54 Episode: Finished after 19 steps: 10次试行的平均step数 &#x3D; 17.8
55 Episode: Finished after 29 steps: 10次试行的平均step数 &#x3D; 17.8
56 Episode: Finished after 33 steps: 10次试行的平均step数 &#x3D; 19.8
57 Episode: Finished after 58 steps: 10次试行的平均step数 &#x3D; 23.6
58 Episode: Finished after 40 steps: 10次试行的平均step数 &#x3D; 26.2
59 Episode: Finished after 38 steps: 10次试行的平均step数 &#x3D; 28.6
60 Episode: Finished after 36 steps: 10次试行的平均step数 &#x3D; 31.1
61 Episode: Finished after 47 steps: 10次试行的平均step数 &#x3D; 34.5
62 Episode: Finished after 52 steps: 10次试行的平均step数 &#x3D; 38.3
63 Episode: Finished after 36 steps: 10次试行的平均step数 &#x3D; 38.8
64 Episode: Finished after 31 steps: 10次试行的平均step数 &#x3D; 40.0
65 Episode: Finished after 76 steps: 10次试行的平均step数 &#x3D; 44.7
66 Episode: Finished after 40 steps: 10次试行的平均step数 &#x3D; 45.4
67 Episode: Finished after 24 steps: 10次试行的平均step数 &#x3D; 42.0
68 Episode: Finished after 51 steps: 10次试行的平均step数 &#x3D; 43.1
69 Episode: Finished after 53 steps: 10次试行的平均step数 &#x3D; 44.6
70 Episode: Finished after 34 steps: 10次试行的平均step数 &#x3D; 44.4
71 Episode: Finished after 31 steps: 10次试行的平均step数 &#x3D; 42.8
72 Episode: Finished after 34 steps: 10次试行的平均step数 &#x3D; 41.0
73 Episode: Finished after 51 steps: 10次试行的平均step数 &#x3D; 42.5
74 Episode: Finished after 46 steps: 10次试行的平均step数 &#x3D; 44.0
75 Episode: Finished after 42 steps: 10次试行的平均step数 &#x3D; 40.6
76 Episode: Finished after 50 steps: 10次试行的平均step数 &#x3D; 41.6
77 Episode: Finished after 32 steps: 10次试行的平均step数 &#x3D; 42.4
78 Episode: Finished after 37 steps: 10次试行的平均step数 &#x3D; 41.0
79 Episode: Finished after 45 steps: 10次试行的平均step数 &#x3D; 40.2
80 Episode: Finished after 67 steps: 10次试行的平均step数 &#x3D; 43.5
81 Episode: Finished after 41 steps: 10次试行的平均step数 &#x3D; 44.5
82 Episode: Finished after 57 steps: 10次试行的平均step数 &#x3D; 46.8
83 Episode: Finished after 77 steps: 10次试行的平均step数 &#x3D; 49.4
84 Episode: Finished after 39 steps: 10次试行的平均step数 &#x3D; 48.7
85 Episode: Finished after 51 steps: 10次试行的平均step数 &#x3D; 49.6
86 Episode: Finished after 61 steps: 10次试行的平均step数 &#x3D; 50.7
87 Episode: Finished after 81 steps: 10次试行的平均step数 &#x3D; 55.6
88 Episode: Finished after 63 steps: 10次试行的平均step数 &#x3D; 58.2
89 Episode: Finished after 84 steps: 10次试行的平均step数 &#x3D; 62.1
90 Episode: Finished after 200 steps: 10次试行的平均step数 &#x3D; 75.4
91 Episode: Finished after 58 steps: 10次试行的平均step数 &#x3D; 77.1
92 Episode: Finished after 57 steps: 10次试行的平均step数 &#x3D; 77.1
93 Episode: Finished after 53 steps: 10次试行的平均step数 &#x3D; 74.7
94 Episode: Finished after 109 steps: 10次试行的平均step数 &#x3D; 81.7
95 Episode: Finished after 82 steps: 10次试行的平均step数 &#x3D; 84.8
96 Episode: Finished after 61 steps: 10次试行的平均step数 &#x3D; 84.8
97 Episode: Finished after 50 steps: 10次试行的平均step数 &#x3D; 81.7
98 Episode: Finished after 156 steps: 10次试行的平均step数 &#x3D; 91.0
99 Episode: Finished after 162 steps: 10次试行的平均step数 &#x3D; 98.8
100 Episode: Finished after 200 steps: 10次试行的平均step数 &#x3D; 98.8
101 Episode: Finished after 92 steps: 10次试行的平均step数 &#x3D; 102.2
102 Episode: Finished after 90 steps: 10次试行的平均step数 &#x3D; 105.5
103 Episode: Finished after 130 steps: 10次试行的平均step数 &#x3D; 113.2
104 Episode: Finished after 147 steps: 10次试行的平均step数 &#x3D; 117.0
105 Episode: Finished after 119 steps: 10次试行的平均step数 &#x3D; 120.7
106 Episode: Finished after 186 steps: 10次试行的平均step数 &#x3D; 133.2
107 Episode: Finished after 200 steps: 10次试行的平均step数 &#x3D; 148.2
108 Episode: Finished after 110 steps: 10次试行的平均step数 &#x3D; 143.6
109 Episode: Finished after 111 steps: 10次试行的平均step数 &#x3D; 138.5
110 Episode: Finished after 159 steps: 10次试行的平均step数 &#x3D; 134.4
111 Episode: Finished after 200 steps: 10次试行的平均step数 &#x3D; 145.2
112 Episode: Finished after 200 steps: 10次试行的平均step数 &#x3D; 156.2
113 Episode: Finished after 200 steps: 10次试行的平均step数 &#x3D; 163.2
114 Episode: Finished after 200 steps: 10次试行的平均step数 &#x3D; 168.5
115 Episode: Finished after 200 steps: 10次试行的平均step数 &#x3D; 176.6
116 Episode: Finished after 200 steps: 10次试行的平均step数 &#x3D; 178.0
117 Episode: Finished after 200 steps: 10次试行的平均step数 &#x3D; 178.0
118 Episode: Finished after 200 steps: 10次试行的平均step数 &#x3D; 187.0
119 Episode: Finished after 200 steps: 10次试行的平均step数 &#x3D; 195.9
120 Episode: Finished after 200 steps: 10次试行的平均step数 &#x3D; 200.0
连续成功10次
121 Episode: Finished after 200 steps: 10次试行的平均step数 &#x3D; 200.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p><img src="/image/output_9_3.png" alt="png"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL第二部分</title>
    <url>/2021/02/01/mysql%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1352427635&auto=1&height=66"></iframe>

<h2><span id="查询练习">查询练习</span></h2><h3><span id="-23-查询95033班和95031班全体学生的记录">-23 查询95033班和95031班全体学生的记录</span></h3><p>//<br>在这里where添加条件限制<br>在条件为多个的时候用 in<br>单个条件可以用 =<br>//<br>mysql&gt; select * from student where class in(‘95031’,’95033’);</p>
<p>+———–+—–+—–+————+——-+<br>| sname     | no  | sex | birthday   | class |<br>+———–+—–+—–+————+——-+<br>| 曾华      | 101 | 男  | 1977-09-01 | 95033 |<br>| 匡明      | 102 | 男  | 1975-10-02 | 95031 |<br>| 王丽      | 103 | 女  | 1976-01-23 | 95033 |<br>| 李军      | 104 | 男  | 1976-02-20 | 95033 |<br>| 王芳      | 105 | 女  | 1975-02-10 | 95031 |<br>| 陆军      | 106 | 男  | 1974-06-03 | 95031 |<br>| 王尼玛    | 107 | 男  | 1976-02-20 | 95033 |<br>| 张全蛋    | 108 | 男  | 1975-02-10 | 95031 |<br>| 赵铁柱    | 109 | 男  | 1974-06-03 | 95031 |<br>+———–+—–+—–+————+——-+</p>
<h3><span id="-24查询存在85分以上成绩的课程c_no">-24.查询存在85分以上成绩的课程c_no</span></h3><p>依然是练习where条件语句<br>mysql&gt; select c_no,degree from score where degree &gt;85;<br>+——-+——–+<br>| c_no  | degree |<br>+——-+——–+<br>| 3-105 |     90 |<br>| 3-105 |     92 |<br>| 3-245 |     86 |<br>| 3-105 |     89 |<br>| 3-105 |     88 |<br>+——-+——–+</p>
<h3><span id="-25查询出计算机系教师所教课程的成绩表">-25.查询出“计算机系”教师所教课程的成绩表</span></h3><p>select * from  teacher where department=’计算机系’；<br>+—–+——–+—–+————+————+————–+<br>| no  | name   | sex | birthday   | profession | department   |<br>+—–+——–+—–+————+————+————–+<br>| 804 | 李诚   | 男  | 1958-12-02 | 副教授     | 计算机系     |<br>| 825 | 王萍   | 女  | 1972-05-05 | 助教       | 计算机系     |<br>+—–+——–+—–+————+————+————–+</p>
<p>select * from course where t_no in(select no from teacher where department=’计算机系’)；<br>+——-+—————–+——+<br>| no    | name            | t_no |<br>+——-+—————–+——+<br>| 3-245 | 操作系统        | 804  |<br>| 3-105 | 计算机导论      | 825  |<br>+——-+—————–+——+</p>
<p>//这里要注意多层套娃条件的时候，结尾处的括号个数一定要与前面的一致，要不会出错的</p>
<p>select * from score where c_no in(select no from course where t_no in(select no from teacher where department=’计算机系’));</p>
<p>+——+——-+——–+<br>| s_no | c_no  | degree |<br>+——+——-+——–+<br>| 103  | 3-245 |     86 |<br>| 105  | 3-245 |     75 |<br>| 109  | 3-245 |     68 |<br>| 101  | 3-105 |     90 |<br>| 102  | 3-105 |     81 |<br>| 103  | 3-105 |     92 |<br>| 104  | 3-105 |     89 |<br>| 105  | 3-105 |     88 |<br>| 109  | 3-105 |     76 |<br>+——+——-+——–+</p>
<h3><span id="-26查询计算机系与电子工程系不同职称的教师的名字-name">-26.查询“计算机系”与“电子工程系”不同职称的教师的名字 name</span></h3><p>–union联合查询<br>–not in </p>
<p>为了方便理解这里先查看以下教师表格</p>
<p>mysql&gt; select * from teacher;<br>+—–+——–+—–+————+————+—————–+<br>| no  | name   | sex | birthday   | profession | department      |<br>+—–+——–+—–+————+————+—————–+<br>| 804 | 李诚   | 男  | 1958-12-02 | 副教授     | 计算机系        |<br>| 825 | 王萍   | 女  | 1972-05-05 | 助教       | 计算机系        |<br>| 831 | 刘冰   | 女  | 1977-08-14 | 助教       | 电子工程系      |<br>| 856 | 张旭   | 男  | 1969-03-12 | 讲师       | 电子工程系      |<br>+—–+——–+—–+————+————+—————–+<br>——问题是要查找什么再简单一点说明——<br>找到计算机系和电子工程系中 职称不重复的教师名字<br>用集合的概念去想</p>
<p>这里计算机系和电子工程系 重合部分是助教，计算机系非助教的集合+电子工程系非助教的集合</p>
<p>select * from teacher where department =’计算机系’ and profession not in(select<br> profession from teacher where department=’电子工程系’);<br>+—–+——–+—–+————+————+————–+<br>| no  | name   | sex | birthday   | profession | department   |<br>+—–+——–+—–+————+————+————–+<br>| 804 | 李诚   | 男  | 1958-12-02 | 副教授     | 计算机系     |<br>+—–+——–+—–+————+————+————–+<br>select * from teacher where department =’电子工程系’ and profession not in(select<br> profession from teacher where department=’计算机系’);<br> +—–+——–+—–+————+————+—————–+<br>| no  | name   | sex | birthday   | profession | department      |<br>+—–+——–+—–+————+————+—————–+<br>| 856 | 张旭   | 男  | 1969-03-12 | 讲师       | 电子工程系      |<br>+—–+——–+—–+————+————+—————–+</p>
<p>两个语句通过union语句联合起来，代表同时满足两个条件<br>//分号代表语句结束 只能末尾有哦</p>
<p>select * from teacher where department =’计算机系’ and profession not in(select<br> profession from teacher where department=’电子工程系’)<br> union<br> select * from teacher where department =’电子工程系’ and profession not in(select<br> profession from teacher where department=’计算机系’);</p>
<p>+—–+——–+—–+————+————+—————–+<br>| no  | name   | sex | birthday   | profession | department      |<br>+—–+——–+—–+————+————+—————–+<br>| 804 | 李诚   | 男  | 1958-12-02 | 副教授     | 计算机系        |<br>| 856 | 张旭   | 男  | 1969-03-12 | 讲师       | 电子工程系      |<br>+—–+——–+—–+————+————+—————–+</p>
<h3><span id="-27查询选修编号为3-105课程且成绩至少高于选修编号3-245的同学的c_nos_no和degree并且按照degree从高到低次序排列">-27.查询选修编号为“3-105”课程且成绩至少高于选修编号“3-245”的同学的c_no，s_no和degree，并且按照degree从高到低次序排列</span></h3><p>/问题理解/<br>至少高于?—&gt;大于其中至少一个，any<br>选修“3-105”课程的同学，只要成绩高于选修“3-245”同学中的至少一名同学的成绩，这个数据就被选择</p>
<p>select * from score where c_no=’3-105’ and degree&gt;any(select degree from score where c_no=’3-245’);</p>
<p>+——+——-+——–+<br>| s_no | c_no  | degree |<br>+——+——-+——–+<br>| 101  | 3-105 |     90 |<br>| 102  | 3-105 |     81 |<br>| 103  | 3-105 |     92 |<br>| 104  | 3-105 |     89 |<br>| 105  | 3-105 |     88 |<br>| 109  | 3-105 |     76 |<br>+——+——-+——–+</p>
<p>//紧接着进行排序<br>select * from score where c_no=’3-105’ and degree&gt;any(select degree from score where c_no=’3-245’) order by degree desc;<br>+——+——-+——–+<br>| s_no | c_no  | degree |<br>+——+——-+——–+<br>| 103  | 3-105 |     92 |<br>| 101  | 3-105 |     90 |<br>| 104  | 3-105 |     89 |<br>| 105  | 3-105 |     88 |<br>| 102  | 3-105 |     81 |<br>| 109  | 3-105 |     76 |<br>+——+——-+——–+</p>
<h3><span id="-28查询选修编号为3-105课程且成绩至少高于选修编号3-245的同学的c_nos_no和degree">-28.查询选修编号为“3-105”课程且成绩至少高于选修编号“3-245”的同学的c_no，s_no和degree</span></h3><p>–且？ all表示所有的关系</p>
<p>select * from score where c_no=’3-105’ and degree&gt;all(select degree from score where c_no=’3-245’);</p>
<p>+——+——-+——–+<br>| s_no | c_no  | degree |<br>+——+——-+——–+<br>| 101  | 3-105 |     90 |<br>| 103  | 3-105 |     92 |<br>| 104  | 3-105 |     89 |<br>| 105  | 3-105 |     88 |<br>+——+——-+——–+</p>
<h3><span id="-29查询所有教师和同学的namesexbirthday">-29.查询所有教师和同学的name，sex，birthday</span></h3><p>//<br>先看数据 在我进行操作之后name和sname都变成了name<br>因为所有数据名称都是按查找的第一组数据的命名来算的<br>//<br>select name ,sex,birthday from teacher<br>union<br>select sname ,sex,birthday from student;<br>+———–+—–+————+<br>| name      | sex | birthday   |<br>+———–+—–+————+<br>| 李诚      | 男  | 1958-12-02 |<br>| 王萍      | 女  | 1972-05-05 |<br>| 刘冰      | 女  | 1977-08-14 |<br>| 张旭      | 男  | 1969-03-12 |<br>| 曾华      | 男  | 1977-09-01 |<br>| 匡明      | 男  | 1975-10-02 |<br>| 王丽      | 女  | 1976-01-23 |<br>| 李军      | 男  | 1976-02-20 |<br>| 王芳      | 女  | 1975-02-10 |<br>| 陆军      | 男  | 1974-06-03 |<br>| 王尼玛    | 男  | 1976-02-20 |<br>| 张全蛋    | 男  | 1975-02-10 |<br>| 赵铁柱    | 男  | 1974-06-03 |<br>| 张飞      | 男  | 1974-06-03 |<br>+———–+—–+————+</p>
<p>//为了看效果这里将两个查询互换位置//<br>select sname as trueename,sex,birthday from student<br>union<br>select name,sex,birthday from teacher;</p>
<p>+———–+—–+————+<br>| trueename | sex | birthday   |<br>+———–+—–+————+<br>| 曾华      | 男  | 1977-09-01 |<br>| 匡明      | 男  | 1975-10-02 |<br>| 王丽      | 女  | 1976-01-23 |<br>| 李军      | 男  | 1976-02-20 |<br>| 王芳      | 女  | 1975-02-10 |<br>| 陆军      | 男  | 1974-06-03 |<br>| 王尼玛    | 男  | 1976-02-20 |<br>| 张全蛋    | 男  | 1975-02-10 |<br>| 赵铁柱    | 男  | 1974-06-03 |<br>| 张飞      | 男  | 1974-06-03 |<br>| 李诚      | 男  | 1958-12-02 |<br>| 王萍      | 女  | 1972-05-05 |<br>| 刘冰      | 女  | 1977-08-14 |<br>| 张旭      | 男  | 1969-03-12 |<br>+———–+—–+————+</p>
<h3><span id="-30查询所有女教师和女同学的namesexbirthday">-30.查询所有女教师和女同学的name，sex，birthday</span></h3><p>同理上一道题，到后面视频是越来越短。。。。就是加了一个where条件<br>我最开始输入的信息都是name,sex,birthday 其实不需要改变，这里换个大写<br>select name as Name,sex as Sex,birthday as Birthday from teacher where sex=’女’<br>union<br>select sname,sex,birthday from student where sex=’女’;</p>
<p>+——–+—–+————+<br>| Name   | Sex | Birthday   |<br>+——–+—–+————+<br>| 王萍   | 女  | 1972-05-05 |<br>| 刘冰   | 女  | 1977-08-14 |<br>| 王丽   | 女  | 1976-01-23 |<br>| 王芳   | 女  | 1975-02-10 |<br>+——–+—–+————+</p>
<h3><span id="-31查询成绩比该课程平均成绩低的同学的成绩表">-31.查询成绩比该课程平均成绩低的同学的成绩表</span></h3><p>各门课程的平均成绩</p>
<p>mysql&gt; select avg(degree) from score group by c_no;<br>+————-+<br>| avg(degree) |<br>+————-+<br>|     86.0000 |<br>|     76.3333 |<br>|     81.6667 |<br>+————-+</p>
<p>这里为了找出低于平均分的成绩，将表格中的每一个数据都和平均成绩进行比较<br>//？？？为什么不用和之前一样的方法 where条件语句+group by 分类比较呢？？？//<br>验证一下</p>
<p>mysql&gt; select * from score  where degree&lt;(select avg(degree) from score a group<br>by c_no);<br>ERROR 1242 (21000): Subquery returns more than 1 row<br>这里erro的意思大概是 子查询返回多行<br>我也没看定义，就可以理解成课程平均成绩有多个，这里寻找低于平均值数据的时候，是要在同一门课程比较的<br>用group by无法知道应该谁和谁比较</p>
<hr>
<p>正确操作<br>//score a 和score b都是指向score表，数据相同 。不信的话动手实践<br>select * from score a;<br>select * from score b;<br>去看结果相同不？<br>这里用where a.c_no=b.c_no去相同课程一一对应比较//<br>select * from score a where degree&lt;(select avg(degree) from score b where a.c_no=b.c_no);</p>
<p>+——+——-+——–+<br>| s_no | c_no  | degree |<br>+——+——-+——–+<br>| 102  | 3-105 |     81 |<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+——+——-+——–+</p>
<h3><span id="-32查询排了课的教师的name和department">-32.查询排了课的教师的name和department</span></h3><p>select name ,department from teacher where no in(select t_no from course);<br>+——–+—————–+<br>| name   | department      |<br>+——–+—————–+<br>| 李诚   | 计算机系        |<br>| 王萍   | 计算机系        |<br>| 刘冰   | 电子工程系      |<br>| 张旭   | 电子工程系      |<br>+——–+—————–+</p>
<h3><span id="-33查询至少有两名男生的班级号">-33.查询至少有两名男生的班级号</span></h3><p>select class from student where sex=’男’ group by class having count(*)&gt;1;<br>+——-+<br>| class |<br>+——-+<br>| 95033 |<br>| 95031 |<br>+——-+</p>
<h3><span id="-34查询student表中不姓王的同学记录">-34.查询student表中不姓王的同学记录</span></h3><p>//like ‘…..%’ 模糊查询<br>select * from student where sname not like ‘王%’;<br>+———–+—–+—–+————+——-+<br>| sname     | no  | sex | birthday   | class |<br>+———–+—–+—–+————+——-+<br>| 曾华      | 101 | 男  | 1977-09-01 | 95033 |<br>| 匡明      | 102 | 男  | 1975-10-02 | 95031 |<br>| 李军      | 104 | 男  | 1976-02-20 | 95033 |<br>| 陆军      | 106 | 男  | 1974-06-03 | 95031 |<br>| 张全蛋    | 108 | 男  | 1975-02-10 | 95031 |<br>| 赵铁柱    | 109 | 男  | 1974-06-03 | 95031 |<br>| 张飞      | 110 | 男  | 1974-06-03 | 95038 |<br>+———–+—–+—–+————+——-+</p>
<h3><span id="-35查询student表中的每个学生的姓名和年龄">-35.查询student表中的每个学生的姓名和年龄</span></h3><p>–年龄=当前年份-出生年月</p>
<p>select year(now());<br>+————-+<br>| year(now()) |<br>+————-+<br>|        2021 |<br>+————-+</p>
<p>select year(birthday) from student;<br>+—————-+<br>| year(birthday) |<br>+—————-+<br>|           1977 |<br>|           1975 |<br>|           1976 |<br>|           1976 |<br>|           1975 |<br>|           1974 |<br>|           1976 |<br>|           1975 |<br>|           1974 |<br>|           1974 |<br>+—————-+</p>
<p>!!有点高级了</p>
<p>select sname,year(now())-year(birthday) as ‘年龄’ from student;<br>+———–+——–+<br>| sname     | 年龄   |<br>+———–+——–+<br>| 曾华      |     44 |<br>| 匡明      |     46 |<br>| 王丽      |     45 |<br>| 李军      |     45 |<br>| 王芳      |     46 |<br>| 陆军      |     47 |<br>| 王尼玛    |     45 |<br>| 张全蛋    |     46 |<br>| 赵铁柱    |     47 |<br>| 张飞      |     47 |<br>+———–+——–+</p>
<h3><span id="36查询student表中最大和最小的birthday日期值">36.查询student表中最大和最小的birthday日期值</span></h3><p>select max(birthday) as ‘最大’,min(birthday) as ‘最小’ from student;<br>+————+————+<br>| 最大       | 最小       |<br>+————+————+<br>| 1977-09-01 | 1974-06-03 |<br>+————+————+</p>
<h3><span id="37以班号和年龄从大到小的顺序查询student表中的全部记录">37.以班号和年龄从大到小的顺序查询student表中的全部记录</span></h3><p>select * from student order by class desc,birthday asc;<br>这里的asc升序排列，可以省略。<br>生日升序排列相当于年龄降序排列<br>+———–+—–+—–+————+——-+<br>| sname     | no  | sex | birthday   | class |<br>+———–+—–+—–+————+——-+<br>| 张飞      | 110 | 男  | 1974-06-03 | 95038 |<br>| 王丽      | 103 | 女  | 1976-01-23 | 95033 |<br>| 李军      | 104 | 男  | 1976-02-20 | 95033 |<br>| 王尼玛    | 107 | 男  | 1976-02-20 | 95033 |<br>| 曾华      | 101 | 男  | 1977-09-01 | 95033 |<br>| 陆军      | 106 | 男  | 1974-06-03 | 95031 |<br>| 赵铁柱    | 109 | 男  | 1974-06-03 | 95031 |<br>| 王芳      | 105 | 女  | 1975-02-10 | 95031 |<br>| 张全蛋    | 108 | 男  | 1975-02-10 | 95031 |<br>| 匡明      | 102 | 男  | 1975-10-02 | 95031 |<br>+———–+—–+—–+————+——-+</p>
<h3><span id="-38查询男教师及其所上的课程">-38.查询男教师及其所上的课程</span></h3><p>select * from course where t_no in(select no from teacher where sex=’男’);<br>+——-+————–+——+<br>| no    | name         | t_no |<br>+——-+————–+——+<br>| 3-245 | 操作系统     | 804  |<br>| 6-166 | 数字电路     | 856  |<br>+——-+————–+——+</p>
<h3><span id="-39查询最高分同学的s_noc_nodegree">-39.查询最高分同学的s_no,c_no,degree</span></h3><p>select * from score where degree=(select max(degree) from score);<br>//这里用的where =<br>但是如果两个同学并列最高分的时候还是用where in 比较严谨<br>//<br>+——+——-+——–+<br>| s_no | c_no  | degree |<br>+——+——-+——–+<br>| 103  | 3-105 |     92 |<br>+——+——-+——–+</p>
<h3><span id="-40查询和李军同性别的所有同学的sname">-40.查询和李军同性别的所有同学的sname</span></h3><p>select sname from student where sex=(select sex from student where sname=’李军’);<br>+———–+<br>| sname     |<br>+———–+<br>| 曾华      |<br>| 匡明      |<br>| 李军      |<br>| 陆军      |<br>| 王尼玛    |<br>| 张全蛋    |<br>| 赵铁柱    |<br>| 张飞      |<br>+———–+</p>
<h3><span id="-41查询和李军同性别并且同班级的同学sname">-41.查询和李军同性别并且同班级的同学sname</span></h3><p>select sname from student where sex=(select sex from student where sname=’李军’)<br>and<br>class=(select class from student where sname=’李军’);</p>
<p>+———–+<br>| sname     |<br>+———–+<br>| 曾华      |<br>| 李军      |<br>| 王尼玛    |<br>+———–+</p>
<h3><span id="-42查询所有选修计算机导论课程的男同学的成绩表">-42.查询所有选修计算机导论课程的男同学的成绩表</span></h3><p>select * from score where c_no=(select no from course where name=’计算机导论’)<br>and<br>s_no in (select no from student where sex=’男’); </p>
<p>+——+——-+——–+<br>| s_no | c_no  | degree |<br>+——+——-+——–+<br>| 101  | 3-105 |     90 |<br>| 102  | 3-105 |     81 |<br>| 104  | 3-105 |     89 |<br>| 109  | 3-105 |     76 |<br>+——+——-+——–+</p>
<h3><span id="-43定义分数类型">-43.定义分数类型</span></h3><p>假设使用以下命令建立一个grade表<br>create table grade(<br>low int(3),<br>upp int (3),<br>grade char(1)<br>);</p>
<p>insert into grade values(90,100,’A’);<br>insert into grade values(80,89,’B’);<br>insert into grade values(70,79,’C’);<br>insert into grade values(60,69,’D’);</p>
<p>select s_no,c_no,grade from score,grade where degree between low and upp;</p>
<p>+——+——-+——-+<br>| s_no | c_no  | grade |<br>+——+——-+——-+<br>| 101  | 3-105 | A     |<br>| 102  | 3-105 | B     |<br>| 103  | 3-105 | A     |<br>| 103  | 3-245 | B     |<br>| 103  | 6-166 | B     |<br>| 104  | 3-105 | B     |<br>| 105  | 3-105 | B     |<br>| 105  | 3-245 | C     |<br>| 105  | 6-166 | C     |<br>| 109  | 3-105 | C     |<br>| 109  | 3-245 | D     |<br>| 109  | 6-166 | B     |<br>+——+——-+——-+</p>
<hr>
<p>例题到此结束<br>之后进入mysql第三部分，就剩下最后十节课啦！</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>关键字库函数</title>
    <url>/2021/07/26/%E5%85%B3%E9%94%AE%E5%AD%97%E5%BA%93%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1><span id="关键字库函数">关键字库函数</span></h1><h2><span id="sizeof和strlen">sizeof和strlen</span></h2><p>1.strlen是头文件’cstring’中的函数，sizeof是C++中的运算符。</p>
<p>2**.strlen测量的是字符串的实际长度**(其源代码如下)，以¥n结束。而<strong>sizeof测量的是字符数组的分配大小。</strong></p>
<p>·strlen源代码：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">size_t strlen(const char *str)&#123;
    size_t length &#x3D; 0;
    while(*str++)
        ++length;
    return length;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>举例:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
int main()&#123;
    char arr[10] &#x3D; &quot;hello&quot;;
    cout &lt;&lt; strlen(arr) &lt;&lt; endl; &#x2F;&#x2F;5
    cout &lt;&lt; sizeof(arr) &lt;&lt; endl; &#x2F;&#x2F;10
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.若字符数组arr作为函数的形参，sizeof(arr)中arr被当作字符指针来处理，strlen(arr)中arr依然是字符数组，从下述程序的运行结果中可以看出。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;

void size_of(char arr[])&#123;
    cout &lt;&lt; sizeof(arr) &lt;&lt; endl;
    cout &lt;&lt; strlen(arr) &lt;&lt; endl;
&#125;

int main()&#123;
    char arr[20] &#x3D; &quot;hello&quot;;
    size_of(arr);  &#x2F;&#x2F; 8   5
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>4.s<strong>trlen本身是库函数，因此在程序运行过程</strong>中，计算长度。而<strong>sizeof在编译</strong>时计算长度。</p>
<p>5.sizeof的参数可以是类型，也可以是变量。*<em>strlen的参数必须是char <em>类型</em></em>的变量。</p>
<h2><span id="lambda表达式匿名函数">lambda表达式（匿名函数）</span></h2><p>lambda 表达式的定义形式如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">[capture list](parameter list)-&gt;return type
&#123;
    function body
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中：</p>
<ul>
<li>capture list：捕获列表，指lambda表达式所在函数中定义的局部变量的列表，通常为空，但如果函数体中用到了lambda表达式所在函数的局部变量，必须捕获该变量，即将此变量写在捕获列表中。捕获方式分为：<strong>引用快捷捕获[&amp;]</strong>,<strong>值捕获方式[=].</strong> </li>
<li>return type,parameter list ,function body:分别标识返回值类型，参数列表，函数体，和普通函数一样。</li>
</ul>
<hr>
<p>举例：</p>
<p>lambda表达式常搭配排序算法使用：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()&#123;
    vector&lt;int&gt;arr &#x3D; &#123;3,4,76,12,54,90,34&#125;;
    sort(arr.begin(),arr.end(),[](int a,int b) &#123;
        return a&gt;b;
    &#125;);  &#x2F;&#x2F;降序排列
    for(auto a:arr)&#123;
        cout&lt;&lt;a&lt;&lt;&quot; &quot;;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="explicit的作用">explicit的作用</span></h2><p>作用：用来声明类构造函数是显示调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显示调用的，再加上explicit关键字并没有意义。</p>
<p>隐式转换：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
class A&#123;
public:
    int var;
    A(int tmp)&#123;
        var &#x3D; tmp;
        cout&lt;&lt;var;
    &#125;
&#125;;
int main()&#123;
    A ex &#x3D; 10;  &#x2F;&#x2F;发生了隐式转换
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述代码中，A ex = 10，在编译时，进行了隐式转换，将10转换成A类型的对象，然后将该对象赋值给ex，等同如下操作：</p>
<p>为了避免隐式转换，可用explicit关键字进行声明：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
class A&#123;
public:
    int var;
    explicit A(int tmp)&#123;
        var &#x3D; tmp;
        cout&lt;&lt;var&lt;&lt;endl;
    &#125;
&#125;;
int main()&#123;
    A ex(100);
    A ex1 &#x3D; 10;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">error: conversion from ‘int’ to non-scalar type ‘A’ requested<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<h2><span id="static的作用">static的作用</span></h2><h3><span id="static定义静态变量静态函数">static定义静态变量，静态函数</span></h3><p>保持变量内容持久：<strong>static 作用于局部变量，改变局部变量的生存周期</strong>，使得该变量存在于定义后直到程序运行结束的这段时间。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
int fun()&#123;
    static int var &#x3D; 1 ; &#x2F;&#x2F;var只在第一次进入这个函数的时候初始化
    var +&#x3D; 1;
    return var;
&#125;
int main()&#123;
    for(int i&#x3D; 0;i&lt;10;++i)&#123;
        cout&lt;&lt;fun()&lt;&lt;&quot; &quot;; &#x2F;&#x2F;2,3,4,5,6,7,8,9,10,11
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>隐藏:static作用于全局变量和参数，改变了全局变量和函数的作用域，使得全局变量和函数只能在定义它的文件中使用，在源文件中不具有全局可见性。（注：普通全局变量和函数具有全局可见性，即其他的源文件也可以使用）</p>
<p>static 作用于类的成员变量和类的成员函数，使得类变量或者类成员函数和类有关，也就是说<strong>可以不定义类的对象就可以通过类访问这些静态成员</strong>。注意：类的静态成员函数只能<strong>访问静态成员变量</strong>或者<strong>静态成员函数</strong>，而<strong>不能将静态成员函数定义成虚函数。</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#inlcude&lt;iostream&gt;
using namespace std;
class A&#123;
private:
    int var;
    static int s_var; &#x2F;&#x2F;静态成员变量
public:
    void show()&#123;
        cout&lt;&lt;s_var++&lt;&lt;endl;
    &#125;
    static void s_show()&#123;
        cout&lt;&lt;s_var&lt;&lt;endl;
        &#x2F;&#x2F;cout&lt;&lt;var&lt;&lt;endl; --&gt;invalid use of member ‘A::var’ in static member function
        &#x2F;&#x2F;show();
    &#125;
&#125;;
int A::s_var &#x3D; 1; &#x2F;&#x2F;静态成员变量在类外进行初始化赋值，默认初始化为0
int main()&#123;
    &#x2F;&#x2F;cout&lt;&lt;A::sa&lt;&lt;endl; 
    A ex;
    ex.show();
    A::s_show(); &#x2F;&#x2F; &#x3D;&#x3D; ex.s_show();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h3><span id="static类中使用的注意事项">static类中使用的注意事项</span></h3><p>static静态成员变量：</p>
<ul>
<li>1.静态成员变量是在类内进行声明，在类外进行定义和初始化，在类外进行<strong>定义和初始化的时候不要出现static关键字和private，public，protected</strong>访问规则。</li>
<li>2.静态成员变量相当于类域中的全局变量，<strong>被类的所有对象所共享，包括派生类的对象。</strong></li>
<li>3.静态成员变量可以<strong>作为成员函数的参数</strong>，而普通成员变量不可以。</li>
</ul>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
class A&#123;
public:
    static int s_var;
    int var;
    void fun1(int i &#x3D; s_var);&#x2F;&#x2F;正确，静态成员变量可以作为成员函数的参数
    void fun2(int i &#x3D; var); &#x2F;&#x2F;erro invalid use of non_static data member &#39;A::var&#39;
    
&#125;;
int main()&#123;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>4.<strong>静态数据成员</strong>的类型可以是<strong>所属类的类型</strong>，而<strong>普通数据成员</strong>的类型只能是<strong>该类类型的指针或引用</strong>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
class A&#123;
public:
    static A s_var;&#x2F;&#x2F;正确，静态数据成员
    A var; &#x2F;&#x2F; error field &#39;var&#39; has incomplete type &#39;A&#39;
    A *p; &#x2F;&#x2F;正确 指针
    A &amp;var1; &#x2F;&#x2F;正确 引用
&#125;;
int main()&#123;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>static<strong>静态成员函数不能调用非静态成员变量或者非静态成员函数</strong>，因为静态成员函数<strong>没有this指针</strong>。静态成员函数作为类作用域的全局函数。</li>
<li><strong>静态成员函数不能声明成虚函数(virtual) , const 函数和volatile函数</strong></li>
</ol>
<h3><span id="static全局变量和普通全局变量">static全局变量和普通全局变量</span></h3><p>相同点：</p>
<p>存储方式：普通全局变量和static全局变量都是静态存储方式</p>
<p>不同点：</p>
<p>作用域：<strong>普通全局变量的作用域是整个源程序</strong>，当一个源程序由多个源文件组成时，普通全局变量在各个源文件都是有效的，<strong>静态全局变量则限制其作用域，即只在定义该变量的源文件内有效。在同一源程序的其他源文件中不能使用它</strong>。由于静态全局变量的作用域限于一个源文件内，只能<strong>为该源文件内的函数公用，因此可以避免在其他源文件中引起错误</strong>。</p>
<h2><span id="const-的作用">const 的作用</span></h2><p>作用：</p>
<ul>
<li>const修饰成员变量，<strong>定义成const常量，相较于宏常量，节省内存空间</strong>，提高了效率。</li>
<li>const修饰函数参数，使得传递过来的<strong>函数参数的值不能改变</strong>。</li>
<li>const修饰成员函数，使得成员函数不能修改任何类型的成员变量（mutable修饰的变量除外），也<strong>不能调用const成员函数，因为非const成员可能会修改成员变量。</strong></li>
</ul>
<p>在类中的用法：</p>
<p>const成员变量：</p>
<p>1.const成员变量只能在类内声明，定义，<strong>在构造函数初始化列表中初始化</strong>。</p>
<p>2.<strong>const成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的</strong>，因为类可以创建多个对象，<strong>不同类的const成员变量的值是不同的</strong>。因此<strong>不能在类的声明中初始化const成员变量，类的对象没有创建，编译器不知道它的值。</strong></p>
<p>const成员函数：</p>
<ol>
<li>不能修改成员变量的值，除非由mutable修饰，只能访问成员变量。</li>
<li>不能调用非常量成员函数，以防修改成员变量的值。</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
class A&#123;
public:
    int var;
    A(int tmp):var(tmp)&#123;&#125;
    void c_fun(int tmp)const &#x2F;&#x2F;const成员函数
    &#123;
        var &#x3D; tmp; &#x2F;&#x2F;error 在const成员函数中，不能修改任何类成员变量
        fun(tmp);
        &#x2F;&#x2F;error  const成员函数不能调用非const成员函数，因为非const成员函数可能会修改成员变量
        
    &#125;
    void fun(int tmp)&#123;
        var &#x3D; tmp;
    &#125;
&#125;;
int main()&#123;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="define和const区别">define和const区别</span></h2><p>区别：</p>
<ul>
<li>编译阶段：define是在编译预处理阶段进行替换，const是在编译阶段确定其值。</li>
<li>安全性**:define定义的宏常量<strong>没有数据类型，只是进行简单的替换，</strong>不会进行类型安全的检查**，const定义的常量是有类型的，要进行判断，可以避免一些低级错误。</li>
<li>内存占用：define定义的宏常量，在<strong>程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的空间</strong>，const定义的常量占用<strong>静态存储区的空间</strong>，程序运行过程中只有一份。</li>
<li>调试：<strong>define定义的宏常量不能调试</strong>，因为在预编译阶段就已经替换了，<strong>const定义的常量可以进行调试</strong>。</li>
</ul>
<p>const的优点：</p>
<p>有数据类型，在定义时可以进行安全检查。</p>
<p>可调式。</p>
<p>占用较少的空间。</p>
<h2><span id="define和typedef的区别">define和typedef的区别</span></h2><p>原理：#define作为预处理指令，在编译预处理时进行替换操作，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。typedef时关键字，在编译时处理，有类型检查的功能，用来给一个已经存在的类型一个别名，但不能在一个函数定义里面使用typedef。</p>
<p>功能：typedef用来定义类型的别名，方便使用。#define不仅可以为类型取别名，还可以定义常量，变量，编译开关等。</p>
<p>作用域：#define没有作用域 的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域。</p>
<p>指针的操作：typedef和#define在处理指针时不完全一样。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#define INTPTR1 int *
typedef int *INTPTR2;
using namespace std;
int main()&#123;
    INTPTR1 p1,p2;   &#x2F;&#x2F;p1:int *; p2:int
    INTPTR p3,p4;    &#x2F;&#x2F;p3:int * ;p4:int *
    int var &#x3D;1;
    const INTPTR1 p5 &#x3D; &amp;var; &#x2F;&#x2F;相当于const int *p5 常量指针，即不可以通过p5去修改p5指向的内容，但是p5可以指向其他内容
    
    const INTPTR2 p6 &#x3D; &amp;var;
    &#x2F;&#x2F;相当于 int * const p6 指针常量，不可使p6再指向其他的内容。
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">指针常量和常量指针的区别--&gt;参考语言特性<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2><span id="宏实现比较大小以及两个数中的最小值">宏实现比较大小，以及两个数中的最小值</span></h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#define MAX(X,Y) ((X)&gt;(Y)?(X):(Y))
#define MIN(X,Y) ((X&lt;Y)?(X):(Y))
using namespace std;
int main()&#123;
    int var1 &#x3D; 10,var2 &#x3D; 100;
    cout&lt;&lt;MAX(var1,var2)&lt;&lt;endl;
    cout&lt;&lt;MIN(var1,var2)&lt;&lt;endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="inline的作用">inline的作用</span></h2><p>作用：</p>
<p><strong>inline是一个关键字，可以用于定义内联函数</strong>。内联函数，像普通函数一样被调用，但是在<strong>调用时并不通过函数调用的机制而是直接在调用点处展开，这样可以大大减少由函数调用带来的开销，</strong>从而提高程序的运行效率。</p>
<p>使用方法：</p>
<p>1.类内定义成员函数默认时内联函数</p>
<p>在<strong>类内定义成员函数，可以不用在函数头部加inline关键字</strong> ，因为编译器会自动将类内定义的函数（构造函数，析构函数，普通成员函数等）声明为内联函数，代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
class A&#123;
public:
    int var;
    A(int tmp)&#123;
        var &#x3D; tmp;
    &#125;
    void fun()&#123;
        cout&lt;&lt;var&lt;&lt;endl;
    &#125;
&#125;;
int main()&#123;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>2.类外定义成员函数，若想定义为内联函数，需要关键字声明</p>
<p>当在类内声明函数，在类外定义函数时，如果想将该函数定义为内联函数，则可以在类内声明时不加inline关键字，而在类外定义函数时加上inline关键字。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
class A&#123;
public:
    int var;
    A(int tmp)&#123;
        var &#x3D; tmp;
    &#125;
    void fun();
&#125;
inline void A::fun()&#123;
    cout&lt;&lt;var&lt;&lt;endl;
&#125;
int main()&#123;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外，可以在声明函数和定义函数的同时加上inline，也可以只在函数声明时加inline，而定义函数时不加inline。<strong>只要确保在调用该函数之前把inline的信息告知编译器即可。</strong></p>
<h3><span id="inline的工作原理">inline的工作原理</span></h3><p><strong>内联函数不是在调用时发生控制转移关系</strong>，而是<strong>在编译阶段将函数体嵌入到每一个调用该函数的语句块中</strong>，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。</p>
<p><strong>普通函数调用</strong>是将程序执行<strong>转移到被调用函数所存放的内存地址</strong>，当函数执行完之后，<strong>返回到执行此函数前的地方</strong>。转移操作需要保护现场，被调用函数执行完后，再恢复现场，该过程需要<strong>较大的资源开销。</strong></p>
<h3><span id="define和inline的区别">define和inline的区别</span></h3><p><strong>内联函数在编译时</strong>展开，而<strong>宏在编译处理时展开</strong>，在编译的时候，内联函数直接嵌入到目标代码中去，而宏只是一个简单的文本替换。</p>
<p>内联函数时真正的函数，<strong>和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销</strong>。而宏定义编写较为复杂，需增加一些括号来避免歧义。</p>
<p><strong>宏定义只进行文本替换</strong>。不会对参数类型，语句能否正常编译等进行检查<strong>。而内联函数是真正的函数，会对参数的类型，函数体内的语句编写是否正确等进行检查。</strong></p>
<p>使用举例：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#define MAX(a,b) ((a)&gt;(b)?(a):(b))
using namespace std;
inline int fun_max(int a,int b)&#123;
    return a&gt;b ?a :b;
&#125;
int main()&#123;
    int var &#x3D;1;
    cout&lt;&lt;MAX(var,5)&lt;&lt;endl;
    cout&lt;&lt;fun_max(var,0);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="new的作用">new的作用</span></h2><p>new是C++的关键字，用来动态分配内存，实现方式如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int *p &#x3D; new int[5];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>new:内存分配成功，返回该对象类型的指针，分配失败，抛出bad_alloc异常。</p>
<p>malloc：成功申请内存，返回指向该内存的指针。分配失败，返回NULL指针。</p>
<h2><span id="delete实现原理">delete实现原理</span></h2><p>delete的实现原理：</p>
<p>首先<strong>执行该对象所属类的析构函数。</strong></p>
<p>进而通过调用operator delete的标准库函数<strong>来释放所占的内存空间。</strong></p>
<p>delete和delete[]的区别：</p>
<p><strong>delete用来释放单个对象所占的空间</strong>，只会调用一次析构函数。</p>
<p><strong>delete[] 用来释放数组空间</strong>，会对数组中的每个成员都调用一次析构函数。</p>
<h2><span id="new-malloc-delete-free">new malloc delete free</span></h2><ul>
<li><p>在使用的时候new，delete搭配使用，malloc和free搭配使用</p>
<p><strong>malloc，free是库函数，而new delete是关键字。</strong></p>
<p>-new申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算，<strong>malloc在申请空间时，需要确定所申请空间的大小</strong>。</p>
</li>
<li><p>new申请空间时，<strong>返回的类型是对象的指针类型</strong>，无需强制类型转换，是类型安全的操作符；*<em>malloc申请空间时，返回的是 void * 类型,需要进行强制类型的转换*</em>，转换为对象类型的指针。</p>
</li>
<li><p>new分配失败时，会抛出bad_alloc异常，malloc分配失败会返回空指针。</p>
</li>
<li><p><strong>对于自定义的类型</strong>，new首先调用operator new()函数申请空间（<strong>底层通过malloc</strong>）实现，然后调用构造函数进行初始化，最后返回自定义类型的指针。delete首先调用析构函数，然后调用operator delete()释放空间（<strong>底层通过free实现</strong>）。<strong>malloc，free无法进行自定义类型的对象的构造和析构。</strong></p>
</li>
<li><p><strong>new操作符从自由存储区上为对象动态分配内存</strong>，而<strong>malloc函数从堆上动态分配内存</strong>（自由存储区不等于堆）。</p>
</li>
</ul>
<h2><span id="malloc的原理">malloc的原理</span></h2><p>malloc的原理：<br>当开辟的空间小于128K时，调用brk()函数，通过移动_enddata来实现。</p>
<p>当开辟空间大于128K时，调用mmap()函数，通过在虚拟地址空间中开辟一块内存空间来实现。</p>
<p>malloc的底层实现：</p>
<p>brk()函数实现原理：向高地址的方向移动指向数据段高地址的指针_enddata。</p>
<p>mmap内存映射原理：</p>
<ol>
<li>进程启动映射过程，并<strong>在虚拟地址空间中为映射创建虚拟映射区域。</strong></li>
<li>调用内核空间的系统函数<strong>mmap()**，实现文件物理地址和进程虚拟地址的</strong>一一映射关系。**</li>
<li>进程发起<strong>对这片映射空间的访问，引发缺页异常</strong>，实现文件内容<strong>到物理内存（主存）的拷贝。</strong></li>
</ol>
<h2><span id="volatile的作用">volatile的作用</span></h2><p>volatile的作用:当对象的值可能在程序的控制或检测之外被改变时，应该将该对象<strong>声明为volatile,告知编译器不应对这样的对象进行优化读取和存储</strong>。</p>
<p>volatile不具有原子性。</p>
<p>volatile对编译器的影响：使用该关键字后，编译器不会对相应的对象进行优化，即不会将变量从内存缓存到寄存器中，防止多个线程有可能使用内存中的变量，有可能使用寄存器中的变量，<strong>从而导致程序错误。出现不一致的现象。</strong></p>
<p>使用volatile关键字的场景：</p>
<ul>
<li>当多个线程都会用到某一变量，并且该变量的值有可能发生改变时，需要用volatile关键字对该变量进行修饰。</li>
<li>中断服务程序中访问的变量或并行设备的硬件寄存器的变量，最好用volatile关键字修饰。</li>
</ul>
<p>volatile关键字和const关键字可以同时使用，某种类型可以既是volatile又是const，同时具有两者的属性。</p>
<h2><span id="返回函数中静态变量的地址会发生什么">返回函数中静态变量的地址会发生什么？</span></h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
int *fun(int tmp)&#123;
    static int var &#x3D; 10;
    var *&#x3D;tmp;
    return &amp;var;
&#125;
int main()&#123;
    cout&lt;&lt;*fun(5)&lt;&lt;endl;
    return 0;
&#125;
&#x2F;&#x2F; 50<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>说明：上述代码中在函数fun中定义了静态局部变量var，使得离开该函数的作用域后，该变量不会销毁，返回到主函数中，该变量依然存在。但是，该静态局部变量直到程序运行结束后才销毁，浪费内存空间。</p>
<h2><span id="extern-c的作用">extern C的作用</span></h2><p>当C++程序需要调用C语言编写的函数，C++使用链接指示，即extern C指出任意非C++函数所用的语言。</p>
<p>举例：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;可能出现在C++头文件&lt;cstring&gt;中的链接指示
extern &quot;C&quot;&#123;
    int strcmp(const char*,const char *);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>extern “C” 的作用是让 C++ 编译器将 extern “C” 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p>
<h2><span id="sizeof11">sizeof（1==1）</span></h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;
void main()&#123;
    printf(&quot;%ld\n&quot;,sizeof(1&#x3D;&#x3D;1));
&#125;
&#x2F;&#x2F;运行结果为4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
int main()&#123;
    cout&lt;&lt;sizeof(1&#x3D;&#x3D;1)&lt;&lt;endl;
    return 0;
&#125;
&#x2F;&#x2F; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>原因：</p>
<p><strong>C语言没有布尔类型 sizeof(1==1) —-&gt;sizeof(1) 按照字节处理</strong> ，4字节，也有可能是8字节。</p>
<p><strong>C++拥有布尔类型，sizeof(1==1) —–&gt;sizeof(true) 按照bool类型处理</strong>，所以是一个字节。</p>
<h2><span id="strcpy函数有什么缺陷">strcpy函数有什么缺陷?</span></h2><p>strcpy函数的缺陷：<strong>strcpy函数不检查目的缓冲区的大小边界</strong>，而是将源字符逐一的全部赋值给目的字符串地址起始的一块连续的内存空间，同时加上字符串终止符，<strong>会导致其他变量被覆盖。</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
int main()&#123;
    int var &#x3D; 0x11112222;
    char arr[10];
    cout&lt;&lt;&quot;Address : var &quot;&lt;&lt;&amp;var&lt;&lt;endl;
    cout&lt;&lt;&quot;Address :arr&quot;&lt;&lt;&amp;arr&lt;&lt;endl;
    strcpy(arr,&quot;hello world!&quot;);
    cout&lt;&lt;&quot;var:&quot;&lt;&lt;hex&lt;&lt;var&lt;&lt;endl; &#x2F;&#x2F;将变量var以16进制输出
    cout&lt;&lt;&quot;arr:&quot;&lt;&lt;arr&lt;&lt;endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>说明：从上述代码中可以看出，变量var的后六位被字符串“hello world！”的“d!￥0”这三个字符改变，则三个字符对应的ascii码十六进制为￥0(0x00) ,!(0x21),d(0x64)。</p>
<p>原因：变量arr只分配的10个内存空间，通过上述程序中的地址可以看出arr和var的内存中是连续存放的，但是在调用strcpy函数进行拷贝时，源字符串的<strong>“hello world！”所占的内存空间为13，因此在拷贝的过程中会占用var的内存空间，导致var的后六位被覆盖。</strong></p>
<h2><span id="auto类型推导的原理">auto类型推导的原理：</span></h2><p>编译器根据初始值来推算变量的类型，要求用auto定义变量时必须有初始值。编译器推断出来的auto类型有时和初始值类型并不完全一样。编译器会适当改变结果类型使其更符合初始化规则。</p>
<h2><span id="class和struct的异同">class和struct的异同</span></h2><p>struct和class都可以自定义数据类型，也可以支持继承操作。</p>
<p>struct中默认的访问级别是public，默认的继承级别是public。class默认的访问级别是private ，默认的继承级别也是private。</p>
<p>当class继承struct或者struct继承class时，默认的继承级别取决于class或struct本身，class（private继承），struct（public继承）取决于派生类的默认继承级别。</p>
<pre class="line-numbers language-none"><code class="language-none">struct A&#123;&#125;;
class B:A&#123;&#125;; &#x2F;&#x2F;private 继承
struct C :B&#123;&#125;; &#x2F;&#x2F;public继承<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>举例：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
class A&#123;
public:
    void funA()&#123;
        cout&lt;&lt;&quot;class A&quot;&lt;&lt;endl;
    &#125;
    
&#125;;
struct B: A&#123;
    &#x2F;&#x2F;由于B是struct A的默认继承级别为public
public:
    void funB()&#123;
        cout&lt;&lt;&quot;class B&quot;&lt;&lt;endl;
    &#125;
&#125;;
class C: B&#123;
    &#x2F;&#x2F;由于C是class ，B的默认继承级别为private ，所以无法访问基类B中的printB函数  
&#125;;
int main()&#123;
    A ex1;
    ex1.funA(); &#x2F;&#x2F;class A
    B ex2;
    ex2.funB(); &#x2F;&#x2F;class B
    ex2.funA(); 
    &#x2F;&#x2F;struct B继承class A是public继承 所以可以调用funA()
    C ex3; 
    ex3.funB(); &#x2F;&#x2F;error 
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2><span id="struct和union的区别">struct和union的区别</span></h2><p>说明：union是联合体，struct是结构体</p>
<p>区别：</p>
<ul>
<li>联合体和结构体都是由若干个数据类型不同的数据成员组成，使用时联合体只有一个有效的成员，而结构体所有的成员都有效。</li>
<li>对联合体的不同成员赋值，将会覆盖其他成员的值，而对于结构体的对不同成员赋值时，相互不影响。</li>
<li>联合体的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小。结构体分配内存的大小遵循内存对齐原则。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
typedef union 
&#123;
    char c[10];
    char cc1;  &#x2F;&#x2F;char 1字节 按该类型的倍数分配大小
&#125; u11;
typedef union 
&#123;
    char c[10];
    int i;   &#x2F;&#x2F;int 4字节，按该类型的倍数分配大小
&#125; u22;

typedef union
&#123;
    char c[10];
    double d; &#x2F;&#x2F; double 8 字节，按该类型的倍数分配大小
&#125; u33;

typedef struct s1
&#123;
    char c;   &#x2F;&#x2F; 1 字节
    double d; &#x2F;&#x2F; 1（char）+ 7（内存对齐）+ 8（double）&#x3D; 16 字节
&#125; s11;

typedef struct s2
&#123;
    char c;   &#x2F;&#x2F; 1 字节
    char cc;  &#x2F;&#x2F; 1（char）+ 1（char）&#x3D; 2 字节
    double d; &#x2F;&#x2F; 2 + 6（内存对齐）+ 8（double）&#x3D; 16 字节
&#125; s22;

typedef struct s3
&#123;
    char c;   &#x2F;&#x2F; 1 字节
    double d; &#x2F;&#x2F; 1（char）+ 7（内存对齐）+ 8（double）&#x3D; 16 字节
    char cc;  &#x2F;&#x2F; 16 + 1（char）+ 7（内存对齐）&#x3D; 24 字节
&#125; s33;

int main()
&#123;
    cout &lt;&lt; sizeof(u11) &lt;&lt; endl; &#x2F;&#x2F; 10
    cout &lt;&lt; sizeof(u22) &lt;&lt; endl; &#x2F;&#x2F; 12
    cout &lt;&lt; sizeof(u33) &lt;&lt; endl; &#x2F;&#x2F; 16
    cout &lt;&lt; sizeof(s11) &lt;&lt; endl; &#x2F;&#x2F; 16
    cout &lt;&lt; sizeof(s22) &lt;&lt; endl; &#x2F;&#x2F; 16
    cout &lt;&lt; sizeof(s33) &lt;&lt; endl; &#x2F;&#x2F; 24

    cout &lt;&lt; sizeof(int) &lt;&lt; endl;    &#x2F;&#x2F; 4
    cout &lt;&lt; sizeof(double) &lt;&lt; endl; &#x2F;&#x2F; 8
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++进阶笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型程序设计</title>
    <url>/2021/02/27/%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="泛型程序设计">泛型程序设计</span></h2><p>编写不依赖于具体数据类型的程序<br>将算法从特定的数据结构中抽象出来，成为通用的<br>C++的模板为泛型程序设计奠定了关键的基础</p>
<h3><span id="概念和模型">概念和模型</span></h3><h4><span id="概念">概念</span></h4><p>概念:<br>用来界定具备一定功能的数据类型。例如：<br>将“可以比大小的所有数据类型（有比较运算符）”这一概念记为Comparable<br>将“具有公有的复制构造函数并可以用”=”赋值的数据类型” 这一概念记为Assignable<br>将“可以比大小，具有公有的复制构造函数并可以用“=”赋值的所有数据类型 这一概念记作Sortable<br>对于两个不同概念的A和B ，如果概念A所需求的所有功能也是概念B所需求的功能，那么<br>就说概念B是概念A的子概念。 例如：<br>Sortable 既是Comparable的子概念 ，也是Assignable的子概念</p>
<h4><span id="模型">模型</span></h4><p>模型(model)：符合一个概念的数据类型称为该概念的模型，例如：<br>int 型是Comparable概念的模型<br>静态数组类型不是Assignable 概念的模型<br>（无法用 “=” 给整个静态数组赋值</p>
<h4><span id="用概念作模板参数名">用概念作模板参数名</span></h4><p>为概念赋予一个名称，并使用该名称作为模板参数名<br>例如：<br>表示insertionSort这样一个函数模板的原型：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;class Sortable&gt;
void insertionSort(Sortable a[],int n)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3><span id="stl">STL</span></h3><p>STL 简介<br>标准模板库，定义了一套概念体系，为泛型程序设计提供了逻辑基础<br>STL中的各个类模板，函数模板的参数都使用这个体系中的概念来规定的<br>使用STL的模板时，类型参数既可以是C++标准库中已有的类型，也可以是自定义的类型<br>只要这些类型是所要求概念的模型</p>
<h4><span id="stl基本组件">STL基本组件</span></h4><p>容器（container)<br>容纳，包含一组元素的对象。<br>基本容器类模板<br>顺序容器<br>array,vector,deque,forward_list,list<br>有序关联容器<br>set,multiset,map,multimap<br>无序关联容器<br>unordered_set,unordered_multiset<br>unordered_map ,unordered_multimap</p>
<p>容器适配器：<br>stack(栈)<br>queue（队列）<br>priority_queue(优先队列)</p>
<p>迭代器（iterator)<br>提供了顺序访问容器每一个元素的方法<br>可以使用“++”运算符来获得指向下一个元素的迭代器<br>可以使用“*”运算符防卫迭代器所指向的元素，如果元素类型是类或结构体，还可以使用<br>“-&gt;”运算符直接访问该元素的一个成员<br>有些迭代器还支持通过”–”运算符获得指向上一个元素的迭代器<br>迭代器是泛化的指针： 指针也具有同样的特性，因此指针本身就是一种迭代器<br>使用独立于STL容器的迭代器 ，需要包含头文件”iterator”</p>
<p>函数对象（function object)<br>一个行为类似函数的对象，对它可以像调用函数一样调用。<br>函数对象是泛化的函数：任何普通的函数和任何重载了“（）”运算符的类的对象都可以作为函数对象使用<br>使用STL的函数对象，需要包含头文件 “functional”</p>
<p>算法(algorithms)<br>可以广泛用于不同的对象和内置的数据类型<br>STL包括了70多个算法<br>例如：排序算法，消除算法，计数算法，比较算法，变换算法，置换算法和容器管理等<br>使用STL的算法，需要包含头文件“algorithm”</p>
<h5><span id="顺序容器">顺序容器</span></h5><h5><span id="向量">向量</span></h5><p>特点：<br>一个可以扩展的动态数组<br>随机访问，在尾部插入或删除元素快<br>在中间或头部插入或删除元素慢</p>
<p>向量的容量：<br>容量（capacity）：世纪分配空间的大小<br>s.capacity() ：返回当前容量<br>s.reserve(n) : 若容量小于n，则对s进行扩展，使其容量至少为n</p>
<h5><span id="双端队列deque">双端队列(deque)</span></h5><p>在两端插入或删除元素快<br>在中间插入或删除元素慢<br>随机访问较快，但比向量容器慢</p>
<p>奇偶排序例题：<br>先按照从大到小顺序输出奇数，再按照从小到达顺序输出偶数<br>特点：先插入两端元素，速度较快</p>
<pre class="line-numbers language-none"><code class="language-none">int main()&#123;
    istream_iterator&lt;int&gt;i1(cin),i2; &#x2F;&#x2F;建立一对输入流迭代器
    vector &lt;int&gt; s1(i1,i2); &#x2F;&#x2F;通过输入流迭代器从标准输入流中输入数据
    sort(s1.begin(),s1.end()); &#x2F;&#x2F;将输入的整数排序
    deque &lt;int&gt; s2; &#x2F;&#x2F;双端队列
    for (vector &lt;int&gt;::iterator iter &#x3D; s1.begin();iter!&#x3D;s1.end();++iter)&#123;
        if (*iter%2 &#x3D;&#x3D;0)
            s2.push_back(*iter); &#x2F;&#x2F;偶数放到s2尾部
        else
            s2.push_front(*iter); &#x2F;&#x2F;奇数放到s2首部
    &#125;
    copy(s2.begin(),s2.end(),ostream_iterator&lt;int&gt;(cout,&quot; &quot;)); &#x2F;&#x2F;将s2的结果输出
    cout&lt;&lt;endl;
    return 0
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5><span id="列表">列表</span></h5><p>特点：<br>在任意位置插入和删除都很快<br>不支持随机访问<br>接合操作（splice）操作<br>s1.splice(p,s2,q1,q2):将s2中[q1,q2)移动到s1中p所指向元素之前</p>
<h5><span id="单向链表forward_list">单向链表（forward_list)</span></h5><p>单向链表每个结点只有指向下个结点的指针，没有简单的方法来获取一个结点的前驱；<br>未定义insert,emplace,erase操作，而定义了insert_after,emplace_after,erase_after操作，其参数与list的insert,emplace,erase相同，但并不是插入或删除迭代器p1所指的元素，而是对p1所指元素之后的结点进行操作<br>不支持size操作</p>
<h5><span id="数组array">数组(array)</span></h5><p>array是对内置数组的封装，提供了更安全，更方便的使用数组的方式<br>array的对象的大小是固定的，定义时除了需要指定元素类型，还需要指定容器大小<br>不能动态地改变容器大小</p>
<h5><span id="顺序容器的比较">顺序容器的比较</span></h5><p>STL所提供的顺序容器各有利弊，需要根据自己的需求选择容器<br>若执行大量的随机访问操作，而且当扩展容器时只需要向容器尾部加入新的元素，就应当选择向量容器vector</p>
<p>如果需要少量的随机访问操作，需要在容器两端插入或删除元素，则应选择双端队列deque</p>
<p>如果不需要对容器进行随机访问，但是需要在中间位置插入或删除元素，就应当选择列表容器list或forward_list</p>
<p>如果需要数组，array相对于内置数组而言，是一种更安全，更容易使用的数组类型</p>
<h5><span id="顺序容器的插入迭代器">顺序容器的插入迭代器</span></h5><p>用于向容器头部，尾部，中间的指定位置插入元素的迭代器<br>包括前插迭代器(front_inserter),后插迭代器(back_inserter),和任意位置插入迭代器(inserter)</p>
<p>例子：</p>
<pre class="line-numbers language-none"><code class="language-none">list &lt;int&gt; s;
back_inserter iter(s);
*(iter++) &#x3D;5； #通过iter把5插入s尾】<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h5><span id="顺序容器的适配器">顺序容器的适配器</span></h5><p>以顺序容器为基础构建一些常用数据结构，是对顺序容器的封装<br>栈: 最先压入的元素最后被弹出<br>队列：最先压入的元素最先被弹出<br>优先级队列：最”大”的元素最先被弹出</p>
<h5><span id="栈和队列模板">栈和队列模板</span></h5><p>栈模板</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;class T,class Sequence &#x3D; deque&lt;T&gt; &gt;class stack;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>队列模板</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;class T,class FrontInsertionSequence &#x3D; deque&lt;T&gt; &gt;class queue;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>栈可以用任何一种顺序容器作为基础容器，而队列只允许用前插顺序容器（双端队列或列表）</p>
<h5><span id="栈和队列共同支持的操作">栈和队列共同支持的操作</span></h5><p>s1 op s2 ，op： ==，！=，&lt;,&lt;=,&gt;,&gt;=<br>它会对两个容器适配器之间的元素按字典序进行比较</p>
<p>s.size() 返回s的元素个数<br>s.empty() 返回s是否为空<br>s.push(t) 将元素t压入到s中<br>s.pop() 将一个元素从s中弹出 ，对于栈来说，每次弹出的是最后被压入的元素，而对于队列来说，每次被弹出的是最先被压入的元素<br>不支持迭代器，因为它们不允许对任意元素进行访问</p>
<h5><span id="栈和队列不同的操作">栈和队列不同的操作</span></h5><p>栈的操作<br>s.top() 返回栈顶元素的引用<br>队列操作<br>s.front() 获得队头元素的引用<br>s.back()  获得队尾元素的引用</p>
<p>利用栈反向输出单词<br>示例：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;iterator&gt;
#include&lt;stack&gt;
using namespace std;
int main ()&#123;
    stack &lt;char&gt; s;
    string str;
    cin &gt;&gt; str; &#x2F;&#x2F;从键盘输入一个字符串
    &#x2F;&#x2F; 将字符串的每个元素顺序压入栈中
    for (string::iterator iter &#x3D; str.begin();iter!&#x3D;str.end();++iter)
        s.push(*iter);
    &#x2F;&#x2F; 将栈中的元素弹出
    while(!s.empty())&#123;
        cout&lt;&lt;s.top();
        s.pop();
    &#125;
    cout&lt;&lt;endl;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果演示：<br>congratulations<br>snoitalutargnoc</p>
<h5><span id="优先级队列">优先级队列</span></h5><p>优先级队列也像栈队列一样支持元素的压入和弹出，但元素弹出的顺序与元素的大小有关，每次弹出的总是容器中最”最大”的一个元素。</p>
<pre class="line-numbers language-none"><code class="language-none">template &lt;class T,class Sequence &#x3D; vector&lt;T&gt; &gt;class priority_queue;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>优先级队列的基础容器必须是支持随机访问的顺序容器<br>支持栈和队列的size,empty,push,pop几个成员函数，用法与栈和队列相同<br>优先级队列并不支持比较操作<br>与栈类似，优先级队列提供一个top函数，可以获得下一个即将被弹出元素（即最”大”的元素）的引用</p>
<p>例10-8 细胞分裂模拟<br>模拟一种细胞在诞生（即上次分裂）后会在500到20000秒内分裂成两个细胞，每个细胞又按照同样的规律继续分裂</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;10_8.cpp
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;cstdlib&gt; &#x2F;&#x2F;随机函数
#include &lt;ctime&gt;　&#x2F;&#x2F;获得当地时间
using namespace std;

const int SPLIT_TIME_MIN &#x3D; 500;      &#x2F;&#x2F;细胞分裂最短时间
const int SPLIT_TIME_MAX &#x3D; 2000;    &#x2F;&#x2F;细胞分裂最长时间

class Cell; 
priority_queue&lt;Cell&gt; cellQueue;


class Cell &#123;    &#x2F;&#x2F;细胞类
private:
    static int count;   &#x2F;&#x2F;细胞总数
    int id;             &#x2F;&#x2F;细胞编号
    int time;           &#x2F;&#x2F;细胞分裂时间
public:
    Cell(int birth) : id(count++) &#123; 
        &#x2F;*产生一定范围随机数的通用表示公式
        要取得 [a,b) 的随机整数，使用 (rand() % (b-a))+ a;

        要取得 [a,b] 的随机整数，使用 (rand() % (b-a+1))+ a;

        要取得 (a,b] 的随机整数，使用 (rand() % (b-a))+ a + 1;

        通用公式: a + rand() % n；其中的 a 是起始值，n 是整数的范围。

        要取得 a 到 b 之间的随机整数，另一种表示：a + (int)b * rand() &#x2F; (RAND_MAX + 1)
        *&#x2F;
        time &#x3D; birth + (rand() % (SPLIT_TIME_MAX - SPLIT_TIME_MIN)) + SPLIT_TIME_MIN; &#x2F;&#x2F;分裂时间在最短时间与最长时间之间
    &#125;
    int getId() const &#123; return id; &#125;            &#x2F;&#x2F;得到细胞编号
    int getSplitTime() const &#123; return time; &#125;   &#x2F;&#x2F;得到细胞分裂时间
    bool operator &lt; (const Cell&amp; s) const &#123; return time &gt; s.time; &#125; &#x2F;&#x2F;重载运算符 

    &#x2F;&#x2F;细胞分裂
    void split() const &#123;    
        Cell child1(time), child2(time);     &#x2F;&#x2F;建立两个子细胞
        cout &lt;&lt; time &lt;&lt; &quot;s: Cell #&quot; &lt;&lt; id &lt;&lt; &quot; splits to #&quot; 
            &lt;&lt; child1.getId() &lt;&lt; &quot; and #&quot; &lt;&lt; child2.getId() &lt;&lt; endl;
        cellQueue.push(child1); &#x2F;&#x2F;将第一个子细胞压入优先级队列
        cellQueue.push(child2); &#x2F;&#x2F;将第二个子细胞压入优先级队列
    &#125;
&#125;;
int Cell::count &#x3D; 0;

int main() &#123;
    srand(static_cast&lt;unsigned&gt;(time(0)));
    &#x2F;*使用当前时钟作为随机数种子
    rand() 产生的随机数在每次运行的时候都是与上一次相同的。若要不同, 用函数 srand() 初始化它。
    可以利用 srand((unsigned int)(time(NULL)) 的方法，产生不同的随机数种子，因为每一次运行程序的时间是不同的。
    *&#x2F;
    &#x2F;&#x2F;强制转换运算符 static_cast&lt;type&gt; (expr): static_cast 运算符执行非动态转换，没有运行时类检查来保证转换的安全性。例如，它可以用来把一个基类指针转换为派生类指针
    int t;  
    cout &lt;&lt; &quot;Simulation time: &quot;;
    cin &gt;&gt; t; &#x2F;&#x2F;模拟时间长度
    cellQueue.push(Cell(0));    
    while (cellQueue.top().getSplitTime() &lt;&#x3D; t) &#x2F;&#x2F;如果最先要弹出的细胞分裂时间在观察时间内 
    &#123;
        cellQueue.top().split();    &#x2F;&#x2F;模拟下一次细胞的分裂
        cellQueue.pop();            &#x2F;&#x2F;将刚刚分裂的细胞弹出
    &#125;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：<br>Simulation time: 5000<br>1042s: Cell #0 splits to #1 and #2<br>2336s: Cell #2 splits to #3 and #4<br>2673s: Cell #1 splits to #5 and #6<br>3004s: Cell #4 splits to #7 and #8<br>3329s: Cell #3 splits to #9 and #10<br>3647s: Cell #7 splits to #11 and #12<br>3979s: Cell #9 splits to #13 and #14<br>4190s: Cell #6 splits to #15 and #16<br>4265s: Cell #8 splits to #17 and #18<br>4305s: Cell #5 splits to #19 and #20<br>4613s: Cell #10 splits to #21 and #22<br>4782s: Cell #11 splits to #23 and #24<br>4810s: Cell #14 splits to #25 and #26</p>
<h4><span id="关联容器">关联容器</span></h4><p>关联容器的特点和接口<br>    每个关联容器都有一个键<br>    可以根据键高效的查找元素<br>接口<br>    插入：insert<br>    删除：erase<br>    查找：find<br>    定界：lower_bound ,upper_bound,equal_range<br>    计数：count</p>
<p>单重关联容器（set,map)<br>    键值是唯一的，一个键值只能对应一个元素<br>多重关联容器（multiset,multimap)<br>    键值是不唯一的，一个键值可以对应多个元素<br>简单关联容器（set,multiset)<br>    容器只有一个类型参数，如set<k>,multiset<k>，表示键类型<br>    容器的元素就是键本身<br>二元关联容器（map,multimap)<br>    容器有两个类型参数，如map&lt;K,V&gt;,multimap&lt;K,V&gt;<br>    分别表示键和附加数据类型<br>    容器的元素类型是pair&lt;K,V&gt;,即由键类型和元素类型复合而成的二元组</k></k></p>
<h5><span id="集合set">集合(set)</span></h5><p>集合用来存储一组无重复的元素。由于集合的元素本身是有序的，可以高效的查找指定元素，也可以方便的得到指定大小范围的元素在容器中所处的区间</p>
<p>例题：<br>输入一串实数，将重复的去掉，取最大和最小值的中值，分别输出小于等于此中值和大于等于此中值的实数</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;10_9.cpp
#include &lt;set&gt;
#include &lt;iterator&gt;
#include &lt;utility&gt;
&#x2F;*
头文件：#include &lt;utility&gt;
类
pair
函数
forward 保留引用类型（或者lvalue或rvalue) 参数从被遮掩完美转发。
get 获取从元素的函数pair对象。
make_pair 用于构造类型的对象的模板 helper 函数pair，其中的组件类型基于作为参数传递的数据类型。
move 返回传入参数作为rvalue的引用。
swap 交换两个 pair 对象的元素。
运算符
*&#x2F;
#include &lt;iostream&gt;
using namespace std;

int main() &#123;
    set&lt;double&gt; s;
    while (true) &#123;
        double v;
        cin &gt;&gt; v;
        if (v &#x3D;&#x3D; 0) break;  &#x2F;&#x2F;输入0终止
        &#x2F;*
        
        类模板：template&lt;class T1,class T2&gt; struct pair

        参数：T1是第一个值的数据类型，T2是第二个值的数据类型。

        功能：pair将一对值(T1和T2)组合成一个值，

        这一对值可以具有不同的数据类型（T1和T2），

        两个值可以分别用pair的两个公有函数first和second访问。
        *&#x2F;
        &#x2F;&#x2F;尝试将v插入
        pair&lt;set&lt;double&gt;::iterator, bool&gt; r &#x3D; s.insert(v);  

        if (!r.second)      &#x2F;&#x2F;如果v存在，输出提示信息
            cout &lt;&lt; v &lt;&lt; &quot; is duplicated&quot; &lt;&lt; endl;
    &#125;
    set&lt;double&gt;::iterator iter1 &#x3D; s.begin();    &#x2F;&#x2F;得到第一个元素的迭代器
    set&lt;double&gt;::iterator iter2 &#x3D; s.end();      &#x2F;&#x2F;得到末尾的迭代器
    double medium &#x3D; (*iter1 + *(--iter2)) &#x2F; 2;  &#x2F;&#x2F;因为末尾的指针指向的是尾元素结束的下一个位置，所以--
    &#x2F;&#x2F;输出小于或者等于中值的元素
    cout &lt;&lt; &quot;&lt;&#x3D; medium: &quot;;
    copy(s.begin(), s.upper_bound(medium), ostream_iterator&lt;double&gt;(cout, &quot; &quot;));
    cout &lt;&lt; endl;
    &#x2F;&#x2F;输出大于或等于中值的元素
    cout &lt;&lt; &quot;&gt;&#x3D; medium: &quot;;
    copy(s.lower_bound(medium), s.end(), ostream_iterator&lt;double&gt;(cout, &quot; &quot;));
    cout &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5><span id="映射map">映射（map）</span></h5><p>映射与集合同属于单重关联容器，他们的主要区别在于，集合的元素类型是键本身，而映射的元素类型是由键和附加数据所构成的二元组。<br>在集合中按照键查找一个元素时，一般只是用来确定这个元素是否存在，而在映射中按照键查找一个元素时，除了能确定它的存在性外，还可以得到相应的附加数据。</p>
<p>例题：<br>有五门课程，每门都有相应学分，从中选择三门，输出学分总和</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;utility&gt;
using namespace std;
int main()&#123;
    map&lt;string,int&gt;courses;
    &#x2F;&#x2F;将课程信息插入courses映射中
    courses.insert(make_pair(&quot;CSAPP&quot;,3));
    courses.insert(make_pair(&quot;C++&quot;,2));
    courses.insert(make_pair(&quot;CSARCH&quot;,4));
    courses.insert(make_pair(&quot;COMPLIER&quot;,4));
    courses.insert(make_pair(&quot;OS&quot;,5));
    int n &#x3D; 3;
    int sum &#x3D; 0;
    while(n&gt;0)&#123;
        string name; &#x2F;&#x2F;输入课程名称
        cin&gt;&gt;name;
        map&lt;string,int&gt;::iterator iter &#x3D; courses.find(name);&#x2F;&#x2F;查找课程
        if (iter &#x3D;&#x3D;course.end())   &#x2F;&#x2F;判断是否会找到 这里是未找到
        &#123;
            cout&lt;&lt;name&lt;&lt;&quot;is not available&quot;&lt;&lt;endl;
        &#125;
        else&#123;
            sum +&#x3D; iter-&gt;second; &#x2F;&#x2F;累加学分
            courses.erase(iter); &#x2F;&#x2F;将刚选过的课程从映射中删除
            n--;
        &#125;

        &#125;

    cout&lt;&lt;&quot;Total credit:&quot;&lt;&lt;sum&lt;&lt;endl;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行结果：<br>CSAPP<br>CSAPP<br>CSAPPis not available  因为每执行某个对象的操作后就将次对象从映射中删除 所以找不到<br>COMPLIER<br>CSARCH<br>Total credit:11</p>
<p>例题：统计一句话中每个字母出现的次数</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;cctype&gt;
&#x2F;*
cctype头文件用于字符检测

isalpha&#x2F;&#x2F;判断字符串是否为大小写字母
isupper&#x2F;&#x2F;判断字符串是否为大写字母
islower&#x2F;&#x2F;判断字符串是否为小写字母
tolower&#x2F;&#x2F;把大写字母转化为小写
toupper&#x2F;&#x2F;把小写字母转化为大写
*&#x2F;
using namespace std;
int main()&#123;
    map &lt;char,int&gt; s;
    char c;
    do&#123;
        cin&gt;&gt;c;
        if (isalpha(c))&#123; &#x2F;&#x2F;判断是否为字母
            c &#x3D; tolower(c); &#x2F;&#x2F;将字母转换为小写
            s[c]++; &#x2F;&#x2F;将该字母的出现频率+1
        &#125;
    &#125;
    while(c!&#x3D;&#39;.&#39;); &#x2F;&#x2F;碰到&quot;.&quot;则结束输入
    &#x2F;&#x2F;则输出每个字母出现次数
    for(map&lt;char,int&gt;::iterator iter &#x3D; s.begin();iter!&#x3D; s.end();++iter)
        cout&lt;&lt;iter-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;iter-&gt;second&lt;&lt;&quot; &quot;;
    cout&lt;&lt;endl;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++进阶笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>深层学习疑难知识点</title>
    <url>/2021/03/30/%E6%B7%B1%E5%B1%82%E5%AD%A6%E4%B9%A0%E7%96%91%E9%9A%BE%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>有关深层学习的疑难知识点<br>self含义<br><strong>init</strong> 方法的第一个参数永远是 self ，表示创建的实例本身，因此，在 <strong>init</strong> 方法的内部，就可以把各种属性绑定到 self，因为 self 就指向创建的实例本身。<br>使用了 <strong>init</strong> 方法，在创建实例的时候就不能传入空的参数了，必须传入与 <strong>init</strong> 方法匹配的参数，<br>但是 self 不需要传，python解释器会自己把实例变量传进去。自动调用构造函数。</p>
<pre class="line-numbers language-none"><code class="language-none">
class Student():
    name &#x3D; &#39;&#39;
    age &#x3D; 0
    def __init__(self,age,num):
        #   它是构造函数
        print(&#39;student&#39;)
    #行为     与   特征
    def do_homework(self):
        print(&#39;homework&#39;)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>student1 = Student()<br>student1.<strong>init</strong>()</p>
<p>()的意义<br>类有一个名为 <strong>init</strong>() 的特殊方法（构造方法），该方法在类实例化时会自动调用，像下面这样：</p>
<p>def <strong>init</strong>(self):<br>    self.data = []</p>
<p>类定义了 <strong>init</strong>() 方法，类的实例化操作会自动调用 <strong>init</strong>() 方法。<br>如下实例化类 MyClass，对应的 <strong>init</strong>() 方法就会被调用:<br>x = MyClass()<br>self代表类的实例，而非类</p>
<p>类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响； 方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据； 通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。</p>
<p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。</p>
<p>optimizer理解</p>
<p>step这个函数使用的是参数空间(param_groups)中的grad,也就是当前参数空间对应的梯度，这也就解释了为什么optimzier使用之前需要zero清零一下，因为如果不清零，那么使用的这个grad就得同上一个mini-batch有关，这不是我们需要的结果。再回过头来看，我们知道optimizer更新参数空间需要基于反向梯度，因此，当调用optimizer.step()的时候应当是loss.backward()的时候</p>
<pre class="line-numbers language-none"><code class="language-none">def step(self, closure&#x3D;None):
    &quot;&quot;&quot;Performs a single optimization step.

    Arguments:
        closure (callable, optional): A closure that reevaluates the model
            and returns the loss.
    &quot;&quot;&quot;
    loss &#x3D; None
    if closure is not None:
        loss &#x3D; closure()

    for group in self.param_groups:
        for p in group[&#39;params&#39;]:
            if p.grad is None:
                continue
            grad &#x3D; p.grad.data  #.data——获得该节点的值，即Tensor类型的值
                                #.grad——获得该节点处的梯度信息
            if grad.is_sparse:
                raise RuntimeError(&#39;Adam does not support sparse gradients, &#39;
                                    &#39;please consider SparseAdam instead&#39;)
            amsgrad &#x3D; group[&#39;amsgrad&#39;]

            state &#x3D; self.state[p]

            # State initialization
            if len(state) &#x3D;&#x3D; 0:
                state[&#39;step&#39;] &#x3D; 0
                # Exponential moving average of gradient values
                state[&#39;exp_avg&#39;] &#x3D; torch.zeros_like(p.data)
                # Exponential moving average of squared gradient values
                state[&#39;exp_avg_sq&#39;] &#x3D; torch.zeros_like(p.data)
                if amsgrad:
                    # Maintains max of all exp. moving avg. of sq. grad. values
                    state[&#39;max_exp_avg_sq&#39;] &#x3D; torch.zeros_like(p.data)

            exp_avg, exp_avg_sq &#x3D; state[&#39;exp_avg&#39;], state[&#39;exp_avg_sq&#39;]
            if amsgrad:
                max_exp_avg_sq &#x3D; state[&#39;max_exp_avg_sq&#39;]
            beta1, beta2 &#x3D; group[&#39;betas&#39;]

            state[&#39;step&#39;] +&#x3D; 1
            bias_correction1 &#x3D; 1 - beta1 ** state[&#39;step&#39;]
            bias_correction2 &#x3D; 1 - beta2 ** state[&#39;step&#39;]

            if group[&#39;weight_decay&#39;] !&#x3D; 0:
                grad.add_(group[&#39;weight_decay&#39;], p.data)

            # Decay the first and second moment running average coefficient
            exp_avg.mul_(beta1).add_(1 - beta1, grad)
            exp_avg_sq.mul_(beta2).addcmul_(1 - beta2, grad, grad)
            if amsgrad:
                # Maintains the maximum of all 2nd moment running avg. till now
                torch.max(max_exp_avg_sq, exp_avg_sq, out&#x3D;max_exp_avg_sq)
                # Use the max. for normalizing running avg. of gradient
                denom &#x3D; (max_exp_avg_sq.sqrt() &#x2F; math.sqrt(bias_correction2)).add_(group[&#39;eps&#39;])
            else:
                denom &#x3D; (exp_avg_sq.sqrt() &#x2F; math.sqrt(bias_correction2)).add_(group[&#39;eps&#39;])

            step_size &#x3D; group[&#39;lr&#39;] &#x2F; bias_correction1

            p.data.addcdiv_(-step_size, exp_avg, denom)

    return loss<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在optimizer的step函数的内部，只使用gradients来更新参数，根本不使用参数本身的值（除了weight decay，但我们将在外围处理）。然后我们可以在optimizer处理之前，简单地执行权重衰减。在计算梯度之后仍然必须进行相同操作（否则会影响gradients值），所以在训练循环中，你必须找到这个位置。</p>
<pre class="line-numbers language-none"><code class="language-none">loss.backward()

#Do the weight decay here!

optimizer.step()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，optimizer应该设置为wd = 0，否则它会进行L2正则化，这正是我们现在不想要的。现在，在那个位置，我们必须循环所有参数，并做weight decay更新。你的参数应该都在optimizer的字典param_groups中，因此循环看起来像这样：</p>
<pre class="line-numbers language-none"><code class="language-none">loss.backward()

for group in optimizer.param_groups():

for param in group[&#39;params&#39;]:

param.data &#x3D; param.data.add(-wd * group[&#39;lr&#39;], param.data)

optimizer.step()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>闭包函数<br>闭包函数：<br>如果一个函数定义在另一个函数的作用域内，并且引用了外层函数的变量，则该函数称为闭包。闭包是Python所支持的一种特性，它让在非global scope定义的函数可以引用其外围空间中的变量，这些外围空间中被引用的变量叫做这个函数的环境变量。环境变量和这个非全局函数一起构成了闭包。</p>
<pre class="line-numbers language-none"><code class="language-none">def line_conf(a, b):
    def line(x):
        return a * x + b
    return line<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>嵌套函数line中的代码访问了a和b变量，line本身函数体内并不存在这两个变量，所以会逐级向外查找，往上走一层就找到了来自主函数line_conf传递的a, b。若往外直至全局作用域都查找不到的话代码会抛异常。</p>
<pre class="line-numbers language-none"><code class="language-none">line_A &#x3D; line_conf(2, 1) #y&#x3D;2x+b
line_B &#x3D; line_conf(3, 2) #y&#x3D;3x+2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>打印x对应y的值<br>print(line_A(1)) #3<br>print(line_B(1)) #5</p>
<p>内包的语法为</p>
<pre class="line-numbers language-none"><code class="language-none">def 父函数(参数):             #这里的参数外部传递给子函数作其函数参数
    def 子函数（参数）：  #这里的参数为外部传递给子函数作其自变量额值
        fuction
    return  子函数值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>调用语法：</p>
<p>变量=父函数（赋给子函数的参数）<br>result=变量（子函数自变量的值）<br>result的值为子函数的计算值</p>
<p>！！当闭包执行完后，仍然能够保持住当前的运行环境。<br>这里每次经过权重更新后得到的新的参数</p>
<p>zip的使用方法<br>zip 方法在 Python 2 和 Python 3 中的不同：在 Python 3.x 中为了减少内存，zip() 返回的是一个对象。如需展示列表，需手动 list() 转换。<br>zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。<br>这里* 单独就可以看作一个解压的步骤，将列表中的元素提出<br>zip按照对应关系一一打包</p>
<p>mask<br>这里的non_final_mask是判断下一步状态是否存在的索引<br>state_batch 是四个元素<br>action_batch 是一个元素<br>决定每一步的动作时<br>如果时根据Q价值最大选择<br>则：<br>action的决定取决于decide_action，每走一步更新一下决定下一步的action，并且记录下来形成action_batch?<br>否则：<br>随机选择<br>no_final_mask中元素为0时，则next_state_values不存在<br>self.model(state_batch)最后经过神经网络输出的是两个结果，分别对应向左和向右移动的Q值</p>
<p>gather函数<br>c = a.gather(0, b) # dim=0    索引b按照矩阵a的每一列去寻找<br>d = a.gather(1, b) # dim=1      索引b按照矩阵a的每一行去寻找</p>
<p>expected_state_value<br>相当于qtable<br>loss损失函数去计算state_value和expected_state_value的差值 </p>
<p>super() 函数是用于调用父类(超类)的一个方法。</p>
<p>super() 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。<br>super(type[, object-or-type])<br>type – 类<br>object-or-type – 类，一般是 self</p>
<pre class="line-numbers language-none"><code class="language-none">class A:
     def add(self, x):
         y &#x3D; x+1
         print(y)
class B(A):
    def add(self, x):
        super().add(x)
b &#x3D; B()
b.add(2)  # 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>np.squeeze（）函数用法：</p>
<p>np.squeeze（）函数可以删除数组形状中的单维度条目，即把shape中为1的维度去掉，但是对非单维的维度不起作用。<br>作用：从数组的形状中删除单维度条目，即把shape中为1的维度去掉<br>场景：在机器学习和深度学习中，通常算法的结果是可以表示向量的数组（即包含两对或以上的方括号形式[[]]），如果直接利用这个数组进行画图可能显示界面为空（见后面的示例）。我们可以利用squeeze（）函数将表示向量的数组转换为秩为1的数组，这样利用matplotlib库函数画图时，就可以正常的显示结果了。</p>
<p>greedy方法</p>
<p>最简单的exploration方法就是epsilon-greedy，即设置一个探索率epsilon来平衡两者的关系——在大部分时间里采用现阶段最优策略，在少部分时间里实现探索。<br>什么是贪婪算法? 简单说,就是,任何时候的决策,都是选择当前观察的最优解,而没有整体长远的规划.<br>贪婪算法的优点是容易理解,简单快速.但缺点是,得到的往往是局部最优解,而不是全局最优.</p>
<p>贪婪算法是如何在“exploit”和“explore”之间实现权衡，以尽可能实现最大化收益的呢？ 首先，从算法的名称我们知道，这是一种贪婪的算法。<br>纯粹贪婪的算法，放到这种多臂老虎机的场景来看就是每次都选择当前那个最好的臂摇，即使从长远来看可能非常不好。那么，ϵϵ-贪婪算法和贪婪算法的区别在哪呢？<br>就像它的名字所展示的那样，区别仅仅就在这个ϵ。这个ϵ代表执行执行“探索”的概率。比如设置ϵ=0.1，那么就表示有10%的概率会进行“探索”操作，<br>而90%会进行“利用”操作，也就是摇当前最好的臂。如果以摇老虎机臂的过程，用次数来算的话，也就是，每10次操作，仅有1次操作去进行探索——尝试其他的臂。</p>
<p>若当前随机产生的0-1的浮点数大于当前的贪婪参数epsilon，则随机决策产生动作。反之则由训练网络net产生Q值并选择最大Q值的动作。</p>
<p>1、ϵ设置的越高，收敛到最佳收益的速度越快。这个很好理解。随机探索的概率越大，越能更快的探索到最好的臂。<br>2、在0.1-0.5，ϵ设置的越低，最终的平均收益越高。这个也是比较好理解的。每次都很大概率的随机探索，就会存在很多利用效果不好的臂的情况。</p>
<p>一个状态的Q值 = （当前状态进行某一个动作a进行到下一个状态的价值 + 时间折扣 * 采取某一行动a到下一个状态的Q值）<br>state_action_value<br>expected_state_action_value</p>
<p>state_action_value<br>从当前状态s实际执行动作a走到下一步s+1 所获得推测eval Q值</p>
<p>若当前状态s所对应的下一个状态s+1存在 </p>
<p>nn.Linear<br>linear 的初始化部分代码<br>y=Ax+b<br>y = xA^T +b</p>
<pre class="line-numbers language-none"><code class="language-none">class Linear(Module):
    ...
    __constants__ &#x3D; [&#39;bias&#39;]
    
    def __init__(self, in_features, out_features, bias&#x3D;True):
        super(Linear, self).__init__()
        self.in_features &#x3D; in_features
        self.out_features &#x3D; out_features
        self.weight &#x3D; Parameter(torch.Tensor(out_features, in_features))
        if bias:
            self.bias &#x3D; Parameter(torch.Tensor(out_features))
        else:
            self.register_parameter(&#39;bias&#39;, None)
        self.reset_parameters()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>示例</p>
<pre class="line-numbers language-none"><code class="language-none">import torch
nn1 &#x3D; torch.nn.Linear(100, 50)
input1 &#x3D; torch.randn(140, 100)
output1 &#x3D; nn1(input1)
output1.size()
torch.Size([140, 50])
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里weight = [out_features,in_features]<br>A 是weight<br>具体计算为[140,100] × [50,100]的转置 + bias = [140,100] × [100,50] + bias 最后得到的维度为[140,50]。<br>至于对于bias和weight的初始化，根据网上所讲的是来有关维度值的均匀分布</p>
<p>forward<br>我们在定义自已的网络的时候，需要继承nn.Module类，并重新实现构造函数__init__和forward这两个方法。但有一些注意技巧：</p>
<p>（1）一般把网络中具有可学习参数的层（如全连接层、卷积层等）放在构造函数<strong>init</strong>()中，当然我也可以把不具有参数的层也放在里面；</p>
<p>（2）一般把不具有可学习参数的层(如ReLU、dropout、BatchNormanation层)可放在构造函数中，也可不放在构造函数中，如果不放在构造函数__init__里面，则在forward方法里面可以使用nn.functional来代替</p>
<p>（3）forward方法是必须要重写的，它是实现模型的功能，实现各个层之间的连接关系的核心。</p>
<p>拿线性变化举例，其中的权重需要不停的更新，这就是需要维持的状态，<br>而以激活函数来说，一般来说都是可以直接使用的，<br>只要给定相应的输入，那么使用后就有确定的输出。</p>
<h2><span id="linear的计算方式">linear的计算方式，</span></h2><p>就是权重矩阵W乘以输入矩阵X，然后加上偏置项b，即Wx+b。</p>
<h2><span id="fc1x的调用流程">fc1(x)的调用流程</span></h2><p>Python中可以在一个类中定义__call__方法来让一个类的实例对象直接调用这个函数。也就是说比如我下面这段程序：</p>
<p>class A():<br>def <strong>init</strong>(self, n):<br>self.n = n</p>
<p>def <strong>call</strong>(self, x):<br>return self.n + x</p>
<p>调用A(3)(5)的结果就是8。由于nn.Linear是module是子类，然后module又定义了__call__方法来隐式的调用了forward，所以fc1(x)实质上就等价于fc1.forward(x)。</p>
<p>nn.module<br>输出权重和bias的方法</p>
<pre class="line-numbers language-none"><code class="language-none">print(&quot;self.fc1.weight&quot;)
print(self.fc1.weight.t(),self.fc1.bias)
print(&quot;self.fc2.weight&quot;)
print(self.fc2.weight,self.fc1.bias)
print(&quot;self.fc3.weight&quot;)
print(self.fc3.weight,self.fc1.bias)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2><span id="权重更新">权重更新</span></h2><p>每个episode之间权重参数相互关联<br>main_q_main_network和target_q_network在初始化的时候权重参数不同<br>每进行两次episode试错后，将main_q_network的参数传递给target网络</p>
<p>DQN</p>
<p>DDQN的逻辑<br>从理论上说，这种方法不能完全减少overestimate，只能减少一部分。但经过数值实验，人们发现上述的改变对于overestimate的减少还是非常可观的。由于其与一般DQN（fixed Q-target）相比几乎没有产生新的成本，所以DDQN也成为了目前DQN训练的必备技术之一。</p>
<h2><span id="bellman-equation">bellman equation</span></h2><p>贝尔曼方程：当前状态的价值和下一步的价值及当前的奖励<br>价值函数分解为当前奖励（离开当前状态的即时价值）和下一步的价值两部分<br>当前状态的价值函数  =<br>当前状态根据策略（概率）进行下一步动作时所获得的价值<br>+<br>根据某一策略（概率）达到下一个状态，下一个状态的价值函数 * discount</p>
<p>我们如何知道它后继状态的value funciton为0.8，10。其实这些值一开始可以任意初始化，<br>后面可以学习更新，就类似于神经网络的权值参数，一开始任意初始化，后面通过loss反向更新一样。<br><a href="https://zhuanlan.zhihu.com/p/35261164">https://zhuanlan.zhihu.com/p/35261164</a><br>即 [Vπ(s)] 为 [Qπ(s,a)] 在策略 [π(a|s)] 下的和 (所有动作下的期望价值)<br><a href="https://www.zhihu.com/question/59122948">https://www.zhihu.com/question/59122948</a></p>
<p>神经网络<br>线性方程：f = Wx<br>非线性方程：f = W2xmax(0,W1x)<br>这里的max相当于一个激活函数</p>
<h2><span id="激活函数">激活函数</span></h2><h2><span id="sigmoid">sigmoid</span></h2><p>某些数据是线性不可分的，所以需要激活函数去非线性分割数据<br>在每一层输出的时候都需要激活函数，去达到非线性表达<br>问题：<br>看梯度变化，求导<br>当存在多层隐藏层的神经网络，会达到梯度消失<br>w1   w2    w3     w4   loss<br>0.01 0.1   0.3    0.5</p>
<h2><span id="relu">RELU</span></h2><p>ReLU处理了它的sigmoid、tanh中常见的梯度消失问题，<br>同时也是计算梯度最快的激励函数。</p>
<p>所以目前sigmoid不用，开始使用RELU<br>tanh</p>
<h2><span id="过拟合">过拟合</span></h2><p>正则化项在神经网络中的重要作用<br>L2正则化惩罚项    λW^2<br>实际预测过程中泛化越强越好<br>越多的神经元，越能够表达复杂的模型</p>
<h2><span id="初始化">初始化</span></h2><p>权重初始化为随机初始化<br>bias初始化可为0，可为1</p>
<p>##dropout<br>全连接操作<br>dropout随机选择<br>保留率60%<br>去掉40%<br>迭代的时候，去随机选择<br>去降低过拟合的风险</p>
<h2><span id="bacthsize">bacthsize</span></h2><p>每次取样品的大小<br>数值越大越好，<br>性能好的话64,128.<br>一般的16，32.<br>取决于计算机的性能。显存大小。</p>
<h2><span id="学习率">学习率</span></h2><p>学习率设置过高可能导致在用梯度损失更新梯度后获得的是极小值，而不是最小值</p>
<h2><span id="卷积神经网络">卷积神经网络</span></h2><p>卷积神经网络的组成<br>输入层<br>卷积层<br>激活函数<br>池化层<br>全连接层</p>
<h3><span id="卷积层">卷积层</span></h3><p>filter帮助进行信息的提取<br>将输入划分成一个个小区域，提取每一个区域获得一个数值。<br>经过卷积层之后获得特征图。<br>32* 32 * 3 image<br>5* 5* 3 filter<br>提取的数据X和filter对应的W 做内积操作 +bias<br>卷积之后都需要采取激活函数，进行非线性转化</p>
<h3><span id="stride-滑动">stride 滑动</span></h3><p>stride的数值越大，会获得较小的特征图。<br>为了获得更多的特征，需要让stride值变小。为了效率不能取太小。</p>
<h3><span id="padding">padding</span></h3><p>防止边缘数据提取次数过少</p>
<p>在原始的输入像5* 5 * 3四周加了两圈0 变成7 * 7 * 3<br>输入 = 7 * 7<br>Filter = 3* 3<br>Pad = 1<br>Output = ？</p>
<p>height out = height in - height kernel +2* padding / stride  +1<br>width out = width in - width kernel +2* padding / stride  +1</p>
<h3><span id="池化层pooling-layer">池化层pooling layer</span></h3><p>对于特征图进行的操作<br>压缩特征图<br>对于filter size内的特征数据进行下面两种操作<br>mean<br>max<br>-2+0.8* 4.3 +0</p>
<h3><span id="神经元死亡bias的更新">神经元死亡bias的更新</span></h3><p>神经元在训练过程中的“死亡”，通常是学习率过大造成的。</p>
<p>这个神经元已经经过若干次迭代，其参数 (w⃗ ,b) 已经迭代得趋于稳定。<br>现在，神经元接收到了一个异常输入 x⃗ 。比方说，它的某一维特征 xi 与对应的权重 wi 的乘积 wixi 非常大。<br>一般来说，这意味着 xi 的绝对值非常大。于是，ReLU 的输入就会很大，对应 ReLU 的输出 y 也就会很大。好了，假设这个 ReLU 神经元期望的输出（ground truth）是 y^，这个时候损失就会很大——损失一般是 |y−y^| 的增函数，记为 f(|y−y^|)。<br>解答：<br>这里当输入一个异常x，会导致输出远远大于期望y值，在反向传播过程中，会因为此次异常数据X，而降低权重w，<br>但更新权重的时候根据学习率部分更新。bias的系数为1.b的变化直接映射到loss的变化。当异常数据导致relu的输出足够大的时候，<br>bias会变成一个负数。</p>
<h3><span id="duelingwork">duelingwork</span></h3><p>Dueling的这种结构的优势在于学习效率，Value[V(s)]的更新将会触及到所有的动作跟着<br>value[V(s)]一起更新，如果是Q的话，你只能更新当前状态下的状态-动作值函数。</p>
<h3><span id="td-error">TD-error</span></h3><p>常将 rt+γ⋅Qπ(st+1,at+1) 的值记作 yt 。<br>因为 yt 中包含了真实的奖励值 rt ，所以认为 yt 比 Qπ(st,at) 更准确。<br>将 yt 命名为 TD target，而将 yt−Qπ(st,at) 的值命名为 TD error。<br>TD error 的绝对值越小，就表明模型预测误差越小，预测的结果越准确。所以，在确定好 TD error 的计算方式后，可以通过 梯度下降 方法来更新模型的参数，降低 TD error 。<br>时序差分学习的目的是让模型预测出的 Qπ(st,at) 值不断的接近TD target 。</p>
<h2><span id="梯度裁剪">梯度裁剪</span></h2><p>torch.nn.utils.clip_grad_norm_(parameters, max_norm, norm_type=2)<br>parameters (Iterable[Tensor] 或 Tensor) —— 一个由张量或单个张量组成的可迭代对象（模型参数），将梯度归一化（原文： an iterable of Tensors or a single Tensor that will have gradients normalized）<br>max_norm (float or int) – 梯度的最大范数（原文：max norm of the gradients）<br>norm_type (float or int) – 所使用的范数类型。默认为L2范数，可以是无穷大范数（‘inf’）（原文：type of the used p-norm. Can be for infinity norm.‘inf’）</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>算法面试4-栈</title>
    <url>/2021/04/04/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%954-%E6%A0%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>算法4<br>栈和队列的使用</p>
<h2><span id="栈的基础使用">栈的基础使用</span></h2><p>例题20：Valid Parentheses<br>给定一个字符串，只包含(,{,[,],},),判定字符串中的括号匹配是否合法<br>如（}不合法</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;stack&gt;
#include&lt;string&gt;
#include&lt;cassert&gt;
#include&lt;iostream&gt;
using namespace std;
class Solution&#123;
public:
    bool isValid(string s)
    &#123;
        stack&lt;char&gt;stack;
        for(int i&#x3D; 0;i&lt;s.size();i++)
        &#123;
            if(s[i] &#x3D;&#x3D; &#39;(&#39;||s[i]&#x3D;&#x3D;&#39;&#123;&#39;||s[i] &#x3D;&#x3D; &#39;[&#39;)
                stack.push(s[i]);
            else
            &#123;
                if(stack.size()&#x3D;&#x3D;0 )
                    return false;
                char c &#x3D; stack.top();&#x2F;&#x2F;将栈顶元素存储
                stack.pop();&#x2F;&#x2F;将栈顶元素推出
            
                char match;
                if(s[i] &#x3D;&#x3D; &#39;)&#39;)
                    match &#x3D; &#39;(&#39;;
                else if(s[i] &#x3D;&#x3D; &#39;]&#39;)
                    match &#x3D; &#39;[&#39;;
                else&#123;
                    assert (s[i] &#x3D;&#x3D; &#39;&#125;&#39;);
                    match &#x3D; &#39;&#123;&#39;;
                &#125;
                if(c !&#x3D; match)
                    return false;
            &#125;
        &#125;
        if(stack.size() !&#x3D; 0)
            return false;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题150： Evaluate Reverse polish Notation<br>给定一个数组逆波兰表达式求值</p>
<p>例题71： Simplify path<br>给定一个unix系统下的路径，简化这个路径<br>如/home/ 简化后/home<br>如/a/./b/../../c/ 简化后为/c</p>
<ul>
<li>给定路径是否一定合法</li>
<li>不能回退的情况？（如/../,返回/)</li>
<li>多余的/?</li>
</ul>
<h2><span id="栈和递归的紧密联系">栈和递归的紧密联系</span></h2><p>例题144：Binary Tree Preorder Traversal</p>
<pre class="line-numbers language-none"><code class="language-none">void preorder(TreeNode *node)&#123;
    if(node)&#123;
        cout&lt;&lt;node-&gt;val;
        preorder(node-&gt;left);
        preorder(node-&gt;right);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用栈模拟系统栈，写出非递归程序</p>
<h3><span id="前序遍历">前序遍历</span></h3><p>先打印，再访问左孩子，再访问右孩子</p>
<pre class="line-numbers language-none"><code class="language-none">struct TreeNode&#123;
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x):val(x),left(NULL),right(NULL)&#123;&#125;
&#125;
struct Command&#123;
    string s; &#x2F;&#x2F;go,print
    TreeNode *node;
    Command(string s,TreeNode *node):s(s),node(node)&#123;&#125; 
    &#x2F;&#x2F;构造函数 然后s(s)和node(node)去初始化
&#125;;
class Solution&#123;
public:
    vector&lt;int&gt;preorderTraversal(TreeNode *root)&#123;

        vector&lt;int&gt;res;
        if(root &#x3D;&#x3D; NULL)
            return res;

        stack &lt;Command&gt; stack;
        stack.push(Command(&quot;go&quot;,root));
        while(!stack.empty())&#123;
            Command command &#x3D; stack.top();
            stack.pop();
            &#x2F;&#x2F;分析栈顶推出的元素command
            if(command.s &#x3D;&#x3D; &quot;print&quot;)
                res.push_back(command.node-&gt;val);
            else&#123;
                assert(command.s &#x3D;&#x3D; &quot;go&quot;);
                if(command.node-&gt;right) &#x2F;&#x2F;判断当前节点的子节点右孩子是否存在
                    stack.push(Command(&quot;go&quot;,command.node-&gt;right));
                if(command.node-&gt;left) &#x2F;&#x2F;判断当前节点的子节点右孩子是否存在
                    stack.push(Command(&quot;go&quot;,command.node-&gt;left));
                &#x2F;&#x2F;输出按照先输出左再输出右，则压入的时候先压入右再压入左

                stack.push(Command(&quot;print&quot;,command.node));

            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="中序遍历">中序遍历</span></h3><p>先访问左孩子 再打印节点 再访问右孩子<br>所以三条命令反向压入栈中<br>右孩子-&gt;打印-&gt;左孩子</p>
<pre class="line-numbers language-none"><code class="language-none">struct Command&#123;
    string s; &#x2F;&#x2F;go,print
    TreeNode *node;
    Command(string s,TreeNode *node):s(s),node(node)&#123;&#125; 
    &#x2F;&#x2F;构造函数 然后s(s)和node(node)去初始化
&#125;;
class Solution&#123;
public:
    vector&lt;int&gt;inorderTraversal(TreeNode *root)&#123;

        vector&lt;int&gt;res;
        if(root &#x3D;&#x3D; NULL)
            return res;

        stack &lt;Command&gt; stack;
        stack.push(Command(&quot;go&quot;,root));
        while(!stack.empty())&#123;
            Command command &#x3D; stack.top();
            stack.pop();
            &#x2F;&#x2F;分析栈顶推出的元素command
            if(command.s &#x3D;&#x3D; &quot;print&quot;)
                res.push_back(command.node-&gt;val);
            else&#123;
                assert(command.s &#x3D;&#x3D; &quot;go&quot;);
                if(command.node-&gt;right) &#x2F;&#x2F;判断当前节点的子节点右孩子是否存在
                    stack.push(Command(&quot;go&quot;,command.node-&gt;right));
                stack.push(Command(&quot;print&quot;,command.node));
                if(command.node-&gt;left) &#x2F;&#x2F;判断当前节点的子节点右孩子是否存在
                    stack.push(Command(&quot;go&quot;,command.node-&gt;left));
                &#x2F;&#x2F;输出按照先输出左再输出右，则压入的时候先压入右再压入左


            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="后序遍历">后序遍历</span></h3><p>先访问左孩子，再访问右孩子，再打印</p>
<pre class="line-numbers language-none"><code class="language-none">struct Command&#123;
    string s; &#x2F;&#x2F;go,print
    TreeNode *node;
    Command(string s,TreeNode *node):s(s),node(node)&#123;&#125; 
    &#x2F;&#x2F;构造函数 然后s(s)和node(node)去初始化
&#125;;
class Solution&#123;
public:
    vector&lt;int&gt;postorderTraversal(TreeNode *root)&#123;

        vector&lt;int&gt;res;
        if(root &#x3D;&#x3D; NULL)
            return res;

        stack &lt;Command&gt; stack;
        stack.push(Command(&quot;go&quot;,root));
        while(!stack.empty())&#123;
            Command command &#x3D; stack.top();
            stack.pop();
            &#x2F;&#x2F;分析栈顶推出的元素command
            if(command.s &#x3D;&#x3D; &quot;print&quot;)
                res.push_back(command.node-&gt;val);
            else&#123;
                assert(command.s &#x3D;&#x3D; &quot;go&quot;);
                stack.push(Command(&quot;print&quot;,command.node));
                if(command.node-&gt;right) &#x2F;&#x2F;判断当前节点的子节点右孩子是否存在
                    stack.push(Command(&quot;go&quot;,command.node-&gt;right));
                if(command.node-&gt;left) &#x2F;&#x2F;判断当前节点的子节点右孩子是否存在
                    stack.push(Command(&quot;go&quot;,command.node-&gt;left));
                &#x2F;&#x2F;输出按照先输出左再输出右，则压入的时候先压入右再压入左


            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题 341：<br>给出一个嵌套的整型列表。列表中的项或者为一个整数，或许是另一个列表。设计一个<br>迭代器，遍历这个整型列表中的所有整数<br>如[[1,1],2,[1,1]]<br>如[1,[4,[6]]]</p>
<p>hasNext()为true的情况下，不断调用next()，依次获得元素</p>
<pre class="line-numbers language-none"><code class="language-none">class NestedInteger&#123;
    public:
    bool isInteger()const;&#x2F;&#x2F;判断是否为整型
    int getInteger()const;&#x2F;&#x2F;获得整型的值
    const vector&lt;NestedInteger&gt;&amp;getlist()const;
&#125;
class NestedIterator&#123;
    public:
    NestedIterator(vector&lt;NestedInteger&gt;&amp;nestedList)&#123; &#125;
    int next()&#123; &#125;
    bool hasNext()&#123; &#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="队列-queue">队列 Queue</span></h2><p>队列的基本应用-广度优先遍历<br>-树：层序遍历<br>-图：无权图的最短路径</p>
<h3><span id="层序遍历">层序遍历</span></h3><p>例题102：<br>对于一个二叉树进行层序遍历</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution&#123;
public:
    vector&lt;vector&lt;int&gt;&gt;levelOrder(TreeNode *root)&#123;

        vector&lt;vector&lt;int&gt;&gt;res;
        if(root &#x3D;&#x3D; NULL)
            return res;
        queue&lt; pair&lt;TreeNode*,int&gt; &gt;q;
        q.push(make_pair(root,0));
        while(!q.empty())&#123;
            TreeNode * node &#x3D; q.front().first; &#x2F;&#x2F;相应节点
            int level &#x3D; q.front().second; &#x2F;&#x2F;所处层级
            q.pop();
            if(level &gt;&#x3D; res.size()) &#x2F;&#x2F;弹出的这个元素的这个节点在新的层中
                res.push_back(vector&lt;int&gt;());
            res[level].push_back(node-&gt;val);&#x2F;&#x2F;当level&gt;res.size()的时候，添加一个向量，然后将节点的值放进去
            if(node-&gt;left)
                q.push(make_pair(node-&gt;left,level+1));
            if(node-&gt;right)
                q.push(make_pair(node-&gt;right,level+1));
        &#125;

        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>例题103<br>对一个二叉树进行层序遍历，按照“之”字型的顺序返回所有节点</p>
<p>例题199<br>想象你站在一棵二叉树的右侧，返回你能看见的节点</p>
<h3><span id="bfs和图的最短路径">BFS和图的最短路径</span></h3><p>例题279<br>给出一个正整数n，寻找最少的完全平方数，使得他们的和为n</p>
<p>完全平方数：1，4，9，16<br>12=4+4+4<br>13=4+9<br>-不可能没有解，因为存在1<br>12=9+1+1+1<br>12=4+4+4</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
public:
    int numSquares(int n)&#123;
        assert(n&gt;0);
        queue&lt;pair&lt;int,int&gt;&gt; q;
        q.push(make_pair(n,0)); &#x2F;&#x2F;初始化

        while(!q.empty())&#123;
            int num &#x3D; q.front().first;
            int step &#x3D; q.front().second;
            q.pop();
            if(num &#x3D;&#x3D; 0)
                return step;
            for(int i &#x3D;1;num-i*i&gt;&#x3D;0;i++) 
            &#x2F;&#x2F;某一个数可以从多种途径获得，造成冗余
            &#x2F;&#x2F;因为这是一个图而不是树
                q.push(make_pair(num-i*i,step+1));
        &#125;
        throw invalid_argument(&quot;No Solution.&quot;);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="bfs广度优先搜索">BFS广度优先搜索</span></h2><p>讲解：<br>深度优先搜索要尽可能的远离起始点，而广度优先搜索则要尽可能的靠近起始点，<br>它首先访问起始顶点的所有邻接点，然后再访问较远的区域，这种搜索不能用栈实现，<br>而是用队列实现。</p>
<p>规则1：访问下一个未访问的邻接点（如果存在），这个顶点必须是当前顶点的邻接点，<br>标记它，并把它插入到队列中。</p>
<p>规则2：如果已经没有未访问的邻接点而不能执行规则 1 时，那么从队列列头取出一个顶点（如果存在），并使其成为当前顶点。</p>
<p>规则3：如果因为队列为空而不能执行规则 2，则搜索结束。<br>上述代码在实现过程中数值num-i* i的数值可能存在多种途径获得<br>通过画图可以加深理解</p>
<p>算法优化，解决冗杂问题。<br>这个问题的重点在于<br>队列实现BFS(广度优先搜索)<br>在入队过程中，只有未被访问过的数值可以入队，防止重复入队<br>这里最短路径的获取：<br>在队列中，如果某一个路径优先使num-i* i的值达到0，则该数字0优先入队，在取出的时候，返回该数字对应的step值</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
public:
    int numSquares(int n)&#123;
        assert(n&gt;0);
        queue&lt;pair&lt;int,int&gt;&gt; q;
        q.push(make_pair(n,0)); &#x2F;&#x2F;初始化
        vector&lt;bool&gt; visited(n+1,false); &#x2F;&#x2F;初始的n+1个元素均没有被访问
        visited[n] &#x3D; true;  &#x2F;&#x2F;最初压入的n存在了，所以这里将其设为true，说明被访问过

        while(!q.empty())&#123;
            int num &#x3D; q.front().first;
            int step &#x3D; q.front().second;
            q.pop();
            for(int i &#x3D;1; ;i++) &#123;
                int a &#x3D; num - i*i;
                if(a&lt;0)
                    break;
                if(a &#x3D;&#x3D; 0)
                    return step+1;
                if(!visited[a])   &#x2F;&#x2F;如果该数字没有被访问过
                &#123;
                    q.push(make_pair(a,step+1)); &#x2F;&#x2F;将这个数字压入
                    visited[a] &#x3D; true; &#x2F;&#x2F;这个数已经存在一个父节点，被访问过了，所以为true
                &#125;
            &#125;
        &#125;
        throw invalid_argument(&quot;No Solution.&quot;);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题127：word ladder<br>例题126： word ladder 2</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;vector&gt;
#include &lt;string&gt;
#include &quot;time_interval.h&quot;
int main() &#123;
    std::vector&lt;std::string&gt; v;
    int count &#x3D; 10000000;
    v.reserve(count);       &#x2F;&#x2F;预分配十万大小，排除掉分配内存的时间

    &#123;
        TIME_INTERVAL_SCOPE(&quot;push_back string:&quot;);
        for (int i &#x3D; 0; i &lt; count; i++)
        &#123;
            std::string temp(&quot;ceshi&quot;);
            v.push_back(temp);&#x2F;&#x2F; push_back(const string&amp;)，参数是左值引用
        &#125;
    &#125;

    v.clear();
    &#123;
        TIME_INTERVAL_SCOPE(&quot;push_back move(string):&quot;);
        for (int i &#x3D; 0; i &lt; count; i++)
        &#123;
            std::string temp(&quot;ceshi&quot;);
            v.push_back(std::move(temp));&#x2F;&#x2F; push_back(string &amp;&amp;), 参数是右值引用
        &#125;
    &#125;

    v.clear();
    &#123;
        TIME_INTERVAL_SCOPE(&quot;push_back(string):&quot;);
        for (int i &#x3D; 0; i &lt; count; i++)
        &#123;
            v.push_back(std::string(&quot;ceshi&quot;));&#x2F;&#x2F; push_back(string &amp;&amp;), 参数是右值引用
        &#125;
    &#125;

    v.clear();
    &#123;
        TIME_INTERVAL_SCOPE(&quot;push_back(c string):&quot;);
        for (int i &#x3D; 0; i &lt; count; i++)
        &#123;
            v.push_back(&quot;ceshi&quot;);&#x2F;&#x2F; push_back(string &amp;&amp;), 参数是右值引用
        &#125;
    &#125;

    v.clear();
    &#123;
        TIME_INTERVAL_SCOPE(&quot;emplace_back(c string):&quot;);
        for (int i &#x3D; 0; i &lt; count; i++)
        &#123;
            v.emplace_back(&quot;ceshi&quot;);&#x2F;&#x2F; 只有一次构造函数，不调用拷贝构造函数，速度最快
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第1中方法耗时最长，原因显而易见，将调用左值引用的push_back，且将会调用一次string的拷贝构造函数，比较耗时，这里的string还算很短的，如果很长的话，差异会更大<br>第2、3、4中方法耗时基本一样，参数为右值，将调用右值引用的push_back，故调用string的移动构造函数，移动构造函数耗时比拷贝构造函数少，因为不需要重新分配内存空间。<br>第5中方法耗时最少，因为emplace_back只调用构造函数，没有移动构造函数，也没有拷贝构造函数。</p>
<h2><span id="优先队列">优先队列</span></h2><p>优先队列的底层实现：堆<br>学习使用语言中的优先级队列容器</p>
<p>C++：priority_queue</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;ctime&gt;
#include&lt;functional&gt;
using namespace std;
bool myCmp(int a,int b)&#123;
    return a%10&lt;b%10;
&#125;
int main()&#123;
    srand(time(NULL)); &#x2F;&#x2F;随机种子
    &#x2F;&#x2F;默认情况下，最大堆
    priority_queue&lt;int&gt;pq;
    for(int i &#x3D; 0;i&lt;10;i++)&#123;
        int num &#x3D; rand()%100 ;&#x2F;&#x2F;0-100中随机选取一个数
        pq.push(num);
        cout&lt;&lt;&quot;insert&quot;&lt;&lt;num&lt;&lt;&quot; in priority queue.&quot;&lt;&lt;endl;
    &#125;
    while(!pq.empty())&#123;
        cout&lt;&lt;pq.top()&lt;&lt;&quot; &quot;;
        pq.pop();

    &#125;
    cout&lt;&lt;endl&lt;&lt;endl;
    &#x2F;&#x2F;底层是最小堆
    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;pq2; 
    &#x2F;&#x2F;底层为vector 最小堆greater&lt;int&gt;
    for(int i &#x3D; 0;i&lt;10;i++)&#123;

        int num &#x3D; rand()%100 ;&#x2F;&#x2F;0-100中随机选取一个数
        pq2.push(num);
        cout&lt;&lt;&quot;insert&quot;&lt;&lt;num&lt;&lt;&quot; in priority queue.&quot;&lt;&lt;endl;
    &#125;
    while(!pq2.empty())&#123;
        cout&lt;&lt;pq2.top()&lt;&lt;&quot; &quot;;
        pq2.pop();

    &#125;
    cout&lt;&lt;endl&lt;&lt;endl;
    &#x2F;&#x2F;使用自定义comparator的priority queue
    priority_queue&lt;int,vector&lt;int&gt;,function&lt;bool(int,int)&gt;&gt;pq3(myCmp);
    for(int i &#x3D; 0;i&lt;10;i++)&#123;
        int num &#x3D; rand()%100 ;&#x2F;&#x2F;0-100中随机选取一个数
        pq3.push(num);
        cout&lt;&lt;&quot;insert&quot;&lt;&lt;num&lt;&lt;&quot; in priority queue.&quot;&lt;&lt;endl;
    &#125;
    while(!pq3.empty())&#123;
        cout&lt;&lt;pq3.top()&lt;&lt;&quot; &quot;;
        pq3.pop();

    &#125;
    cout&lt;&lt;endl&lt;&lt;endl;
    return 0;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果：<br>insert20 in priority queue.<br>insert63 in priority queue.<br>insert74 in priority queue.<br>insert20 in priority queue.<br>insert41 in priority queue.<br>insert38 in priority queue.<br>insert26 in priority queue.<br>insert95 in priority queue.<br>insert87 in priority queue.<br>insert19 in priority queue.<br>95 87 74 63 41 38 26 20 20 19 </p>
<p>insert57 in priority queue.<br>insert41 in priority queue.<br>insert58 in priority queue.<br>insert34 in priority queue.<br>insert79 in priority queue.<br>insert80 in priority queue.<br>insert97 in priority queue.<br>insert85 in priority queue.<br>insert69 in priority queue.<br>insert25 in priority queue.<br>25 34 41 57 58 69 79 80 85 97 </p>
<p>这个是return a%10&lt; b% 10<br>insert57 in priority queue.<br>insert28 in priority queue.<br>insert31 in priority queue.<br>insert20 in priority queue.<br>insert18 in priority queue.<br>insert77 in priority queue.<br>insert34 in priority queue.<br>insert81 in priority queue.<br>insert4 in priority queue.<br>insert59 in priority queue.<br>59 28 18 77 57 34 4 31 81 20 </p>
<p>如果是return  a% 10 &gt;b % 10<br>则按照从小到大进行排列<br>程序正常返回需要return 0<br>所以对于bool型而言，子函数需要返回0 也就是false。<br>return a&gt;b，就需要让b&gt;a.<br>例题 347：<br>给定一个非空数组，返回前k个出现频率最高的元素<br>如给定[1,1,1,2,2,3] k = 2<br>返回[1,2]<br>注意k的合法性问题</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution&#123;
public:
    vector&lt;int&gt;topKFrequent(vector&lt;int&gt; &amp;nums,int k)&#123;
        assert(k&gt;0);
        &#x2F;&#x2F;先设定哈统计每个元素出现的频率
        unordered_map&lt;int,int&gt;freq;

        for(int i &#x3D; 0;i&lt;nums.size();i++)
            freq[numsi]]++;
        assert(k&lt;&#x3D;freq.size());
        &#x2F;&#x2F;扫描freq,维护当前出现频率最高的k个元素
        &#x2F;&#x2F;在优先队列中，按照频率排序，所以数据对时（频率，元素）的形式
        priority_queue&lt; pair&lt;int,int&gt; ,vector&lt;pair&lt;int,int&gt;&gt; ,greater&lt;pair&lt;int,int&gt;&gt; &gt;pq;
        for(unordered_map&lt;int,int&gt;::iterator iter &#x3D; freq.begin();iter!&#x3D;freq.end();iter++)&#123;
            if(pq.size() &#x3D;&#x3D; k)&#123;
                if(iter-&gt;second &gt;pq.top().first) &#x2F;&#x2F;优先队列按照（频率，元素）存储
                &#x2F;&#x2F;相同元素频率相同，不进行以下操作，去掉重复元素
                &#123;
                pq.pop(); &#x2F;&#x2F;弹出队列首元素，并将iter迭代器所对应元素压入
                pq.push_back(make_pair(iter-&gt;second,iter-&gt;first));
                &#125;
            &#125;
            else
                pq.push_back(make_pair(iter-&gt;second,iter-&gt;first));
        &#125;
        &#x2F;&#x2F;这里为了输出最后结果还需要定义一个数组res
        vector&lt;int&gt;res;
        while(!pq.empty())&#123;
            res.push_back(pq.top().second); &#x2F;&#x2F;优先队列的第二列是元素本身
            pq.pop();
        &#125;
        return res;
&#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>例题23：<br>有k个有序数组，将他们归并为一个有序数组</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法面试</tag>
      </tags>
  </entry>
  <entry>
    <title>编译内存</title>
    <url>/2021/07/28/%E7%BC%96%E8%AF%91%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1><span id="c编译内存">C++编译内存</span></h1><h2><span id="c-程序编译过程">C++ 程序编译过程</span></h2><p>编译过程分为四个部分，<strong>编译（编译预处理，编译优化），汇编，链接。</strong></p>
<ul>
<li>编译预处理：处理＃开头的命令</li>
<li>编译优化：将源码.cpp文件翻译成.s汇编代码</li>
<li>汇编：将汇编代码.s翻译成机器指令.o文件</li>
<li>链接：汇编程序生成的目标文件，即.o文件，并不会立即执行，因为可能出现.cpp文件中的函数引用了另一个.cpp文件中定义的符号或者调用了某个库文件中的函数，那么链接的目的就是将这些文件对应的目标文件链接成一个整体，从而生成可执行的程序.exe文件。</li>
</ul>
<p>链接分为两种：</p>
<ul>
<li>静态链接：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序执行时，这些<strong>代码会被装入到该进程的虚拟地址空间</strong>中。</li>
<li>动态链接：代码被放到动<strong>态链接库或共享对象</strong>的某个目标文件中，链接程序只是在最终的可执行程序中<strong>记录了共享对象的名字等一些信息</strong>。在程序执行时，<strong>动态链接库的全部内容会被映射到运行时相应进行的虚拟地址空间。</strong></li>
</ul>
<p>二者的优缺点：</p>
<ol>
<li>静态链接：浪费空间，每个可执行程序都会有目标文件的一个副本，<strong>这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难</strong>）；优点就是执行的时候<strong>运行速度快</strong>，因为可自行程序具备了程序运行的所有内容。</li>
<li>动态链接：<strong>节省内存，更新方便</strong>，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的<strong>性能损失。</strong></li>
</ol>
<h2><span id="c内存管理">C++内存管理</span></h2><p>C++内存分区：栈，堆，全局/静态存储区，常量存储区，代码区</p>
<p>栈：存放函数的局部变量，函数参数，返回地址等。由<strong>操作系统自动分配和释放。</strong></p>
<p>堆：动态申请的内存空间，就是由malloc分配的内存块，由程序员去控制它的分配和释放，<strong>如果程序执行结束还没有释放，操作系统会自动回收</strong>。</p>
<p>全局区/静态存储区：(.bss段和data段)：存放全局变量和静态变量，程序运行结束操作系统自动释放，<strong>在C语言中，未初始化的放在.bss段中，初始化的放在.data段中</strong>，C++中不再区分了。</p>
<p><strong>常量存储区(.rodata段)：</strong>存放代码，但不允许修改，但可以执行。<strong>编译后的二进制文件存放在这里。</strong></p>
<p><strong>代码区(.text段)**：存放代码，</strong>不允许修改，但可以执行。编译后的二进制文件存放在这里。**</p>
<p>说明：从操作系统的本身来讲，以上存储区在内存中的分布是如下形式（从低地址到高地址）：**.text段 —&gt; .data—–&gt;.bss—–&gt;堆—-&gt;unused—-&gt;栈—-&gt;env**</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
 
 &#x2F;&#x2F;C++中已经不再区分初始化和未初始化的全局变量，静态变量的存储区

int g_var &#x3D; 0;  &#x2F;&#x2F;全局区 (.data段)
char *gp_var;  &#x2F;&#x2F;全局区 (.bss段)

int main()&#123;
    int var;   &#x2F;&#x2F;栈
    char *p_var; &#x2F;&#x2F;栈
    char arr[] &#x3D; &quot;abc&quot;; 
    &#x2F;&#x2F;arr为数组变量，存储在栈区，&quot;abc&quot;为字符串常量，存储在常量区
    char *p_var &#x3D; &quot;123456&quot;; &#x2F;&#x2F;p_var在栈区 &quot;123456&quot;字符串常量，存储在常量区
    static int s_var; &#x2F;&#x2F;s_var 为静态变量，存在静态存储区 (.data)
    p_var &#x3D; (char *)malloc(10); &#x2F;&#x2F;分配得来的 10个字节的区域在堆区
    free(p_var);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2><span id="栈和堆的区别">栈和堆的区别</span></h2><p>申请方式：<strong>栈是操作系统自动分配，堆是程序员主动申请。</strong></p>
<p>申请后系统响应：分配栈空间。<strong>如果剩余空间大于申请空间则分配成功</strong>，否则分配失败栈溢出。申请堆空间，堆在内存中呈现的方式类似于链表（<strong>记录空闲地址空间的链表</strong>），在链表上<strong>寻找第一个大于申请空间的节点分配给程序，将该节点但从链表中删除</strong>，大多数系统中，该块空间的首地址存放的是本次分配空间的大小，便于<strong>释放，将该块空间上的剩余空间再次链接在空闲链表上。</strong></p>
<p><strong>栈在内存中是连续的一块空间（向低地址扩展</strong>）最大容量是系统预定好的，<strong>堆在内存中的空间（向高地址扩展）是不连续的。</strong></p>
<p>申请效率:<strong>栈</strong>是系统自动分配，<strong>申请效率高，</strong>但程序员无法控制。<strong>堆</strong>是由程序员主动申请，<strong>效率低，使用起来方便，但是容易产生碎片。</strong></p>
<p>存放的内容：<strong>栈中存放的是局部变量，函数的参数</strong>，<strong>堆中存放的内容由程序员控制。</strong></p>
<h2><span id="变量的区别">变量的区别</span></h2><p>全局变量，局部变量，静态全局变量，静态局部变量的区别</p>
<p>C++变量根据定义的位置的不同的生命周期，具有不同的作用域。作用域可分为6种：<strong>全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域</strong>。</p>
<p><u>从作用域看：</u></p>
<ul>
<li>全局变量：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用在所有的源文件。当然，<strong>其他不包含全局变量定义的源文件需要用extern关键字再次声明</strong>这个全局变量。</li>
<li>静态全局变量：<strong>具有文件作用域</strong>。它与全局变量的区别在于如果程序包含多个文件的话，他作用于定义它的文件中，不能作用到其他文件中，即被static关键字修饰过的变量具有文件作用域。这样<strong>即时两个不同的源文件都定义了相同名字的静态全局变量，他们也是 不同的变量。</strong></li>
<li>局部变量：具有局部作用域。它是自动对象（auto），<strong>在程序运行期间不是一直存在，而是只在函数执行期间存在</strong>，函数的一次调用执行结束后，变量被撤销，其所占用的<strong>内存也被收回。</strong></li>
<li>静态局部变量：具有局部作用域。他只被初始化一次，<strong>自从第一次被初始化直到程序运行结束都一直存在</strong>。它和全局变量的区别在于全局变量堆所有函数都是可见的，而<strong>静态局部变量只对定义自己的函数体始终可见。</strong></li>
</ul>
<p><u>从分配内存空间看：</u></p>
<p>静态存储区：全局变量，静态局部变量，静态全局变量</p>
<p>栈：<strong>局部变量</strong></p>
<p>说明：</p>
<ul>
<li><p>静态变量和栈变量（存储在栈中的变量），堆变量（存储在堆中的变量）的区别：</p>
<p><strong>静态变量</strong>会被放在程序的静态数据存储区（.data段）中（静态变量会自动初始化），这样可以<strong>在下一次调用的时候还可以保持原来的赋值</strong>。<strong>而栈变量或堆变量不能保证在下一次调用的时候依然保持原来的值。</strong></p>
</li>
<li><p>静态变量和全局变量的区别：静态变量用static告知编译器，自己仅仅在变量的作用范围内可见。</p>
</li>
</ul>
<h2><span id="全局变量定义在头文件中有什么问题">全局变量定义在头文件中有什么问题？</span></h2><p>如果在头文件中定义全局变量，当头文件被多个文件include时，改头文件的全局变量就会被定义多次，导致重复定义，因此不能在头文件中定义全局变量。</p>
<h2><span id="对象创建限制在堆和栈">对象创建限制在堆和栈</span></h2><p>如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？</p>
<p>说明：C++中的类的对象的建立分为两种：静态建立，动态建立</p>
<p>静态建立：由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如<strong>A a;</strong></p>
<p>动态建立：使用new关键字在堆上创建对象，底层首先调用operator new()函数，<strong>在堆空间上寻找合适的内存并分配，然后调用类的构造函数创建对象</strong>。例如：A *p = <strong>new A()</strong></p>
<p>限制对象只能建立在堆上：</p>
<p>最直观的思想：避免直接调用类的构造函数，因为对象静态建立时，会调用类的构造函数创建对象。但是直接将类的构造函数设为私有并不可行。因为当构造函数设置为私有后，不能再类的外部调用构造函数来构造对象，只能用new来建立对象。但是由于new创建对象的时候，底层也会调用类的构造函数，将构造函数设置为私有后，那就无法再类的外部使用new创建对象了，因此这种方法不可行。</p>
<p>解决方法1：</p>
<p><strong>将析构函数设置为私有</strong>。原因：静态对象建立在栈上，是由编译器分配和释放内存，<strong>编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性</strong>。当析构函数<strong>设置为私有</strong>的时候，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间。因此<strong>编译器不会在栈上为对象分配内存。</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;
public:
    A()&#123;&#125;;
    void destroy()&#123;
        delete this;
    &#125;
private:
    ~A()&#123;&#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>该方法<strong>存在问题</strong>：</p>
<p>用new创建的对象，通常会使用delete来释放对象的内存空间。但此时类的外部无法调用析构函数，因此<strong>类内必须定义一个destroy函数</strong>，用来释放new创建的对象。</p>
<p>无法解决<strong>继承的问题</strong>，因为<strong>如果这个类作为基类，析构函数要设置为virtual</strong>，然后在派生类中重写该函数，来实现多态。但此时，<strong>析构函数是私有的，派生类中无法访问</strong>。</p>
<p>解决方法2：</p>
<p><strong>构造函数设置为protected</strong>，并提供一个public的静态函数来完成构造。而不是在类的外部使用new构造，将析构函数设置为protected。原因：类似于单例模式，也保证了在<strong>派生类中能够访问析构函数</strong>，通过调用create()函数在堆上创建对象。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;
protected:
    A()&#123;&#125;
    ~A()&#123;&#125;
public:
    static A*create()&#123;
        return new A();
    &#125;
    void destroy()&#123;
        delete this;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>说明：<strong>static函数</strong>可以通过<strong>类名调用</strong>，而<strong>非静态函数</strong>只能通过<strong>对象调用</strong></p>
<p>创建一个对象的时候，该对象不存在，所以无法通过对象来调用非静态函数。</p>
<p>限制对象只能建立在栈上</p>
<p>解决方法：将operator new()设置为私有。原因：当对象建立在堆上的时候，是采用new的方式建立的，其底层会调用operator new()函数，因此只要对该函数加以限制，就能够防止对象建立在堆上。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;
private:
    void *operator new(size_t)&#123;&#125; &#x2F;&#x2F;注意函数的第一个参数和返回值都是固定的
    void operator delete(void *ptr)  &#x2F;&#x2F;重载了new就需要重载delete
public:
    A();
    ~A();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="内存对齐">内存对齐</span></h2><p>什么是内存对齐？内存对齐的原则？为什么要进行内存对齐？有什么缺点？</p>
<p>内存对齐：编译器将程序中的每个“数据单元”安排在字的整数倍的地址指向的内存当中。</p>
<p>内存对其原则：</p>
<ul>
<li>结构体变量的<strong>首地址能够被其最宽基本类型成员大小与对齐基数中的较小者所整除。</strong></li>
<li>结构体每个成员相对于结构体首地址的偏移量（offset）都是该成员大小与对齐基数中较小者的整数倍，如有需要，编译器会在成员之间加上填充字节。(internal padding)</li>
<li>结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之加上填充字节(trailing padding)</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
struct A&#123;
    char var3;   &#x2F;&#x2F;1 
    short var;   &#x2F;&#x2F;2
    long var2;   &#x2F;&#x2F;8 
    int var1;    &#x2F;&#x2F;4 
    string s;    &#x2F;&#x2F;32
&#125;;

int main()&#123;
    short var;
    int var1;
    long var2;
    char var3;
    string s;
    A ex1;
    cout &lt;&lt; sizeof(var) &lt;&lt; endl;    &#x2F;&#x2F;2
    cout &lt;&lt; sizeof(var1) &lt;&lt; endl;   &#x2F;&#x2F;4
    cout &lt;&lt; sizeof(s) &lt;&lt; endl;      &#x2F;&#x2F;32
    cout &lt;&lt; sizeof(var2) &lt;&lt; endl;   &#x2F;&#x2F;8
    cout &lt;&lt; sizeof(var3) &lt;&lt; endl;   &#x2F;&#x2F;1
    cout &lt;&lt; sizeof(ex1) &lt;&lt; endl;    &#x2F;&#x2F;56
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>进行内存对齐的原因：（主要是硬件设备方面的问题）</p>
<ol>
<li>某些硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常。</li>
<li>某些硬件设备不能保证在存取非对齐数据的时候操作是<strong>原子操作。</strong></li>
<li>相比于存取对齐的数据，存取非对齐的数据需要<strong>花费更多的时间</strong></li>
<li>某些处理器虽然支持非对齐数据的访问，但会引发<strong>对齐陷阱</strong>(alignment trap)</li>
<li>某些硬件设备只支持简单数据指令非对齐存取，<strong>不支持复杂数据指令的非对齐存取。</strong></li>
</ol>
<p>内存对齐的特点：</p>
<ul>
<li>便于在不同的平台之间进行移植，因为<strong>有一些硬件平台不能够支持任意地址的数据访问</strong>，只能在某些地址处取某些特定的数据，否则会抛出异常。</li>
<li><strong>提高内存的访问效率</strong>，因为CPU读取内存时，是一块一块读取的。</li>
</ul>
<h2><span id="类的大小">类的大小</span></h2><p>说明：类的大小是指类的实例化对象的大小。用sizeof对类型名操作时，结果是该类型的对象的大小。</p>
<p>计算原则：</p>
<p>遵循结构体对齐原则</p>
<p>与<strong>普通成员变量有关，与成员函数，静态成员无关</strong>。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响。因为<strong>静态数据成员被类的对象共享</strong>，并不属于某个具体的对象。</p>
<p><strong>虚函数</strong>对类的大小<strong>有影响</strong>，因为虚函数表指针的影响。</p>
<p>虚继承对类的大小有影响，因为虚基表指针的影响。</p>
<p><strong>空类</strong>的大小是一个特殊情况，空类的大小为1，当用new来创建一个空类的对象时，为了<strong>保证不同对象的地址不同</strong>，<strong>空类也占用存储空间。</strong></p>
<p>实例：</p>
<p>简单情况和空类情况：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
class A&#123;
private:
    static int s_var;
    const int c_var; &#x2F;&#x2F;4个字节
    int var;
    char var1;
public:
    A(int tmp): c_var(tmp)&#123;&#125;
    ~A()&#123;&#125;
&#125;;

class B&#123;
&#125;;
int main()&#123;
    A ex1(4);
    B ex2;
    cout &lt;&lt; sizeof(ex1) &lt;&lt; endl;
    cout &lt;&lt; sizeof(ex2) &lt;&lt; endl;
    return 0;
&#125;

&#x2F;&#x2F; 12 ----- 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>带有虚函数的情况：（注意：虚函数的个数并不影响所占内存的大小，因为类对象的内存中只保存了指向虚函数表的指针）</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*
说明：程序是在 64 位编译器下测试的
*&#x2F;
#include &lt;iostream&gt;

using namespace std;

class A
&#123;
private:
    static int s_var; &#x2F;&#x2F; 不影响类的大小
    const int c_var;  &#x2F;&#x2F; 4 字节
    int var;          &#x2F;&#x2F; 8 字节 4 + 4 (int) &#x3D; 8
    char var1;        &#x2F;&#x2F; 12 字节 8 + 1 (char) + 3 (填充) &#x3D; 12
public:
    A(int temp) : c_var(temp) &#123;&#125; &#x2F;&#x2F; 不影响类的大小
    ~A() &#123;&#125;                      &#x2F;&#x2F; 不影响类的大小
    virtual void f() &#123; cout &lt;&lt; &quot;A::f&quot; &lt;&lt; endl; &#125;

    virtual void g() &#123; cout &lt;&lt; &quot;A::g&quot; &lt;&lt; endl; &#125;

    virtual void h() &#123; cout &lt;&lt; &quot;A::h&quot; &lt;&lt; endl; &#125; &#x2F;&#x2F; 24 字节 12 + 4 (填充) + 8 (指向虚函数的指针) &#x3D; 24
&#125;;

int main()
&#123;
    A ex1(4);
    A *p;
    cout &lt;&lt; sizeof(p) &lt;&lt; endl;   &#x2F;&#x2F; 8 字节 注意：指针所占的空间和指针指向的数据类型无关
    cout &lt;&lt; sizeof(ex1) &lt;&lt; endl; &#x2F;&#x2F; 24 字节
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="内存泄漏">内存泄漏</span></h2><p>内存泄漏：由于疏忽或错误导致的程序未能释放已经不再使用的内存。</p>
<p>进一步解释：</p>
<ul>
<li><strong>并非指内存从物理上消失</strong>，而是指程序在运行过程中，由于疏忽或者错误而<strong>失去对该内存的控制</strong>，从而造成内存的浪费。</li>
<li>常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。</li>
<li>使用malloc,calloc,realloc,new等分配内存的时候，<strong>使用完要调用相应的free或delete释放内存</strong>，否则这块内存就会造成内存泄漏。</li>
<li>指针重新赋值</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char *p &#x3D; (char *)malloc(10);
char *p1 &#x3D; (char *)malloc(10);
p &#x3D; np;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>


<p>开始时，指针p和p1分别指向一块内存空间，但是指针p被重新赋值，导致p初始指向的那块内存空间无法找到，从而发生了内存泄漏。</p>
<h3><span id="怎么防止内存泄漏">怎么防止内存泄漏</span></h3><p>防止内存泄漏的方法：</p>
<h4><span id="内部封装">内部封装</span></h4><p>将内存的分配和释放封装到类中。在构造的时候申请内存，析构的时候释放内存。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;

class A&#123;
private:
    char *p;
    unsigned int p_size;
public:
    A(unsigned int n &#x3D; 1)&#123;
        p &#x3D; new char[n];
        p_size &#x3D; n;
    &#125;;
    ~A()&#123;
        if(p!&#x3D;NULL)&#123;
            delete[] p; &#x2F;&#x2F;删除字符数组
            p &#x3D; NULL; &#x2F;&#x2F;防止出现野指针
        &#125;
    &#125;;
    char *GetPointer()&#123;
        return p;
    &#125;
&#125;;

void fun()&#123;
    A ex(100);
    char *p &#x3D; ex.GetPointer();
    strcpy(p, &quot;Test&quot;);
    cout &lt;&lt; p &lt;&lt; endl;
&#125;
int main()&#123;
    fun();
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>说明：</p>
<p>但这样做不是最佳的做法，在<strong>类的对象复制时，程序会出现同一块内存空间释放两次的情况</strong>，请看如下程序。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void fun1()&#123;
    A ex(100);
    A.ex1 &#x3D; ex;
    char *p &#x3D; ex.GetPointer();
    strcpy(p,&quot;Test&quot;);
    cout&lt;&lt;p;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>简单解释：对于fun1这个函数中定义的两个类的对象而言，在离开该函数的作用域时，会调用析构函数来释放空间。但是这<strong>两个对象指向的时同一块内存空间，所以导致同一块内存空间被释放两次</strong>，可以通过增加<strong>计数机制</strong>来避免这种情况，看如下程序：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;

class A&#123;
private:
    char *p;
    unsigned int p_size;
    int *p_count;
public:
    A(unsigned int n &#x3D;1)&#123;
        p &#x3D; new char[n];
        p_size &#x3D; n;
        p_count &#x3D; new int;
        *p_count &#x3D; 1;
        cout &lt;&lt; &quot;count is :&quot; &lt;&lt; *p_count &lt;&lt; endl;
    &#125;;
    A(const A &amp;tmp)&#123;
        p &#x3D; tmp.p;
        p_size &#x3D; tmp.p_size;
        p_count &#x3D; tmp.p_count;
        (*p_count)++; &#x2F;&#x2F;复制时，计数变量+1
        cout &lt;&lt; &quot;count is:&quot; &lt;&lt; *p_count &lt;&lt; endl;
    &#125;
    ~A()&#123;
        (*p_count)--;
        cout &lt;&lt; &quot;count is :&quot; &lt;&lt; *p_count &lt;&lt; endl;
        if(*p_count &#x3D;&#x3D; 0)&#123;
            cout &lt;&lt; &quot;buf is deleted&quot; &lt;&lt; endl;
            if(p!&#x3D;NULL)&#123;
                delete[] p;
                p &#x3D; NULL;
                if(p_count!&#x3D;NULL)&#123;
                    delete p_count;
                    p_count &#x3D; NULL;
                &#125;
            &#125;
        &#125;
    &#125;;
    char *GetPointer()&#123;
        return p;
    &#125;;
&#125;;
void fun()
&#123;
    A ex(100);
    char *p &#x3D; ex.GetPointer();
    strcpy(p, &quot;Test&quot;);
    cout &lt;&lt; p &lt;&lt; endl;
    A ex1 &#x3D; ex; &#x2F;&#x2F; 此时计数变量会 +1
    cout &lt;&lt; &quot;ex1.p &#x3D; &quot; &lt;&lt; ex1.GetPointer() &lt;&lt; endl;
&#125;
int main()
&#123;
    fun();
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>程序运行结果:</p>
<pre class="line-numbers language-none"><code class="language-none">程序运行结果：
count is : 1
Test
count is : 2
ex1.p &#x3D; Test
count is : 1
count is : 0
buf is deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>解释：</p>
<p>程序运行结果的倒数2，3行时调用析构函数时进行的操作，第二次调用析构函数时，进行内存空间的释放，从而会有倒数第一行的输出结果。</p>
<h4><span id="智能指针">智能指针</span></h4><p>智能指针是C++中已经对内存泄漏封装好了的一个工具，可以直接拿来使用，将在下一个问题中对智能指针进行详细的解释。</p>
<h3><span id="内存泄漏检测工具原理">内存泄漏检测工具原理</span></h3><p>内存检测工具有很多，这里重点介绍一下valgrind</p>
<p>valgrind是一套linux下，开放源代码(GPL V2)的仿真调试工具的集合，包括以下工具:</p>
<ul>
<li>Memcheck:内存检查器(valgrind 应用最广泛的工具),能够发现开发中绝大多数内存错误的使用情况，比如：未初始化的内存，使用已经释放了的内存，内存访问越界等。</li>
<li>Callgrind :检查程序中函数调用过程中出现的问题</li>
<li>Cachegrind:检查程序中缓存使用出现的问题</li>
<li>Helgrind：检查多线程程序中出现的竞争问题</li>
<li>Massif：检查程序中堆栈使用中出现的问题</li>
<li>Extension：可以利用core提供的功能，自己编写特定的内存调试工具。</li>
</ul>
<p>Memcheck 能够检测出内存问题，关键在于其建立了两个全局表：</p>
<ul>
<li>Valid-Value 表：对于进程的整个地址空间中的每一个字节（byte），都有与之对应的 8 个 bits ；对于 CPU 的每个寄存器，也有一个与之对应的 bit 向量。这些 bits 负责记录该字节或者寄存器值是否具有有效的、已初始化的值。</li>
<li>Valid-Address 表：对于进程整个地址空间中的每一个字节（byte），还有与之对应的 1 个 bit，负责记录该地址是否能够被读写。</li>
</ul>
<p>检测原理：</p>
<ul>
<li>当要读写内存中某个字节时，首先检查这个字节对应的 Valid-Address 表中对应的 bit。如果该 bit 显示该位置是无效位置，Memcheck 则报告读写错误。</li>
<li>内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节在 Valid-Value 表对应的 bits 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 Memcheck 会检查 Valid-Value 表对应的 bits，如果该值尚未初始化，则会报告使用未初始化内存错误。</li>
</ul>
<h2><span id="智能指针">智能指针</span></h2><p>智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的。C++11中封装在了“memory”头文件中。</p>
<p>智能指针包括以下三种：</p>
<ul>
<li><strong>共享指针(shared_ptr):资源可以被多个指针共享，</strong>使用计数机制表明资源被几个指针共享。通过use_count()查看资源的所有者个数，<strong>可以通过unique_ptr,weak_ptr来构造，调用release()释放资源的所有权，计数-1</strong>，当计数减为0时，会<strong>自动释放内存空间</strong>，从而避免内存泄漏。</li>
<li>独占指针(unique_ptr):<strong>独享所有权的指针</strong>，资源只能被一个指针占有，该指针不能拷贝构造函数和赋值。但可以<strong>移动构造和移动赋值构造</strong>（调用move函数），即<strong>一个unique_ptr对象赋值给另一个unique_ptr对象</strong>，通过该方法赋值。</li>
<li>弱指针(weak_ptr)：指向shared_ptr指向的对象。能够<strong>解决shared_ptr带来的循环引用问题。</strong></li>
</ul>
<h3><span id="智能指针的实现原理">智能指针的实现原理</span></h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;memory&gt;
template&lt;typename T&gt;
class SmartPtr&#123;
private:
    T *_ptr;
    size_t *_count;

public:
    SmartPtr(T *ptr &#x3D;&#x3D; nullptr ): _ptr(ptr)&#123;
        if(_ptr)&#123;
            _count &#x3D; new size_t(1);
        &#125;
        else&#123;
            _count &#x3D; new size_t(0);
        &#125;
    &#125;
    ~SmartPtr()&#123;
        (*this-&gt;_count)--;
        if(*this-&gt;_count &#x3D;&#x3D; 0)&#123;
            delete this-&gt;_ptr;
            delete this-&gt;_count;
        &#125;
    &#125;
    
    SmartPtr(const SmartPtr &amp;ptr)  &#x2F;&#x2F;拷贝构造：计数+1
    &#123;
        if(this!&#x3D; &amp;ptr)&#123;
            this-&gt;_ptr &#x3D; ptr._ptr;
            this-&gt;_count &#x3D; ptr._count;
            (*this-&gt;_count)++;
        &#125;
    &#125;

    SmartPtr &amp; operator &#x3D; (const SmartPtr &amp;ptr) &#x2F;&#x2F;赋值运算符重载
    &#123;
        if(this-&gt;_ptr &#x3D;&#x3D; ptr._ptr)&#123;
            return *this;
        &#125;
        if(this-&gt;_ptr)  &#x2F;&#x2F;将当前的ptr指向原来的空间的计数-1
        &#123;
            (*this-&gt;_count)--;
            if(*this-&gt;_count &#x3D;&#x3D; 0)&#123;
                delete this-&gt;_ptr;
                delete this-&gt;_count;
            &#125;
        &#125;
        this-&gt;_ptr &#x3D; ptr._ptr;
        this-&gt;_count &#x3D; ptr._count;
        (*this-&gt;_count)++; &#x2F;&#x2F;此时ptr指向的新赋值空间，该空间计数-1
        return *this;
    &#125;

    T &amp;operator *()&#123;
        assert(this-&gt;_ptr !&#x3D; nullptr);
        return *(this-&gt;_ptr);
    &#125;

    T *operator -&gt;()&#123;
        assert(this-&gt;_ptr !&#x3D; nullptr);
        return this-&gt;_ptr;
    &#125;
    size_t use_count()&#123;
        return *this-&gt;count;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h3><span id="unique_ptr如何赋值">unique_ptr如何赋值</span></h3><p>借助std::move()可以实现unique_ptr对象赋值给另一个unique_ptr对象，其目的是实现所有权的转移。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;A作为一个类
std::unique_ptr&lt;A&gt; ptr1(new A());
std::unique_ptr&lt;A&gt; ptr2 &#x3D; std::move(ptr1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3><span id="智能指针可能出现的问题">智能指针可能出现的问题</span></h3><p>智能指针可能出现的问题：<strong>循环引用</strong></p>
<p>在如下例子中定义了两个类Parent,child，在两个类中分别定义另一个类的对象的共享指针，由于在程序结束后，<strong>两个指针相互指向对方的内存空间，导致内存无法被释放。</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;memory&gt;
using namespace std;
class Child;
class Parent;

class Parent&#123;
private:
    shared_ptr&lt;Child&gt; ChildPtr;

public:
    void setChild(shared_ptr&lt;Child&gt; child)
    &#123;
        this-&gt;ChildPtr &#x3D; child;
    &#125;
    void doSomething()&#123;
        if(this-&gt;ChildPtr.use_count())&#123;

        &#125;
    &#125;
    ~Parent()&#123;

    &#125;
&#125;;

class Child&#123;
private:
    shared_ptr&lt;Parent&gt; ParentPtr;
public:
    void setParent(shared_ptr&lt;Parent&gt; parent)&#123;
        this-&gt;ParentPtr &#x3D; parent;
    &#125;

    void doSomething()&#123;
        if(this-&gt;ParentPtr.use_count())&#123;

        &#125;
    &#125;
    ~Child()&#123;

    &#125;
&#125;;

int main()&#123;
    weak_ptr&lt;Parent&gt; wpp;
    weak_ptr&lt;Child&gt; wpc;
    &#123;
        shared_ptr&lt;Parent&gt; p(new Parent);
        shared_ptr&lt;Child&gt; c(new Child);
        p-&gt;setChild(c);
        c-&gt;setParent(p);
        wpp &#x3D; p;
        wpc &#x3D; c;
        cout &lt;&lt; p.use_count() &lt;&lt; endl; &#x2F;&#x2F;2
        cout &lt;&lt; c.use_count() &lt;&lt; endl; &#x2F;&#x2F;2

    &#125;
    cout &lt;&lt; wpp.use_count() &lt;&lt; endl;
    cout &lt;&lt; wpc.use_count() &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>循环引用的解决办法：weak_ptr</p>
<p>循环引用：该被调用的析构函数没有被调用，从而出现内存泄漏</p>
<ul>
<li>weak_ptr 对 <u>被shared_ptr管理的对象</u> 存在非拥有性（弱）引用，在访问所引用的对象前必须先转化为shared_ptr;</li>
<li>weak_ptr用来打断shared_ptr所管理对象的循环引用问题，若这种环被孤立（没有指向环中的外部共享指针），shared_ptr引用计数无法抵达0，内存被泄漏，<strong>令环中的指针之一为弱指针可以避免该情况。</strong></li>
<li><strong>weak_ptr用来表达临时所有权的概念</strong>，当某个对象只有存在时才需要被访问，而且随时可能被他人删除。可以用weak_ptr跟踪该对象，<strong>需要获得所有权时将其转化为shared_ptr，此时如果原来的shared_ptr被销毁</strong>，则该对象的生命周期被延长至这个临时的shared_ptr同样被销毁。</li>
</ul>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;
#include &lt;memory&gt;

using namespace std;

class Child;
class Parent;

class Parent &#123;
private:
    &#x2F;&#x2F;shared_ptr&lt;Child&gt; ChildPtr;
    weak_ptr&lt;Child&gt; ChildPtr;
public:
    void setChild(shared_ptr&lt;Child&gt; child) &#123;
        this-&gt;ChildPtr &#x3D; child;
    &#125;

    void doSomething() &#123;
        &#x2F;&#x2F;new shared_ptr
        if (this-&gt;ChildPtr.use_count()) &#123;

        &#125;
    &#125;

    ~Parent() &#123;
    &#125;
&#125;;

class Child &#123;
private:
    shared_ptr&lt;Parent&gt; ParentPtr;
public:
    void setPartent(shared_ptr&lt;Parent&gt; parent) &#123;
        this-&gt;ParentPtr &#x3D; parent;
    &#125;
    void doSomething() &#123;
        if (this-&gt;ParentPtr.use_count()) &#123;
            
        &#125;
    &#125;
    ~Child() &#123;
    &#125;
&#125;;

int main() &#123;
    weak_ptr&lt;Parent&gt; wpp;
    weak_ptr&lt;Child&gt; wpc;

    &#123;
        shared_ptr&lt;Parent&gt; p(new Parent);
        shared_ptr&lt;Child&gt; c(new Child);
        p-&gt;setChild(c);
        c-&gt;setPartent(p);
        wpp &#x3D; p;
        wpc &#x3D; c;
        cout &lt;&lt; p.use_count() &lt;&lt; endl; &#x2F;&#x2F; 2
        cout &lt;&lt; c.use_count() &lt;&lt; endl; &#x2F;&#x2F; 1
    &#125;
    cout &lt;&lt; wpp.use_count() &lt;&lt; endl;  &#x2F;&#x2F; 0
    cout &lt;&lt; wpc.use_count() &lt;&lt; endl;  &#x2F;&#x2F; 0
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++进阶笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2021/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="计算机网络持续更新">计算机网络（持续更新）</span></h2><h3><span id="1请你来说一下-socket编程中服务器端和客户端主要用到哪些函数">1.请你来说一下 socket编程中服务器端和客户端主要用到哪些函数</span></h3><p>1)基于TCP的socket<br>1.<strong>服务器端程序</strong>：<br>1.创建一个socket，用函数socket()<br>2.绑定IP地址，端口等信息到socket上，用函数<strong>bind()</strong><br>3.开始监听，<strong>设定最大连接数用函数listen()</strong><br>4.接收客户端上的连接，用函数<strong>accept()</strong><br>5.收发数据，用函数send()和recv()，或者read()和write()<br>6.关闭网络连接</p>
<p>2.<strong>客户端程序</strong>：<br>1.创建socket(),用函数socket()<br>2.设置要连接的对方的IP地址和端口等属性<br>3.连接服务器，用函数<strong>connect()</strong><br>4.收发数据，用send()和recv().或者read(),write()<br>5.关闭网络连接</p>
<p>2）基于UDP的socket:<br>1.服务器端流程<br>1.建立套接字文件描述符，使用函数socket()，生成套接字文件描述符<br>2.设置服务器地址和侦听端口，<strong>初始化要绑定网络地址结构</strong><br>3.绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。<br>4.接收客户端的数据，使用recvfrom()函数接受客户端的网络数据<br>5.向客户端发送数据，使用<strong>sendto()函数向服务器主机发送数据</strong><br>6.关闭套接字，使用close()函数释放资源。</p>
<p>2.客户端流程<br>1.建立套接字文件描述符socket()<br>2.设置服务器地址和端口，struct sockaddr.<br>3.向服务器发送数据，sendto()<br>4.接收服务器数据，recvfrom()<br>5.关闭套接字,close()</p>
<h3><span id="2tcp拥塞机制">2.TCP拥塞机制</span></h3><p>主要是下面四种机制<br>1.慢开始<br>慢开始指的是TCP开始发送设置拥塞窗口cwnd= 1.不要一开始就发送大量数据，先探测一下网络的拥塞程度，经过一个轮次的传输，拥塞窗口cwnd加倍。当cwnd超过慢开始门限，则使用拥塞避免算法，防止cwnd增长过大。<br>2.拥塞避免<br>每经过一个RTT时间，cwnd就增长1<br>在慢开始和拥塞避免的过程中一旦发现网络拥塞，就把慢开始<strong>门限</strong>设置为<strong>当前cwnd的一半</strong>，<strong>重新设置cwnd为1.</strong><br>3.快重传<br>接收方每次接收到一个失序的报文段之后就应该立即发出重复确认，<strong>发送方只要连续收到三次重复确认</strong>就立即重传。<br>4.快速回复<br>当发送方收到三个连续的重复确认时，就进行乘法减小算法，把慢开始门限设置为当前cwnd的一半，<strong>将cwnd设置为慢开始门限大小，执行拥塞避免算法。</strong></p>
<h3><span id="3流量控制服务和拥塞控制服务的区别">3.流量控制服务和拥塞控制服务的区别</span></h3><p>TCP接收正确，按序到达的字节后，直接放入接收缓存。相关进程会从当前缓，存读取数据，但是<strong>不一定是立即读取</strong>，接收方应用或许在忙其他业务，如果发送方读取数据缓慢，就会很容易使该连接接收缓存溢出。<br><strong>流量控制服务</strong>：消除发送方使接收方缓存溢出的可能性。流量控制因此是一个速度匹配的服务。即<strong>发送方的发送速率和接收方应用程序的读取速率相匹配。</strong><br>让发送方维护一个称为接收窗口(rwnd receive window)的变量来提供流量控制。接收窗口用于给发送方一个提示————该接收方窗口还有多少可用的空间。<strong>发送方控制发送出去的字节数小于接收窗口的大小。</strong>。<br>小问题：发送方维护的rwnd为0.接收方清空缓存，但是并不向发送方发送带有新值的rwnd段。解决当<strong>主机B的接收窗口为0的时候，主机A继续发送只有一个字节的数据报段</strong>，这样B就可以返回非零的rwnd的值。<br>拥塞控制：TCP发送方有可能因为IP网络的拥塞而被抑制，这种形式的发送方控制叫做拥塞控制。</p>
<h3><span id="4简述一下tcp的三次握手-四次挥手">4.简述一下TCP的三次握手 四次挥手</span></h3><p>握手<br>1.客户端将报文段首部SYN标志位设置为1，随机生成序号seq=x ，发送给服务器，客户端进入client-sent状态。<br>2.服务器接收包含SYN=1的数据报，知道了客户端要建立请求连接，客户端将标志位SYN和ACK都设置为1，将<strong>确认号</strong>置为x+1，<strong>随机生成一个序号seq=y</strong>,将数据报发回客户端确认连接请求，服务器进入SYN_received状态。<br>3.客户端收到数据报<strong>检查接收的确认号是否为X+1</strong>，<strong>ACK是否为1</strong>.如果正确<strong>将确认号设置为Y+1发送给服务器，服务器检查确认号是否为Y+1</strong>，ack是否为1，如果是则建立连接成功，客户端和服务器进入established状态，可以互相发送数据。</p>
<p>挥手<br>TCP是全双工连接的，每一方都需要单独关闭，原则是发送FIN来终止任务，首先一方执行主动关闭，另一方执行被动关闭。</p>
<p>1.数据传输结束后，<strong>客户端应用进程发出连接解除报文段，并停止发送数据，客户端进入FIN_wait状态</strong>，此时客户端依然可以接收数据。<br>2.服务器接收FIN之后，再发送一个ACK给客户端，确认号为收到序号+1，服务器进入close_wait状态，客户端进入FIN_wait2状态。<br>3.当服务器端没有数据要发送时，服务器向客户端发送一个FIN报文，此时服务器进入LAST_ACK状态。<br>4.客户端<strong>接收到服务器的FIN报文</strong>之后，<strong>给服务器发送一个ACK报文，确认序列号是收到序列号+1</strong>.此时客户端进入TIME_wait状态，等待一段时间后（报文最大生存时间）关闭连接。</p>
<p>为什么三次握手<br>为了实现可靠数据传输。TCP协议的通信双方，都必须维护一个序列号，以标识发送出去的数据报中，哪些是已经被对方收到的。三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到序列号起始值的必经步骤。<br>如果只是两次握手，至多只有连接发起方的起始序列号可以被确认，另一方选择的序列号得不到确认。<br>防止本来应该失效的连接请求报文又突然回到服务器端造成的浪费。<br>例如：客户端发送一个SYN，由于网络堵塞，服务器并没有收到这个数据包。然后客户端又重新传了这个SYN数据报并且正确建立TCP连接了，传送完数据，又关闭了TCP连接，这个时候之前发送的SYN数据报来到服务器，服务器发出应答报文段。如果没有采用三次握手连接，此时服务器发送应答报文段表示已经建立起连接，一直等着发送数据。因为客户端没有发起新的请求，会丢弃服务器的SYN。此时服务器会一直等待客户端发送数据而造成资源的浪费。<br><strong>SYN洪泛攻击。</strong></p>
<p>为什么是四次挥手<br>为了能够保证数据完成传输，当关闭连接时，<strong>当收到FIN报文通知的时候，它仅仅表示对方没有数据发送给你了，但是你的数据未必全部发送给了对方，</strong>所以你可以不立刻关闭socket，你还可以继续传输数据给对方。<strong>你发送FIN给对方表示你同意关闭连接了</strong>，所以这里的FIN和ACk都是分开发送的。</p>
<h3><span id="5ip报文的格式和各个字段的含义">5.IP报文的格式和各个字段的含义</span></h3><p>版本号：IPV4就是4.IPV6就是6 （4）<br>首部长度：IPV4可以包含一些可变参数选项，所以需要一个参数指示数据部分从哪里开始 。一般IPV4数据报具有20字节的首部。（4）<br>服务类型：不常用 （8）<br>数据报长度，这个IP数据报的总长度，最多可以传送65535字节的IP数据报。一般不超过1500字节。（16）</p>
<p>标识（16） 标志（3） 片偏移（13）：这三个字段与所谓的IP分片有关。</p>
<p>生存时间TTL ： 经过一个路由器-1.字段为0时，数据报被丢弃，并且发送ICMP报文通知源主机。（8）<br>协议 ：区分上层协议（8）<br>首部校验和：将首部字段和反码存入该字段（16）</p>
<p>源和目的IP地址（64）</p>
<p>选项：平常用不到</p>
<h3><span id="6介绍一下ip分片">6.介绍一下IP分片</span></h3><p>IP之所以分片是因为不是所有链路层都能承载相同长度的网络分组。例如，以太网能承载不超过1500字节的数据，而某些广域网链路只能承载不超过576字节的数据。一个链路能承载的最大数据量叫做最大传输单元MTU，每种链路可能采用不同的链路层协议，每种协议可能有不同的MTU。</p>
<p>假如在传输过程中，收到的IP数据报字节数比我要转发出去的那条链路的MTU还要大，这个时候就需要将IP进行分解，逐个传输。</p>
<p>标识：数据报被拆分成片后具有相同的标识<br>标志：最后一个片的标志为0，其他都为1.<br>偏移：偏移指示该片应该放到初始IP分组的哪个位置，8字节为单位。</p>
<h3><span id="7子网掩码">7.子网掩码</span></h3><p>子网掩码是一种用来指示一个IP地址所标示的主机处于哪个子网当中，子网掩码不能单独存在，他还必须结合IP地址一起使用。<strong>子网掩码只有一个作用，就是将某个IP地址划分成网络部分和主机部分。</strong>使得路由更方便，先到达子网，再确认是哪个主机。</p>
<h3><span id="8子网掩码类型">8.子网掩码类型</span></h3><p>因特网地址分配策略为无类别区间路由选择（CIDR）。32比特的IP地址划分成两部分。并且也具有点十分制格式a.b.c.d/x 。x–最高比特构成IP地址的网络部分，在外部路由仅仅需要考虑前x个比特。</p>
<p>具有8，16，24比特子网地址的子网 称为A,B,C类地址，能容纳2^24个地址。B类可容纳65534台主机，C类可容纳254台主机。</p>
<h3><span id="9ip首部校验和是怎么计算的">9.IP首部校验和是怎么计算的</span></h3><p>与ICMP，IGMP，TCP，UDP的首部校验和有什么区别和共同点。</p>
<p>1.先把校验和字段置为0<br>2.对首部中每个<strong>16位比特</strong>进行二进制反码求和<br>3.结果存在校验和字段中<br>4.收到一份IP数据报后，同样对首部中每个16bit二进制反码求和<br>5.最后<strong>结果全为1 表示正确</strong>，否则表示错误<br>6.如果是错误的，IP就丢弃该数据报，但是不生成差错报文，由上层去处理。</p>
<p>共同点：用到的计算方法都是一样的<br>区别：<strong>IP计算的时候没有将数据包括在内</strong><br>ICMP，IGMP，TCP，UDP同时覆盖首部和数据校验码</p>
<h3><span id="10io多路复用">10.I/O多路复用</span></h3><p>I/O多路复用使得程序可以同时监听多个文件描述符，能够提高程序的性能。<br>I/O多路复用出现的场景，是设计一个高性能的网络服务器，能够供多个客户端同时连接并处理客户端传上来的请求。首先想到的是可以利用多线程，但是多线程存在很大的弊端<br>，需要上下文切换。</p>
<p>select<br>主旨思想：<br>1.首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中。<br>2.调用一个系统函数，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行I/O操作的时候，该函数才返回。<br>a.这个函数是阻塞的<br>b.函数对文件描述符的检测操作是由内核完成的<br>3.在返回的时候，他会告诉进程有哪些文件描述符要进行IO操作</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;sys&#x2F;time.h&gt;
#include&lt;sys&#x2F;types.h&gt;
#include&lt;unistd.h&gt;
int select(int nfds,fd_set *readfds,fd_set *writefds,fd_set *ecxeptfds,struct timeval *timeout);
    参数：
        -nfds 委托内核检测的最大文件描述符的值+1
        -readfds：要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性
            -一般检测读操作
            -对应的是对方发送过来的数据，因为读是被动的接收数据，检测的是读缓冲区
            -是一个传入传出参数
        -writefds:检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性
            -委托内核检测写缓冲区是不是还可以写数据（不满的话就可以写）
        -exceptfds：检测发生异常的文件描述符的集合
        -timeout:设置的超时时间
            struct timeval&#123;
                long tv_sec;
                long tv_usec;
            &#125;;
            -NULL :永久阻塞，直到检测到文件描述符有变化
            -tv_sec &#x3D; 0 tv_usec&#x3D;0 不阻塞
            -tv_sec &gt; 0 tv_usec&gt;0 阻塞对应的时间

    返回值：-1 失败
            n ：检测的集合中有n个文件描述符发生了变化
&#x2F;&#x2F;将参数文件描述符fd对应的标志位设置为0
void FD_CLR(int fd,fd_set *set);

&#x2F;&#x2F;判断fd对应的标志位是0还是1，返回值：fd对应的标志位的值，0返回0，1返回1
int FD_ISSET(int fd,fd_set *set);

&#x2F;&#x2F;将文件描述符fd对应的标志位设置为1
void FD_SET(int fd,fd_set *set);

&#x2F;&#x2F;fd_set一共有1024bit，全部初始化为0
void FD_ZERO(fd_set *set); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>epoll<br>创建一个新的epoll实例。在内核中创建一个数据，这个数据有两个比较重要的数据，一个是需要检测的文件描述符的信息（红黑树），还有一个是就绪链表，存放检测到数据发送改变的文件描述符信息（双向链表）</p>
<pre class="line-numbers language-none"><code class="language-none">常见的epoll检测事件：
    EPOLLIN
    EPOLLOUT
    EPOLLERR
int poll_create(int size);
    参数：
        size 目前没有意义，随便写一个数，必须大于0

    返回值：
        -1 失败
        &gt;0 文件描述符，操作epoll实例的
&#x2F;&#x2F;对epoll实例进行管理，添加文件描述符，删除信息，修改信息

int epoll_ctl(int epfd,int op,struct epoll_event *event);
    参数：
        epfd：epoll实例对应的文件描述符
        op： 要进行什么操作 --&gt; 红黑树
            EPOLL_CTL_ADD: 添加
            EPOLL_CTL_MOD: 修改
            EPOLL_CTL_DEL: 删除
        fd ：要检测的文件描述符
        event:检测文件描述符什么事情
int epoll_wait(int epfd,struct epoll_event * events,int maxevents,int timeout);
    参数：
        epfd：epoll实例对应文件描述符
        events：传出参数，保存了发送了变化的文件描述符的信息
        maxevents:第二个参数结构体数组的大小
        timeout：阻塞时间
            0 不阻塞
            -1 阻塞，直到有检测到fd数据发生变化解除阻塞
            &gt;0 要阻塞的时长 （毫秒）
    返回值 -1 失败
           &gt;0 返回发生变化的文件描述符的个数
 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="11http协议">11.http协议</span></h3><p>超文本传输协议：一个专门在计算机世界里专门在两个点之间传输的文字，图片，视频等超文本数据的约定和规范。<strong>首部行里存有各种字段。</strong><br>http有两种：报文请求和响应报文</p>
<p>例子：<br><strong>请求报文格式</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;请求行，正在请求的对象http版本号
GET &#x2F;some&#x2F;dir&#x2F;page.html HTTP&#x2F;1.1
&#x2F;&#x2F;指定的服务器的域名，可以将请求发往同一台服务器上的不同网站
Host : www.someschool.edu
&#x2F;&#x2F;一个可以复用的TCP连接就建立了，直到客户端或者服务器端主动断开连接
connection:Keep-Alive
&#x2F;&#x2F;服务器在发完被请求的对象之后关闭连接
connection: close
&#x2F;&#x2F;浏览器的类型和版本
user-agent : Mozilla&#x2F;1.0
&#x2F;&#x2F;声明自己能够接收的请求
Accept:*&#x2F;*    &#x2F;&#x2F;都能收
&#x2F;&#x2F;语言类型
Accept-Language:en-us
&#x2F;&#x2F;我可以接收什么压缩方式
Accept-Encoding:gzip deflate
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>响应报文格式</strong></p>
<pre class="line-numbers language-none"><code class="language-none">Http&#x2F;1.1 200 OK
&#x2F;&#x2F;发送完报文关闭tcp连接
connection:close
&#x2F;&#x2F;服务器产生该响应并且发送响应报文的时间
date :Tue,09,Aug...
&#x2F;&#x2F;服务器类型
server:..
&#x2F;&#x2F;最后对象修改的日期
Last-Modified:
&#x2F;&#x2F;被发送对象的字节数
content-Length :6180
content-Type:test&#x2F;html
&#x2F;&#x2F;采用压缩方式
Contest-Encoding gzip
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>常见的状态码：<br>200 OK 请求成功 信息在返回响应的报文之中<br>301 Move Permanently:请求的对象被永久转移了，新的URL在定义响应报文段的location字段中，浏览器自动重定向新的URL<br>400 Bad request:一个通用差错编码，指示请求不能被服务器理解<br>404 Not found：请求的文档不在服务器上<br>505 Http version not supported 服务器不支持请求报文使用的HTTP协议版本</p>
<p><strong>GET和Post的区别</strong><br>Get方法的含义是<strong>请求服务器获取资源</strong>，这个资源可以是静态文本，页面，图片视频等。<br>而Post方法则是相反的操作。<strong>他向URL指定的资源中提交数据</strong>，比如说一个人的博客可以留言，我写完留言后点击提交，我的留言就会执行一次post请求。<br>Get方法是<strong>安全的并且是幂等的</strong>，也就是说get是一个只读操作，无论执行多少次，服务器上的数据都是安全的，并且每次的结果都是相同的。</p>
<p>Post方法<strong>不是安全的并且不是幂等的。</strong> Post因为是新增或者提交数据，会修改服务器上的资源，所以不是安全的。并多次提交数据会执行多次操作创建多个资源，所以不是幂等的。</p>
<p><strong>Get能够被缓存，而post不可以。</strong><br>Get参数保留在浏览器历史中，而post参数不会保留在浏览器历史中。<br>当发生数据时，<strong>get方法向URL添加数据，URL的数据长度时受限的，而post没有数据长度限制。</strong></p>
<p>Get只允许ASCII编码，而Post没有限制<br>Get安全性没有post安全性好<br>Get数据在URL中对所有人是可见的，而在post中数据不会显示在URL中。<br>Get产生一个TCP数据包，post产生两个TCP数据包。对于get方式的请求，浏览器会把header和data一并发送出去，对于post，浏览器先发送header再发送data。</p>
<p>参考回答：<br>1.概括<br>对于get方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）<br>而对于post，浏览器先发送header，服务器响应100continue，浏览器再发送data，服务器响应200 ok（返回数据）<br>2.区别<br>1.get参数通过url传递，post放在request body中。<br>2.get请求在url传递的参数是有长度限制的，而post没有。<br>3.get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。<br>4.get请求只能进行url编码，而post支持多种编码。<br>5.get请求会主动cache<br>6.get请求参数会被完整的保留在浏览历史记录里，而post中的参数不会保留<br>7.get和post本质上都是TCP连接，并无差别。但是由于http的固定和浏览器、服务器的限制，导致他们在应用过程中体现出一些不同。<br>8.get产生一个TCP数据报，post产生两个TCP数据包</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>GET</td>
<td><strong>发送请求来获得服务器上的资源</strong>，请求体中不会包含请求数据，请求数据放在协议头中。另外get支持快取，缓存，可保留书签等。幂等。</td>
</tr>
<tr>
<td>2</td>
<td>POST</td>
<td>和get一样很常见，<strong>向服务器提交资源让服务器处理，比如提交表单，上传文件等，可能导致建立新的资源或者对原有资源的修改</strong>。提交的资源放在请求体中。不支持快取，非幂等，<strong>post的数据存放位置由服务器自己决定</strong></td>
</tr>
<tr>
<td>3</td>
<td>HEAD</td>
<td>本质上和get一样<strong>，但是响应中没有呈现数据，而是http的头信息，主要用来检查资源或者超链接的有效性或是否可以可达，检查网页是否被串改和更新，获取头信息</strong>。特别适用在有限的速度和带宽下。</td>
</tr>
<tr>
<td>4</td>
<td>PUT</td>
<td>和post类似，html表单不支持，发送资源与服务器，并存储在服务器指定位置，要求客户端事先知道该位置，比如<strong>post是在一个集合上（/province)，而put是具体在某一个资源上(/province/123</strong>)。所以put是安全的，无论请求多少次，都是在123上更改，而post可能请求几次创建了几次资源。<strong>幂等</strong>。</td>
</tr>
<tr>
<td>5</td>
<td>DELETE</td>
<td>请求服务器删除某资源，和put都具有破坏性，可能被防火墙拦截。如果是http协议，则无需担心。幂等。</td>
</tr>
<tr>
<td>6</td>
<td>CONNECT</td>
<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器，就是把<strong>服务器做为跳板，去访问其他网页然后把数据返回回来</strong>，连接成功后，就可以正常的get，post。</td>
</tr>
<tr>
<td>7</td>
<td>OPTIONS</td>
<td><strong>获取http服务器支持的http请求方法，允许客户端查看服务器的性能</strong>，比如ajax跨域时的预检等。</td>
</tr>
<tr>
<td>8</td>
<td>TRACE</td>
<td><strong>回显服务器收到的请求。主要用于测试或诊断。</strong>一般金庸，防止被恶意攻击或盗取信息。</td>
</tr>
</tbody></table>
<h4><span id="cookies和session的区别">Cookies和session的区别</span></h4><ul>
<li>登录网站，输入用户名和密码登录，第二天再打开很多情况下就直接打开了，这个时候用到的机制就是cookie。</li>
<li>session一个场景就是购物车，添加了商品之后客户端处就可以知道添加了哪些商品，而服务器端如何判别呢，所以也需要存储一些信息，就用到了session。</li>
</ul>
<p>cookies：当一个web站点通常希望能够识别用户，将内容和用户身份连接起来。当客户端发送http请求的时候，服务器就会在返回的报文中含有set-cookies字段，并且这个字段保存在客户端的硬盘上。这样客户端再次发送请求的时候就会加上自己的cookies，从而服务器就可以识别用户了。可以用在某个站点持久的保存数据。凡是也会造成隐私泄露问题，<strong>结合cookies和用户的账户信息，购物信息等。web站点可以知道很多关于用户的信息。cookie存在于客户端，所以也可以伪造。</strong></p>
<p>session：session存在于服务器的一种用来存放用户数据的类Hashtable结构。当浏览器第一次发起请求的时候，服务器就会自动生成session id和hashtable，当第二次发起请求的时候，将前一次服务器响应的session id放在请求中一并发给服务器，这时服务器进行和原来的session id进行对比，就可以找到这个用户的hashtable。</p>
<p>cookie数据保存在客户端，session保存在服务器端。</p>
<h3><span id="12为什么又mac地址">12.为什么又MAC地址</span></h3><p>事实上并不是所有的主机或者路由器都具有链路层地址，而是他们的适配器（网络接口）具有链路层地址。。因此就会有多个网络接口的主机或者路由器将具有多个链路层地址，也就像它具有与之相关联的IP地址一样。</p>
<p><strong>局域网设计是为任意的网络层协议而设计的，而不指示用于IP和因特网，如果适配器指派的时IP地址而不是MAC地址，则适配器不能方便的支持其他的网络层协议。其次网络层地址必须存储在RAM中，在每次适配器移动的时候要重新配置。用MAC地址和IP地址两个地址，用于分别表示物理地址和逻辑地址是有好处的。这样分层可以使网络层与链路层的协议更灵活的替换，网络层不一定要用IP协议，链路层也不一定非用以太网协议</strong>。</p>
<h3><span id="13arp协议">13.ARP协议</span></h3><p>ARP协议为IP地址得到对应的硬件地址提供动态映射</p>
<p>ARP只能为同一个子网上的主机和路由器解析IP地址。</p>
<p>ARP（地址解析协议），当<strong>主机要发送一个IP包的时候，会先查自己的ARP告诉缓存表，如果查询的IP-MAC的值不存在，主机向网络广播一个ARP请求，这个包里有等待查询的IP地址</strong>，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的<strong>某一个主机发现自己符合条件，那就回应一个ARP应答包，源主机拿到ARP应答包后会更新自己的ARP缓存表</strong>。源主机根据ARP缓存表准备好数据链路层的数据报发送工作。</p>
<p>点对点链路使用ARP吗？</p>
<p>不使用。</p>
<p>ARP高效运行的关键是什么？</p>
<p>关键是每个主机都有一个ARP告诉缓存。</p>
<p>ARP各个字段以及含义？</p>
<p>帧类型：ARP：0x0806（2）</p>
<p>ARP首部：</p>
<p>硬件类型：硬件地址的类型 1表示以太网地址（2）</p>
<p>协议地址：协议地址的类型，0x0800表示IP地址 （2）</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2021/07/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1><span id="设计模式">设计模式</span></h1><h2><span id="单例模式">单例模式</span></h2><p>保证类的实例化对象只有一个，并且提供一个访问它的全局访问点。</p>
<p>应用场景：</p>
<ul>
<li>标识文件系统的类，一个操作系统一定是只有一个文件系统，因此文件系统的类的实例有且仅有一个。</li>
<li>打印机打印程序的实例，一台计算机可以连接好几台打印机，但是计算机上的打印程序只有一个，就可以<strong>通过单例模式来避免两个打印作业同时输出到打印机。</strong></li>
</ul>
<p>实现方式：</p>
<p>单例模式可以通过全局或者静态变量的形式实现，这样比较简单，但是这样会影响封装性，难以保证别的代码不会对全局变量造成影响。</p>
<p>默认的构造函数，拷贝构造函数，赋值构造函数声明为私有的，这样进制在类的外部创建该对象。</p>
<p>全局访问点也要定义为<strong>静态类型的成员函数</strong>，没有参数，返回该类的指针类型。<strong>因此使用实例化对象的时候是通过类直接调用该函数，并不是先创建一个该类的对象，通过对象调用</strong>。</p>
<p>不安全的实现方式：</p>
<p>原因：考虑当两个线程同时调用 getInstance 方法，并且同时检测到instance是NULL，两个线程会同时实例化对象，不符合单例模式的要求。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Singleton&#123;
private:
    static Singleton * instance;
    Singleton()&#123;&#125;
    Singleton(const Singleton &amp;tmp)&#123;&#125;
    Singleton &amp; operator &#x3D; (const Singleton &amp;tmp)&#123;&#125;
public:
    static Singleton *getInstance()&#123;
        if(instance &#x3D;&#x3D; NULL)&#123;
            instance &#x3D; new Singleton();
        &#125;
        return instance;
    &#125;
&#125;;
Singleton *Singleton :: instance &#x3D; NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>分类：h</p>
<ul>
<li><strong>懒汉模式</strong>：直到第一次用到类的实例时才会去实例化，上面是懒汉实现。</li>
<li><strong>饿汉模式</strong>：类定义的时候就实例化</li>
</ul>
<p>线程安全的懒汉模式实现：</p>
<p>方法：加锁</p>
<p>存在的问题：每次判断实例对象是否为NULL，都要被锁定，如果是多线程，就会造成大量线程阻塞。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Singleton&#123;
private:
    static pthread_mutex_t mutex;
    static Singleton *instance;
    Singleton()&#123;
        pthread_mutex_init(&amp;mutex,NULL);
    &#125;
    Singleton(const Singleton &amp;tmp);
    Singleton &amp; operator &#x3D; (const Singleton &amp;tmp);
public:
    static Singleton * getInstance()&#123;
        pthread_mutex_lock(&amp;mutex);
        if(instance &#x3D;&#x3D; NULL)&#123;
            instance &#x3D; new Singleton();
        &#125;
        pthread_mutex_unlock(&amp;mutex);
        return instance;
    &#125;
&#125;;
Singleton *Singleton ::instance &#x3D; NULL;
pthread_mutex_t Singleton::mutex;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>方法：内部静态变量，在全局访问点getInstance中定义静态实例</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Singleton&#123;
private:
    static pthread_mutex_t mutex;
    Singleton()&#123;
        pthread_mutex_init(&amp;mutex,NULL);
    &#125;
    Singleton(const Singleton &amp;temp);
    Singleton &amp; operator &#x3D; (const Singleton &amp;temp);
public:
    static Singleton * getInstance()&#123;
        static Singleton instance;
        return instance;
    &#125;
&#125;;
pthread_mutex_t Singleton::mutex;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>饿汉模式的实现：</p>
<p>饿汉模式本身就是线程安全的，不用加锁。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Singleton&#123;
private:
    static Singleton *instance;
    Singleton(const Singleton &amp;tmp);
    Singleton &amp; operator &#x3D; (const Singleton &amp;tmp);
protected:
    Singleton()&#123;&#125;
public:
    static Singleton * getInstance()&#123;
        return instance;
    &#125;
&#125;;
Singleton *Singleton ::instance &#x3D; new Singleton();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="工厂模式">工厂模式</span></h2><p>工厂模式：包括简单工厂模式，抽象工厂模式，工厂方法模式</p>
<p>简单工厂模式：主要用于创建对象。用一个工厂来根据输入的条件产生不同的类，然后根据不同的类的虚函数得到不同的结果。</p>
<p>工厂方法模式：修正了简单工厂模式不遵守开放封闭原则。把选择判断移到了客户端去实现，如果<strong>想添加新功能就不用修改原来的类，直接修改客户端即可</strong>。</p>
<p>抽象工厂模式：定义了一个创建一系列相关或相互依赖的接口，而无需指定他们的具体类。</p>
<h3><span id="1简单工厂模式">1.简单工厂模式</span></h3><p>主要用于创建对象。用一个工厂来根据输入的条件产生不同的类，然后根据不同类的虚函数得到不同的结果。</p>
<p>应用场景：</p>
<p>适用于针对不同情况创建不同类时，只需传入工厂类的参数即可，无需了解具体实现方法。例如计算器中对于同样的输入，执行不同的操作：加减乘除。</p>
<p>实现方式：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

&#x2F;&#x2F;here is the product class
class Operation_Pos()&#123;
public:
    int var1,var2;
    virtual double GetResult()&#123;
        double res &#x3D; 0;
        return res;
    &#125;
&#125;;
class Add_Operation_Pos : public Operation_Pos&#123;
public:
    virtual double GetResult()&#123;
        return var1 + var2;
    &#125;
    
&#125;;
class Sub_Operation_Pos : public Operation_Pos&#123;
public:
    virtual double GetResult()&#123;
        return var1 - var2;
    &#125;
    
&#125;;
class Mul_Operation_Pos : public Operation_Pos&#123;
public:
    virtual double GetResult()&#123;
        return var1 * var2;
    &#125;
    
&#125;;
class Div_Operation_Pos : public Operation_Pos&#123;
public:
    virtual double GetResult()&#123;
        return var1 &#x2F; var2;
    &#125;
&#125;;

&#x2F;&#x2F;here is factory class
class Factory&#123;
public:
    static Operation_Pos *CreateProduct(char op)&#123;
        switch(op)&#123;
            case &#39;+&#39;:
                return new Add_Operation_Pos();
            case &#39;-&#39;:
                return new Sub_Operation_Pos();                   case &#39;*&#39;:
                return new Mul_Operation_Pos();                   case &#39;&#x2F;&#39;:
                return new Div_Operation_Pos();
            default:
                return new Add_Operation_Pos();
        &#125;
    &#125;
&#125;;
int main()&#123;
    int a,b;
    cin&gt;&gt;a&gt;&gt;b;
    Operation_Pos *p &#x3D; Factory::CreateProduct(&#39;+&#39;);
    p-&gt;var1 &#x3D; a;
    p-&gt;var2 &#x3D; b;
    cout&lt;&lt;p-&gt;GetResult()&lt;&lt;endl;
    
    p &#x3D; Factory::CreateProduct(&#39;*&#39;);
    p-&gt;var1 &#x3D; a;
    p-&gt;var2 &#x3D; b;
    cout&lt;&lt;p-&gt;GetResult()&lt;&lt;endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="2工厂方法模式">2.工厂方法模式</span></h3><p>修正了简单工厂模式中不遵守开放封闭原则。把选择判断移到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可。</p>
<p>应用场景：</p>
<p>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要直到产品类的类名，只需要知道所对应的工厂即可，<strong>具体的产品对象由具体工厂类创建，客户端需要知道创建具体产品的工厂类</strong>。</p>
<p>一个类通过其派生类来指定创建哪个对象：在工厂模式中，<strong>对于抽象工厂类只需要提供一个创建产品的接口，而由其派生类来确定具体要创建的对象</strong>，利用面向对象的多态性和里氏代换原则，程序运行时，派生类对象将<strong>覆盖父类对象</strong>，从而使系统更容易扩展。</p>
<p>将创建对象的任务委托给多个工厂派生类中的某一个，<strong>客户端在使用时可以无需关心是哪个工厂派生类创建产品派生类，需要时再动态指定</strong>，可将具体工厂类的类名存储在配置文件或数据库。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

 &#x2F;&#x2F;here is the product class
class Operation_Pos&#123;
public:
    int var1,var2;
    virtual double GetResult()&#123;
        double res &#x3D; 0;
        return res;
    &#125;
&#125;;

class Add_Operation_Pos : public Operation_Pos
&#123;
public:
     virtual double GetResult()&#123;
         return var1 + var2;
     &#125;
&#125;;

class Sub_Operation_Pos : public Operation_Pos
&#123;
public:
     virtual double GetResult()&#123;
         return var1 - var2;
     &#125;
&#125;;

class Mul_Operation_Pos : public Operation_Pos
&#123;
public:
     virtual double GetResult()&#123;
         return var1 * var2;
     &#125;
&#125;;

class Div_Operation_Pos : public Operation_Pos
&#123;
public:
     virtual double GetResult()&#123;
         return var1 &#x2F; var2;
     &#125;
&#125;;

class Factory&#123;
public:
    virtual Operation_Pos *CreateProduct() &#x3D; 0;
&#125;;

class Add_Factory : public Factory&#123;
public:
    Operation_Pos *CreateProduct()&#123;
        return new Add_Operation_Pos();
    &#125;
&#125;;

class Sub_Factory : public Factory&#123;
public:
    Operation_Pos *CreateProduct()&#123;
        return new Sub_Operation_Pos();
    &#125;
&#125;;

class Mul_Factory : public Factory&#123;
public:
    Operation_Pos *CreateProduct()&#123;
        return new Mul_Operation_Pos();
    &#125;
&#125;;

class Div_Factory : public Factory&#123;
public:
    Operation_Pos *CreateProduct()&#123;
        return new Div_Operation_Pos();
    &#125;
&#125;;

int main()&#123;
    int a,b;
    cin&gt;&gt;a&gt;&gt;b;
    &#x2F;&#x2F;
    Add_Factory *p_fac &#x3D; new Add_Factory();
    &#x2F;&#x2F;
    Operation_Pos *p_pro &#x3D; p_fac-&gt;CreateProduct();
    p_pro-&gt;var1 &#x3D; a;
    p_pro-&gt;var2 &#x3D; b;
    cout&lt;&lt;p_pro-&gt;GetResult()&lt;&lt;endl;
    &#x2F;&#x2F;
    Mul_Factory *p_fac1 &#x3D; new Mul_Factory();
    &#x2F;&#x2F;
    Operation_Pos *p_pro1 &#x3D; p_fac1-&gt;CreateProduct();
    p_pro1-&gt;var1 &#x3D; a;
    p_pro1-&gt;var2 &#x3D; b;
    cout &lt;&lt; p_pro1-&gt;GetResult() &lt;&lt; endl;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="3抽象工厂模式">3.抽象工厂模式</span></h3><p>定义了一个创建一系列相关或相互依赖的接口，而无需指定他们的具体类</p>
<p>应用场景：</p>
<ul>
<li>一个系统不应当依赖于产品类实例如何被创建，组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li>
<li>系统中有多于一个产品族，而每次只是用其中某一个产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li>
<li>产品等级结构稳定，设计完成后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</li>
</ul>
<p>实现方式：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

 &#x2F;&#x2F;here is the product class
class Operation_Pos&#123;
public:
    int var1,var2;
    virtual double GetResult()&#123;
        double res &#x3D; 0;
        return res;
    &#125;
&#125;;

class Add_Operation_Pos : public Operation_Pos
&#123;
public:
     virtual double GetResult()&#123;
         return var1 + var2;
     &#125;
&#125;;

class Sub_Operation_Pos : public Operation_Pos
&#123;
public:
     virtual double GetResult()&#123;
         return var1 - var2;
     &#125;
&#125;;

class Mul_Operation_Pos : public Operation_Pos
&#123;
public:
     virtual double GetResult()&#123;
         return var1 * var2;
     &#125;
&#125;;

class Div_Operation_Pos : public Operation_Pos
&#123;
public:
     virtual double GetResult()&#123;
         return var1 &#x2F; var2;
     &#125;
&#125;;

&#x2F;*............................................*&#x2F;
class Operation_Neg&#123;
public:
    int var1,var2;
    virtual double GetResult()&#123;
        double res &#x3D; 0;
        return res;
    &#125;
&#125;

class Add_Operation_Neg : public Operation_Neg&#123;
public:
    virtual double GetResult()&#123;
        return -(var1 + var2);
    &#125;
&#125;;

class Sub_Operation_Neg:public Operation_Neg&#123;
public:
    virtual double GetResult()&#123;
        return -(var1-var2);
    &#125;
&#125;;

class Mul_Operation_Neg:public Operation_Neg&#123;
public:
    virtual double GetResult()&#123;
        return -(var1*var2);
    &#125;
&#125;;

class Div_Operation_Neg:public Operation_Neg&#123;
public:
    virtual double GetResult()&#123;
        return -(var1&#x2F;var2);
    &#125;
&#125;;

&#x2F;&#x2F;.................................................

&#x2F;&#x2F;here is the factory class

class Factory&#123;
public:
    virtual Operation_Pos *CreateProduct_Pos() &#x3D; 0;
    virtual Operation_Neg *CreateProduct_Neg() &#x3D; 0;
&#125;;

class Add_Factory : public Factory&#123;
public:
    Operation_Pos *CreateProduct_Pos()&#123;
        return new Add_Operation_Pos();
    &#125;
    Operation_Pos *CreateProduct_Neg()&#123;
        return new Add_Operation_Neg();
    &#125;
&#125;;

class Sub_Factory : public Factory&#123;
public:
    Operation_Pos *CreateProduct()&#123;
        return new Sub_Operation_Pos();
    &#125;
    Operation_Pos *CreateProduct_Neg()&#123;
        return new Sub_Operation_Neg();
    &#125;
&#125;;

class Mul_Factory : public Factory&#123;
public:
    Operation_Pos *CreateProduct()&#123;
        return new Mul_Operation_Pos();
    &#125;
    Operation_Pos *CreateProduct_Neg()&#123;
        return new Mul_Operation_Neg();
    &#125;
&#125;;

class Div_Factory : public Factory&#123;
public:
    Operation_Pos *CreateProduct()&#123;
        return new Div_Operation_Pos();
    &#125;
    Operation_Pos *CreateProduct_Neg()&#123;
        return new Div_Operation_Neg();
    &#125;
&#125;;

int main()&#123;
    int a,b;
    cin&gt;&gt;a&gt;&gt;b;
    &#x2F;&#x2F;
    Add_Factory *p_fac &#x3D; new Add_Factory();
    &#x2F;&#x2F;
    Operation_Pos *p_pro &#x3D; p_fac-&gt;CreateProduct_Pos();
    p_pro-&gt;var1 &#x3D; a;
    p_pro-&gt;var2 &#x3D; b;
    cout&lt;&lt;p_pro-&gt;GetResult()&lt;&lt;endl;
    &#x2F;&#x2F;
    Add_Factory * p_fac1  &#x3D; new Add_Factory();
    &#x2F;&#x2F;
    Operation_Neg *p_pro1 &#x3D; p_fac1-&gt;CreateProduct_Neg();
    p_pro1-&gt;var1 &#x3D; a;
    p_pro1-&gt;var2 &#x3D; b;
    cout &lt;&lt; p_pro1-&gt;GetResult() &lt;&lt; endl;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2><span id="观察者模式">观察者模式</span></h2><h3><span id="观察者模式">观察者模式</span></h3><p>定义一种一（被观察类）对多（观察类）的关系，让多个观察对象同时监听一个被观察对象，被观察对象状态发生变化时，会通知所有的观察对象，使他们能够更新自己的状态。</p>
<p>观察者模式存在两种角色:</p>
<ul>
<li>观察者：内部包含被观察者对象，当被观察者对象的状态发生变化时，<strong>更新自己</strong>的状态。（<strong>接收通知更新状态）</strong></li>
<li>被观察者：内部包含了所有观察者对象，当状态发生变化时<strong>通知所有的观察者</strong>更新自己的状态。<strong>（发送通知）</strong></li>
</ul>
<p>应用场景：</p>
<p>当一个对象的改变需要同时改变其他对象，且不知道具体有多少对象有待改变时，应该考虑使用观察者模式。</p>
<p>一个抽象模型有两个方面，其中一个方面依赖于另一个方面，这时可以用观察者模式将这两者封装在独立的对象中使他们各自独立地改变和复用。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;list&gt;
#include&lt;string&gt;
using namespace std;
class Subject;
&#x2F;&#x2F;观察者基类 （内部实例化了被观察者的对象Sub）
class Observer&#123;
protected:
    string name;
    Subject *sub;
public:
    Observer(string name,Subject *sub)&#123;
        this-&gt;name &#x3D; name;
        this-&gt;sub &#x3D; sub;
    &#125;
    virtual void update() &#x3D; 0;
&#125;;

class StockObserver : public Observer&#123;
public:
    StockObserver(string name,Subject *sub):Observer(name,sub)&#123;
        
    &#125;
    void update();
&#125;;

class NBAObserver : public Observer&#123;
public:
    NBAObserver(string name,Subject *sub):Observer(name,sub)&#123;
        
    &#125;
    void update();
&#125;;

&#x2F;&#x2F;被观察者基类 （内部存放了所有的观察者对象，以便状态发生变化时，给观察者发通知）

class Subject&#123;
protected:
    list&lt;Observer *&gt;observers;
public:
    string action ; &#x2F;&#x2F;被观察者对象的状态
    virtual void attach(Observer *) &#x3D; 0;
    virtual void detach(Observer *) &#x3D; 0;
    virtual void notify() &#x3D; 0;
&#125;;

class Secretary : public Subject&#123;
    void attach(Observer *observer)&#123;
        observers.push_back(observer);
    &#125;
    void detach(Observer * observer)&#123;
        list&lt;Observer *&gt;::iterator iter &#x3D; observers.begin();
        while(iter!&#x3D;observers.end())&#123;
            if((*iter) &#x3D;&#x3D; observer)&#123;
                observers.erase(iter);
                return;
            &#125; 
            ++iter;
        &#125;
    &#125;
    
    void notify()&#123;
        list&lt;Observer *&gt;::iterator iter &#x3D;observers.begin();
        while(iter!&#x3D;observers.end())&#123;
            (*iter)-&gt;update();
            ++iter;
        &#125;
    &#125;
&#125;;

void StockObserver :: update()&#123;
    cout&lt;&lt;name &lt;&lt;&quot;收到消息：&quot;&lt;&lt;sub-&gt;action&lt;&lt;endl;
    if(sub-&gt;action &#x3D;&#x3D; &quot;梁所长来了！&quot;)&#123;
        cout&lt;&lt;&quot;我马上关闭股票装作很认真的样子&quot;&lt;&lt;endl;
    &#125;
&#125;

void NBAObserver :: update()&#123;
    cout&lt;&lt;name&lt;&lt;&quot;收到消息：&quot;sub-&gt;action&lt;&lt;endl;
    if(sub-&gt;action &#x3D;&#x3D; &quot;梁所长来了！&quot;)&#123;
        cout&lt;&lt;&quot;我马上关闭NBA，装作认真工作的样子&quot;&lt;&lt;endl;
    &#125;
    
&#125;

int main()&#123;
    Subject *dwq &#x3D; new Secretary();
    Observer *xs &#x3D; new NBAObserver(&quot;xiaoshuai&quot;,dwq);
    Observer *zy &#x3D; new NBAObserver(&quot;zouyue&quot;,dwq);
    Observer *lm &#x3D; new NBAObserver(&quot;limin&quot;,dwq);
    dwq-&gt;attach(xs);
    dwq-&gt;attach(zy);
    dwq-&gt;attach(lm);
    
    dwq-&gt;action &#x3D;&#x3D; &quot;去吃饭了！&quot;;
    dwq-&gt;notify();
    cout&lt;&lt; endl;
    dwq-&gt;action &#x3D; &quot;梁所长来了！&quot;;
    dwq.notify();
    return 0;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出：</p>
<pre class="line-numbers language-none"><code class="language-none">xiaoshuai收到消息
zouyue收到消息
limin收到消息

xiaoshuai收到消息梁所长来了！
我马上关闭NBA，装作认真工作的样子
zouyue收到消息梁所长来了！
我马上关闭NBA，装作认真工作的样子
limin收到消息梁所长来了！
我马上关闭NBA，装作认真工作的样子<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1><span id="面向对象">面向对象</span></h1><p>面向对象：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含数据（成员变量）和动作（成员方法）。</p>
<h2><span id="面向对象的三大特性">面向对象的三大特性</span></h2><p>封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问<strong>，降低耦合性。</strong>——&gt;代码之间应该相互独立 ，降低依赖关系易于扩展。</p>
<p>继承：**<strong>子类继承父类的特征和行为**</strong>，子类有父类的<strong>非private</strong>方法或成员变量，子类可以对父类的方法进行<strong>重写</strong>，<strong>增强</strong>了类之间的<strong>耦合性</strong>，但是当父类的成员变量，成员函数，或者类本身被<strong>final关键字</strong>修饰的时候，修饰的类不能继承，修饰的成员不能重写或修改。</p>
<p>多态：多态就是不同继承类的对象。对同一消息做出不同的响应，<strong>基类的指针指向或绑定到派生类的对象</strong>，使得基类指针呈现不同的表现方式。</p>
<h2><span id="重载重写隐藏的区别">重载，重写，隐藏的区别</span></h2><p>概念解释：·  </p>
<p><strong><u>重载</u>**：是指同一可访问区内被声明几个</strong>具有不同参数列<strong>（参数的类型，个数，顺序）的</strong>同名函数，<strong>根据参数列表确定调用哪个函数，</strong>重载不关心函数的返回类型。**</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;
public:
    void fun(int tmp);
    void fun(float tmp);
    void fun(int tmp,float tmp1);
    void fun(float tmp,int tmp1);
    int fun(int tmp);   &#x2F;&#x2F; error 注意重载不关心函数返回类型
    
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p><strong><u>隐藏</u>**：是指派生类的函数屏蔽了与其同名的基类函数。只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。——–&gt;**在派生类中构建的对象无法调用基类中的同名函数。</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
class Base&#123;
public:
    void fun(int tmp,float tmp1)&#123;
        cout&lt;&lt;&quot;Base::fun(int tmp,float tmp1)&quot;&lt;&lt;endl;
    &#125;   
&#125;;

class Derive: public Base&#123;
public:
    void fun(int tmp)&#123;
        cout&lt;&lt;&quot;Derive :: fun(int tmp)&quot;&lt;&lt;endl; &#x2F;&#x2F;隐藏基类中的同名函数
    &#125;
&#125;;

int main()&#123;
    Derive ex;
    ex.fun(1);
    ex.fun(1,0.01); &#x2F;&#x2F;error :candidate expects 1 arguement 2 provided
    return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>说明：上述代码中ex.fun(1,0.01) ;出现错误，说明派生类中将基类的同名函数隐藏了。若是<strong>想调用基类中的同名函数</strong>，可以<strong>加上类型名</strong>指明 <strong>ex.Base::fun(1,0.01)</strong>,这样就可以调用基类中的同名函数。</p>
<p>**<u>重写（覆盖）</u>**：是指派生类中存在重写定义的函数，函数名，参数列表，返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写函数必须有virtual修饰。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
class Base&#123;
public:
    virtual void fun(int tmp)&#123;
        cout &lt;&lt; &quot;Base :: fun(int tmp):&quot; &lt;&lt; tmp &lt;&lt; endl;

    &#125;
&#125;;
class Derived : public Base&#123;
public:
    virtual void fun(int tmp)&#123;
        cout &lt;&lt; &quot;Derived ::fun(int tmp)&quot; &lt;&lt; tmp &lt;&lt; endl;

    &#125;
&#125;;
int main()&#123;
    &#x2F;&#x2F;Base * p &#x3D; new Derived();
    Derived ex;
    ex.fun(3); &#x2F;&#x2F; Derived :: fun(int) :3
    ex.Base::fun(4); &#x2F;&#x2F;Base::fun(int) :4 
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>重载和重写的区别：</p>
<ul>
<li>范围区别：对于类中函数的重载或者重写而言，<strong>重载发生在同一个类的内部</strong>，<strong>重写发生在不同的类之间</strong>（子类和父类之间）。</li>
<li>参数区别：<strong>重载的函数</strong>需要与原函数有<strong>相同的函数名</strong>，<strong>不同的参数列表</strong>，不关注函数的返回值类型，<strong>重写的函数的函数名，参数列表和返回值类型都需要和原函数相同</strong>。父类中被重写的函数需要<strong>有virtual修饰</strong>。</li>
<li>Virtual关键字:重写的函数<strong>基类中必须有virtual关键字</strong>修饰，重载的函数可以有virtual关键字的修饰也可以没有。</li>
</ul>
<p>隐藏和重写，重载的区别：</p>
<p>范围区别：隐藏与重载范围不同。隐藏发生在不同类中。</p>
<p>参数区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同。<strong>当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被</strong><u>隐藏</u><strong>而不是</strong>被<u>重写。</u></p>
<p>如何理解C++是面向对象编程</p>
<p>说明：该问题最好结合自己的项目经历进行展开解释。或举一些恰当的例子，同时对比下面向过程编程。</p>
<ul>
<li>面向过程编程：一种<strong>以执行程序操作的过程或函数为中心编写软件的方法</strong>。程序的<strong>数据</strong>通常存储在变量中，与这些<strong>过程是分开的</strong>。所以必须将变量传递给需要使用它们的函数。缺点：随着程序变得越来越复杂，<strong>程序数据与运行代码的分离可能会导致问题</strong>。例如，程序的规范经常会发生变化，从而需要更改数据的格式或数据结构的设计。当数据结构发生变化时，对数据进行操作的代码也必须更改为接受新的格式。查找需要更改的所有代码会为程序员带来额外的工作，并增加了使代码出现错误的机会。</li>
<li>面向对象编程（Objective-Oriented Programming ,OOP），以创建和使用对象为中心。一个对象（Object）就是一个软件实体，它将<strong>数据和程序在一个单元中组合起来</strong>。对象的数据项，也称其为属性，存储在成员变量中。对象执行的过程称其为成员函数。将对象的数据绑在一起则被称之为封装。</li>
</ul>
<p><strong>面向对象编程的进一步说明</strong>：</p>
<p>面向对象编程<strong>将数据成员和成员函数封装到一个类</strong>中，并声明数据成员和成员函数的访问级别（public ，private，protected）,以便控制类对象对数据成员和函数的访问，对数据成员起到一定的保护作用。而且在类的对象调用成员函数的时候，只知道成员函数的名，参数列表以及返回值类型即可，<strong>无需了解其函数的实现原理</strong>。当类<strong>内部的数据成员或者成员函数发生改变时</strong>，<strong>不影响类外部的代码</strong>。</p>
<h2><span id="多态的实现">多态的实现</span></h2><p>多态：多态就是不同继承类的对象。对同一消息做出不同的响应，基类的指针呈现不同的表现方式。<strong>在基类函数前加上virtual关键字</strong>，在派生类中<strong>重写</strong>该函数，<strong>运行时将会根据对象的实际类型来调用相应的函数</strong>。如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。</p>
<p>实现方法：多态是通过虚函数实现的，虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。</p>
<p>实现过程：</p>
<ul>
<li>1.在<strong>类中用virtual关键字声明的函数叫做虚函数</strong>。</li>
<li>2.存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，<strong>该对象有一个指向虚函数表的虚表指针</strong>（虚函数表和类对应的，虚函数表指针和对象对应）。</li>
<li>3.当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。</li>
</ul>
<p>简单解释：基类指针指向派生类对象时，通过派生类对象的虚表指针找到虚函数表，进而找到相应的虚函数。 Derive::f()进行调用。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>语言特性</title>
    <url>/2021/07/26/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1><span id="语言特性">语言特性</span></h1><h2><span id="常量指针和指针常量的区别">常量指针和指针常量的区别</span></h2><h3><span id="常量指针">常量指针</span></h3><p>常量指针本质上是一个指针，只不过这个指针指向的对象是常量。</p>
<p>特点：const的位置在指针声明运算符 *的左侧。只要const位于 * 的左侧，无论他在类型名的左边或右边，都表示指向常量的指针。（可以这样理解，* 左侧表示指针指向的对象，该对象为常量，那么该指针为常量指针。）</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">const int * p;
int const *p;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>注意1:指针指向的对象不能通过这个指针来修改，也就是说常量指针可以被赋值为变量的地址，之所以叫做<strong>常量指针，是限制了通过这个指针修改变量的值。</strong></p>
<p>例如：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
int main()&#123;
    const int c_var  &#x3D; 8;
    const int *p &#x3D; &amp;c_var;
    *p &#x3D; 6; &#x2F;&#x2F;error assignment of read-only location &#39;*p&#39;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>注意2:虽然常量指针指向的对象不能变化，可是因为常量指针本身是一个变量，因此可以被重新赋值。</p>
<p>例如：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
int main()&#123;
    const int c_var1 &#x3D; 8;
    const int c_var2 &#x3D; 8;
    const int *p &#x3D; &amp;c_var1;
    p &#x3D; &amp;c_var2;  &#x2F;&#x2F;常量指针p是地址
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="指针常量">指针常量</span></h3><p>指针常量的本质上是一个常量，只不过这个常量的值是一个指针。</p>
<p>特点：const位于指针声明操作符右侧，表明该对象本身是一个常量，* 左侧表示指针指向的类型 ，即以 * 为分界线，其左侧表示指针指向的类型，右侧表示指针本身的性质。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int var;
int * const c_p&#x3D; &amp;var;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>注意1：指针常量的值是指针，这个值因为是常量，所以指针本身不能改变。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
int main()&#123;
    int var,var1;
    int *const c_p &#x3D; &amp;var;
    *c_p &#x3D; &amp;var1;   &#x2F;&#x2F;error assignment of read_only variable &#39;c_p&#39;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>注意2: 指针的内容可以改变</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
int main()&#123;
    int var&#x3D; 3;
    int * const c_var &#x3D; &amp;var;
    *c_var &#x3D; 12;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="函数指针和指针函数的区别">函数指针和指针函数的区别</span></h2><h3><span id="指针函数">指针函数</span></h3><p>指针函数本质上是一个函数，只不过该函数的返回值是一个指针。相对于普通函数而言，只是返回值是指针。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
struct Type&#123;
    int var1;
    int var2;
&#125;;
Type * fun(int tmp1,int tmp2)&#123;
    Type *t &#x3D; new Type();
    t-&gt;var1 &#x3D; tmp1;
    t-&gt;var2 &#x3D; tmp2;
    return t;
&#125;
int main()&#123;
    Type *t &#x3D; fun(5,6);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="函数指针">函数指针</span></h3><p>函数指针本质上是一个指针变量，只不过这个指针指向一个函数。函数指针即指向函数的指针。</p>
<p>举例：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iosteam&gt;
using namespace std;
int fun1(int tmp1,int tmp2)&#123;
    return tmp1 * tmp2;
&#125;
int fun2(int tmp1,int tmp2)&#123;
    return tmp1&#x2F;tmp2;
&#125;
int main()&#123;
    int (*fun)(int x,int y);
    fun &#x3D; fun1;
    cout&lt;&lt;fun(15,5)&lt;&lt;endl;
    fun &#x3D; fun2;
    cout&lt;&lt;fun(15,5)&lt;&lt;endl;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="区别">区别</span></h3><ul>
<li><p>本质不同</p>
<p>指针函数本质上是一个函数，其返回值为指针。</p>
<p>函数指针本质上是一个指针变量，其值指向一个函数。</p>
</li>
<li><p>定义形式不同</p>
<p>指针函数：</p>
<pre class="line-numbers language-none"><code class="language-none">int  * fun(int tmp1,int tmp2) ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里 * 表示函数返回值类型是指针类型函数指针:</p>
<pre class="line-numbers language-none"><code class="language-none">int (*fun)(int tmp1,int tmp2);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里的 * 表示变量本身是指针类型。</p>
</li>
</ul>
<h2><span id="左值和右值">左值和右值</span></h2><p>左值：指表达式结束后依然存在的持久对象。</p>
<p>右值：表达式结束就不再存在的临时对象。</p>
<p>左值和右值的区别：左值持久，右值短暂</p>
<p>右值引用和左值引用的区别：</p>
<p>左值引用不能绑定到要转换的表达式、字面常量或返回右值的表达式。右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。<br><strong>右值引用必须绑定到右值的引用，通过 &amp;&amp; 获得</strong>。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。<br><strong>std::move 可以将一个左值强制转化为右值</strong>，继而可以通过右值引用使用该值，以用于移动语义。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

void fun1(int&amp; tmp) 
&#123; 
  cout &lt;&lt; &quot;fun1(int&amp; tmp):&quot; &lt;&lt; tmp &lt;&lt; endl; 
&#125; 

void fun2(int&amp;&amp; tmp) 
&#123; 
  cout &lt;&lt; &quot;fun2(int&amp;&amp; tmp)&quot; &lt;&lt; tmp &lt;&lt; endl; 
&#125; 

int main() 
&#123; 
  int var &#x3D; 11; 
  fun1(12); &#x2F;&#x2F; error: cannot bind non-const lvalue reference of type &#39;int&amp;&#39; to an rvalue of type &#39;int&#39;
  fun1(var);
  fun2(1); 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2><span id="move函数的实现原理">move()函数的实现原理</span></h2><p>move()两个作用：</p>
<p><strong>独享指针所有权的转移</strong></p>
<p><strong>左值到右值属性的转移</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;
typename remove_reference&lt;T&gt;::type &amp;&amp; move(T&amp;&amp;t)&#123;
    return static_cast&lt;typename_reference&lt;T&gt;::type &amp;&amp;&gt;(t);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>说明：<strong>引用折叠原理</strong></p>
<p>右值传递给上述的形参T&amp;&amp; 依然是右值，<strong>即T&amp;&amp; &amp;&amp; 相当于 T&amp;&amp;</strong></p>
<p>左值传递给上述的形参T&amp;&amp;依然是左值，<strong>即T&amp;&amp; &amp;相当于T&amp;</strong></p>
<p>小结：通过引用折叠原理可以知道，move()函数的形参既可以左值也可以是右值。</p>
<p><strong>remove_reference</strong>具体实现：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;原始的，最通用版本
template&lt;typename T&gt;struct remove_reference&#123;
    typedef T type;
&#125;
&#x2F;&#x2F;部分版本特例化 将用于左值引用和右值引用
template&lt;class T&gt;struct remove_reference&lt;T&amp;&gt;  &#x2F;&#x2F;左值引用
&#123;
    typedef T type;
&#125;
template&lt;class T&gt; struct remove_reference&lt;T&amp;&amp;&gt; &#x2F;&#x2F;右值引用
&#123;
    typedef T  type;  
&#125;
&#x2F;&#x2F;举例如下 下列定义的a,b,c三个变量都是int类型
int i;
remove_reference&lt;decltype(42)&gt;::type a;  &#x2F;&#x2F;使用原版本
remove_reference&lt;decltype(i)&gt;::type a;  &#x2F;&#x2F;使用左值引用
remove_reference&lt;decltype(std::move(i))&gt;::type b;  &#x2F;&#x2F;使用右值引用特例版本
&#x2F;&#x2F;decltype 类似auto 可以进行类型推导<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>举例：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int var &#x3D; 10;
&#x2F;&#x2F;转化过程
1.std::move(var) &#x3D;&gt;std::move(int &amp;&amp; &amp;)&#x3D;&gt;折叠后std::move(int &amp;)
2.此时：T类型为int &amp; ，typename remove_reference&lt;T&gt;::type 为 int，这里使用remove_reference 的左值引用的特例化版本
3.通过static_cast 将int &amp; 强制转换为int &amp;&amp;
整个std::move被实例化如下：
    
int &amp;&amp;move(int &amp;t)&#123;
    return static_cast&lt;int &amp;&amp;&gt;(t);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>总结：std::move()实现原理：</p>
<ul>
<li>利用<strong>引用折叠原理</strong>将右值经过T&amp;&amp;传递类型保持不变还是右值，而左值经过T&amp;&amp;变为普通的左值引用，以<strong>保证模板可以传递任意实参</strong>，且保持类型不变。</li>
<li>然后<strong>通过remove_reference移除引用，得到具体的类型T</strong></li>
<li>最后<u>通过static_cast进行强制类型转换，返回T&amp;&amp;右值引用</u></li>
</ul>
<h2><span id="指针的大小和用法">指针的大小和用法</span></h2><p>指针：只想另外一种类型的复合类型</p>
<p>指针的大小：在64位计算机中，<strong>指针占8个字节空间</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
int main()&#123;
    int *p &#x3D; nullptr;
    cout&lt;&lt;sizeof(p)&lt;&lt;endl; &#x2F;&#x2F;8
    char *p1 &#x3D;nullptr;
    cout&lt;&lt;sizeof(p1)&lt;&lt;endl; &#x2F;&#x2F;8
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>指针的用法</p>
<p>1.指向普通对象的指针</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
class A&#123;
    
&#125;;
int main()&#123;
    A * p &#x3D; new A();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>2.指向常量对象的指针，常量指针</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
int main()&#123;
    const int c_var &#x3D; 10;
    const int *p &#x3D; &amp;c_var;
    cout&lt;&lt;*p&lt;&lt;endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>3.指向函数的指针：函数指针</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
int add(int a,int b)&#123;
    return a+b;
&#125;
int main(void)&#123;
    int (*fun_p)(int,int);
    fun_p &#x3D; add;
    cout&lt;&lt;fun_p(1,6)&lt;&lt;endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>4.<strong>指向对象成员的指针</strong>，包括指向<strong>对象成员函数</strong>的指针和指向<strong>对象成员变量</strong>的指针。特别注意：定义指向成员函数的指针时，要<strong>标明</strong>指针所属的<strong>类。</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
class A&#123;
public:
    int var1,var2;
    int add()&#123;
        return var1 * var2;
    &#125; 
&#125;;
int main()&#123;
    A ex;
    ex.var1 &#x3D; 3;
    ex.var2 &#x3D; 4;
    int *p &#x3D; &amp;ex.var1; &#x2F;&#x2F;指向对象成员变量的指针
    cout&lt;&lt;*p&lt;&lt;endl;
    
    int (A::*fun_p)();
    fun_p &#x3D; &amp;A::add; &#x2F;&#x2F;指向对象成员函数的指针fun_p
    cout&lt;&lt; (ex.*fun_p)()&lt;&lt;endl; &#x2F;&#x2F;函数指针 
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>5.this指针：指向类的当前对象的<strong>指针常量</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
class A&#123;
public:
    void set_name(string tmp)&#123;
        this-&gt;name &#x3D; tmp;
    &#125;
    void set_age(int tmp)&#123;
        this-&gt;age  &#x3D; tmp;
    &#125;
    void set_sex(int tmp)&#123;
        this-&gt;sex &#x3D; tmp;
    &#125;
    void show()&#123;
        cout&lt;&lt;&quot;Name : &quot;&lt;&lt;this-&gt;name&lt;&lt;endl;
        cout&lt;&lt;&quot;Age : &quot;&lt;&lt;this-&gt;age&lt;&lt;endl;
        cout&lt;&lt;&quot;Sex : &quot;&lt;&lt;this-&gt;sex&lt;&lt;endl;
    &#125;
private:
    string name;
    int age;
    int sex;
&#125;;
int main()&#123;
    A *p &#x3D; new A();
    p-&gt;set_name(&quot;Alice&quot;);
    p-&gt;set_age(16);
    p-&gt;set_sex(1);
    p-&gt;show();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="悬空指针和野指针">悬空指针和野指针</span></h2><p>悬空指针：</p>
<p>若指针指向一块内存空间，当这块内存空间被释放后，该指针仍然指向这块内存空间，此时称该指针为悬空指针。</p>
<p>举例：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void *p &#x3D; malloc(size);
free(p);
&#x2F;&#x2F;此时p指向的内存空间已经被释放，p就是悬空指针
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>


<p>野指针：</p>
<p>“野指针”是指不确定其指向的指针，未初始化的指针为野指针。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void *p;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<h2><span id="强制类型转换">强制类型转换</span></h2><p>static_cast:用于数据的强制类型转换，强制将一种数据类型转换为另一种数据类型。</p>
<ol>
<li>用于基本数据类型的转换</li>
<li>用于类层次之间的基类和派生类之间<strong>指针或者引用的转换</strong>（不要求必须包含虚函数，但是必须是有相互联系的类），<strong>进行上行转换（派生类的指针或引用转换成基类表示）是安全的</strong>，<strong>进行下行转换</strong>（基类的指针或引用转换成派生类表示），由于<strong>没有动态类型检查</strong>，所以是不安全的，<strong>最好用dynamic_cast进行下行转换</strong>。</li>
<li>可以将空指针转化为目标类型的空指针</li>
<li>可以将任何类型的表达式转化为void类型</li>
</ol>
<p>const_cast：强制去掉常量属性，不能用于去掉变量的常量性，只能<strong>用于去除指针和引用的常量性</strong>，将常量指针转化为非常量指针或者将常量引用转化为非常量引用（注意：表达式的类型和要转化的类型是相同的）。</p>
<p>reinterpret_cast:改变指针或引用的类型，将指针或引用转换为一个足够长度的整型，将整型化为指向或引用类型。</p>
<p>dynamic_cast：</p>
<ul>
<li>其他三种都是编译时完成的，<strong>动态类型转换是在程序运行时处理的</strong>，运行时会进行类型检查。</li>
<li><strong>只能用于带有虚函数的基类或派生类的指针或引用对象的转换</strong>，转换成功<strong>返回指向类型的指针或引用</strong>，转换失败返回NULL，<strong>不能用于基本数据类型的转换</strong>。</li>
<li>在<strong>向上进行转换时</strong>，即派生类类的指针转换成基类类的指针<strong>和static_cast效果是一样</strong>的。（这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）</li>
</ul>
<p>上行转换永远是安全的，下行转换建议使用dynamic_cast.</p>
<h2><span id="判断结构体是否相等">判断结构体是否相等</span></h2><p>需要重载操作符 == 判断两个结构体是否相等 ，<strong>不能用函数memcmp来判断两个结构体是否相等</strong>，因为memcmp函数是<strong>逐个字节进行比较的</strong>，而结构体存在<strong>内存空间中保存时存在字节对齐</strong>，字节对齐时补的字节内容是随机的，会产生<strong>垃圾值</strong>，所以无法进行比较。</p>
<p>利用运算符重载来实现结构体对象的比较.</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
struct A
&#123;
    char c;
    int val;
    A(char c_tmp,int tmp):c(c_tmp),val(tmp)&#123;&#125;
    friend bool operator&#x3D;&#x3D;(const A &amp;tmp1, const A &amp;tmp2);
    &#x2F;&#x2F;友元运算符重载函数
&#125;;

bool operator&#x3D;&#x3D;(const A &amp;tmp1,const A &amp;tmp2)&#123;
    return (tmp1.c &#x3D;&#x3D; tmp2.c &amp;&amp; tmp1.val &#x3D;&#x3D; tmp2.val);
&#125;

int main()&#123;
    A ex1(&#39;a&#39;, 90), ex2(&#39;b&#39;, 80);
    if(ex1 &#x3D;&#x3D; ex2)&#123;
        cout &lt;&lt; &quot;ex1&#x3D;&#x3D;ex2&quot; &lt;&lt; endl;
    &#125;
    else&#123;
        cout &lt;&lt; &quot;ex1!&#x3D;ex2&quot; &lt;&lt; endl;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2><span id="参数传递">参数传递</span></h2><p>参数传递的三种方式：</p>
<ul>
<li><strong>值传递：形参是实参的拷贝</strong>，函数对形参的所有操作不会影响实参。</li>
<li>指针传递：本质上是值传递，只不过<strong>拷贝的是指针的值</strong>，拷贝之后，<strong>实参和形参是不同的指针，通过指针可以间接的访问指针所指向的对象</strong>，从而修改它所指向的对象的值。</li>
<li><strong>引用传递</strong>：当形参是引用类型时，我们说<strong>它对应的实参被引用传递。</strong></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
void fun1(int tmp)&#123;
    cout &lt;&lt; &amp;tmp &lt;&lt; endl;
&#125;

void fun2(int *tmp)&#123;
    cout &lt;&lt; tmp &lt;&lt; endl;
&#125;

void fun3(int &amp;tmp)&#123;
    cout &lt;&lt; &amp;tmp &lt;&lt; endl;
&#125;
int main()&#123;
    int var &#x3D; 5;
    cout &lt;&lt; &quot;var 在主函数中的地址：&quot; &lt;&lt; &amp;var &lt;&lt; endl;
    cout &lt;&lt; &quot;var 值传递时的地址：&quot;;
    fun1(var);
    cout &lt;&lt; &quot;var 指针传递时的地址：&quot;;
    fun2(&amp;var);
    cout &lt;&lt; &quot;var 引用传递时的地址：&quot;;
    fun3(var);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>说明：从上述代码的运行结果可以看出，只有在值传递时，形参和实参的地址不一样。在函数体内操作的不是变量本身，引用传递和指针传递，在函数体内操作的时变量本身。</p>
<h2><span id="模板实现">模板实现</span></h2><h3><span id="模板">模板</span></h3><p>模板：创建类或者函数的蓝图或者公式，分为<strong>函数模板和类模板</strong>。</p>
<p>实现方式：模板定义以关键字template开始，后跟一个模板参数列表。</p>
<p>模板参数列表不能为空</p>
<p>模板类型参数前必须使用关键字class或者typename，在模板参数列表中这两个关键字含义相同，可互换使用。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T,typename U...&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>函数模板：通过定义一个函数模板，可以避免每一种类型定义一个新函数。</p>
<ul>
<li>对于函数模板而言，<strong>模板类型参数可以用来指定返回类型或函数的参数类型</strong>，以及在函数体内用于变量声明或类型转换。</li>
<li>函数模板实例化：当调用一个模板时，<strong>编译器用函数实参来推断模板实参</strong>，从而使用实参的类型来确定绑定到模板参数的类型。</li>
</ul>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;

template&lt;typename T&gt;
T add_fun(const T &amp;tmp1,const T &amp;tmp2)&#123;
    return tmp1 + tmp2;
&#125;
int main()&#123;
    int var1, var2;
    cin &gt;&gt; var1 &gt;&gt; var2;
    cout &lt;&lt; add_fun(var1, var2);

    double var3, var4;
    cin &gt;&gt; var3 &gt;&gt; var4;
    cout &lt;&lt; add_fun(var3, var4);

    &#x2F;&#x2F; cout &lt;&lt; add_fun(var1, var3); 两者类型不同 出错
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>类模板：类似函数模板<strong>，类模板以关键字template开始</strong>，后跟模板参数列表。但是，编译器<strong>不能为类模板推断模板参数类型</strong>，需要在使用该类模板时，在模板后面的<strong>尖括号中指明类型。</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

template &lt;typename T&gt;
class Complex
&#123;
public:
    &#x2F;&#x2F;构造函数
    Complex(T a, T b)
    &#123;
        this-&gt;a &#x3D; a;
        this-&gt;b &#x3D; b;
    &#125;

    &#x2F;&#x2F;运算符重载
    Complex&lt;T&gt; operator+(Complex &amp;c)
    &#123;
        Complex&lt;T&gt; tmp(this-&gt;a + c.a, this-&gt;b + c.b);
        cout &lt;&lt; tmp.a &lt;&lt; &quot; &quot; &lt;&lt; tmp.b &lt;&lt; endl;
        return tmp;
    &#125;

private:
    T a;
    T b;
&#125;;

int main()
&#123;
    Complex&lt;int&gt; a(10, 20);
    Complex&lt;int&gt; b(20, 30);
    Complex&lt;int&gt; c &#x3D; a + b;

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="函数模板和类模板的区别">函数模板和类模板的区别</span></h3><p>实例化方式不同 ：<strong>函数模板实例化</strong>由<strong>编译程序在处理函数调用时自动完成</strong>。<strong>类模板</strong>实例化需要在程序中<strong>显式指定。</strong></p>
<p>实例化的结果不同：函数模板实例化是一个函数。类模板实例化后是一个类</p>
<p>默认参数：<strong>类模板在模板参数列表中可以有默认参数</strong>。</p>
<p><u>特化</u>：函数模板只能全特化 ，而类模板可以全特化也可以偏特化。</p>
<p>调用方式不同：函数模板可以隐式调用，也可以显式调用，<strong>类模板只能显式调用</strong>。</p>
<p>函数模板调用方式举例：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
template&lt;typename T&gt;
T add_fun(const T &amp;tmp1,const T &amp;tmp2)&#123;
    return tmp1 + tmp2;
&#125;
int main()&#123;
    int var1, var2;
    cin &gt;&gt; var1 &gt;&gt; var2;
    cout &lt;&lt; add_fun&lt;int&gt;(var1, var2); &#x2F;&#x2F;显式调用

    double var3, var4;
    cin &gt;&gt; var3 &gt;&gt; var4;
    cout &lt;&lt; add_fun(var3, var4);  &#x2F;&#x2F;隐式调用
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="可变参数模板">可变参数模板</span></h3><p>可变参数模板：接受可变数目参数的模板函数或模板类</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++进阶笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2021/02/01/sql/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1409311773&auto=1&height=66"></iframe>

<p>mysql的学习笔记(持续更新中)<br>mysql<br>##基础操作</p>
<h3><span id="登陆mysql">登陆mysql</span></h3><p>mysql -uroot-p输入密码</p>
<h3><span id="查看数据库信息的基本指令">查看数据库信息的基本指令</span></h3><p>–显示数据库<br>show databases;<br>–如何在数据库服务器中创建我们的数据库<br>create database test;<br>–切换数据库<br>use test<br>–显示数据库中所有的表<br>show tables;<br>–如何创建一个数据表<br>create table pet(<br>name varchar(20),<br>owner varchar(20),<br>species varchar(20),<br>sex char(1),<br>birth date,<br>death date<br>);<br>-查看数据表结构<br>mysql-describe pet;<br>省略写成 desc pet<br>–如何查看数据表 中的记录<br>mysql&gt; select *from pet;<br>Empty set (0.01 sec)<br>–如何往数据表中添加数据记录<br>insert into pet values(‘pul’,’Die’,’hamer’,’f’,’1990-3-3’,NULL);<br>//大小写均可以<br>INSERT INTO pet VALUES (‘puffball’, ‘Diane’, ‘hamster’, ‘f’, ‘1990-03-30’, NULL);<br>inser into pet values(‘旺财’,’周星驰’,’dog’,’公’,’1996-3-1’,NULL);<br>–mysql 常用数据类型有哪些<br>mysql 支持多种类型，可以分为三类<br>create table testType<br>(<br>    number TINYINT<br>    );</p>
<p>INSERT INTO testType VALUES(127);<br>select * from testType;<br>+——–+<br>| number |<br>+——–+<br>|    127 |<br>+——–+<br>1 row in set (0.00 sec)</p>
<h3><span id="数据记录常见操作">数据记录常见操作</span></h3><p>–增加<br>INSERT<br>INSERT INTO pet VALUES (‘puffball’, ‘Diane’, ‘hamster’, ‘f’, ‘1990-03-30’, NULL);<br>–删除<br>Delete<br>删除数据<br>DELETE FROM pet where name = ‘squirrel’;<br>删除表<br>delete table pet;<br>–修改<br>update<br>UPDATE pet SET name = ‘squirrel’ where owner = ‘Diane’;<br>–查询<br>select<br>SELECT * from pet;</p>
<h2><span id="mysql建表约束-sql">mysql建表约束 .sql</span></h2><h3><span id="1主键约束">1.主键约束</span></h3><p>他能够唯一确定一张表中的一条记录，也就是我们通过给某个字段添加约束，使得该字段不重复且不为空<br>create table user(<br>    id int primary key,<br>    name varchar(20)<br>    );<br>INSERT INTO user VALUES(1,’张三’);<br>INSERT INTO user VALUES(2,’李四’);<br>//注意一定要注意逗号等符号的格式，中英文切换容易造成格式错误</p>
<h3><span id="2联合主键">2.联合主键</span></h3><p>–只要联合的主键值加起来不重复就可以 //完全重复不可以.其中至少有一个不相同可以<br>create table user2(<br>id int,<br>name varchar(20),<br>password varchar(20),<br>primary key (id,name)<br>);<br>insert into user2 values(1,’张三’,’123’);<br>insert into user2 values(2,’张三’,’123’);<br>insert into user2 values(1,’李四’,’123’);<br>insert into user2 values(NULL,’李四’,’123’);<br>//并且主键值都不能为空</p>
<h4><span id="-添加主键约束">- 添加主键约束</span></h4><p>– 如果忘记设置主键，还可以通过SQL语句设置（两种方式）：<br>ALTER TABLE user ADD PRIMARY KEY(id);//选择数据表，然后添加数据类型为主键约束<br>ALTER TABLE user MODIFY id INT PRIMARY KEY;//将数据表中的某一个数据修改为主键约束</p>
<h3><span id="3自增约束">3.自增约束</span></h3><p>–自增约束的主键由系统自动递增分配<br>create table user(<br>    id int primary key auto_increment,<br>    name varchar(20));</p>
<h3><span id="4唯一约束">4.唯一约束</span></h3><p>insert into user5 values(1,’张三’);</p>
<p>create table user6(<br>    id int,<br>    name varchar(20),<br>    unique (name));<br>create table user7(<br>    id int,<br>    name varchar(20)unique);<br>create table user8(<br>    id int,<br>    name varchar(20),<br>    unique (id,name));<br>mysql&gt; desc user8;<br>+——-+————-+——+—–+———+——-+<br>| Field | Type        | Null | Key | Default | Extra |<br>+——-+————-+——+—–+———+——-+<br>| id    | int         | YES  | MUL | NULL    |       |<br>| name  | varchar(20) | YES  |     | NULL    |       |<br>+——-+————-+——+—–+———+——-+</p>
<p>insert into user8 values(1,’张三’);<br>insert into user8 values(1,’张三’);<br>如何删除唯一约束<br>–mysql&gt; alter table user7 drop index name;<br>Query OK, 0 rows affected (0.00 sec)<br>Records: 0  Duplicates: 0  Warnings: 0</p>
<p>mysql&gt; desc user7;<br>+——-+————-+——+—–+———+——-+<br>| Field | Type        | Null | Key | Default | Extra |<br>+——-+————-+——+—–+———+——-+<br>| id    | int         | YES  |     | NULL    |       |<br>| name  | varchar(20) | YES  |     | NULL    |       |<br>+——-+————-+——+—–+———+——-+<br>–modify添加<br>alter table user7 modify name varchar(20) unique;</p>
<h3><span id="5非空约束">5.非空约束</span></h3><p>–修饰字段不能为空NULL<br>create table user9(<br>    id int,<br>    name varchar(20) not NULL);<br>INSERT INTO user9(id)values(1);</p>
<p>–mysql&gt; INSERT INTO user9(id)values(1);<br>ERROR 1364 (HY000): Field ‘name’ doesn’t have a default VALUE</p>
<p>INSERT INTO user9(name)values(‘zhang’);<br>INSERT INTO user9 values(1,’zhang’);<br>//设定name为非空值，则不能为空，id可为空<br>mysql&gt; select * from user9;<br>+——+——-+<br>| id   | name  |<br>+——+——-+<br>| NULL | zhang |<br>|    1 | zhang |<br>+——+——-+<br>2 rows in set (0.00 sec)</p>
<a id="more"></a>
<p>–默认约束<br>–就是当我们插入字段值时，如果没有传值就会使用默认值<br>create table user10(<br>id int,<br>name varchar(20),<br>age int default 10);<br>mysql&gt; desc user10;<br>+——-+————-+——+—–+———+——-+<br>| Field | Type        | Null | Key | Default | Extra |<br>+——-+————-+——+—–+———+——-+<br>| id    | int         | YES  |     | NULL    |       |<br>| name  | varchar(20) | YES  |     | NULL    |       |<br>| age   | int         | YES  |     | 10      |       |<br>+——-+————-+——+—–+———+——-+<br>3 rows in set (0.00 sec)<br>insert into user10 (id,name)values(1,’zhangsan’);<br>//age 未赋值 所以age显示默认值<br>mysql&gt; select * from user10;<br>+——+———-+——+<br>| id   | name     | age  |<br>+——+———-+——+<br>|    1 | zhangsan |   10 |<br>+——+———-+——+<br>1 row in set (0.00 sec)</p>
<h3><span id="6外键约束">6.外键约束</span></h3><p>–涉及到两个表 父表子表<br>–主表 副表<br>–班级<br>create table classes(<br>id int primary key,<br>name varchar(20)<br>);</p>
<p>–学生表<br>create table students(<br>id int primary key,<br>name varchar(20),<br>class_id int,<br>foreign key (class_id) references classes (id)<br>);</p>
<p>insert into classes values(1,’一班’);<br>insert into classes values(2,’二班’);<br>insert into classes values(3,’三班’);<br>insert into classes values(4,’四班’);</p>
<p>mysql&gt; select * from classes;<br>+—-+——–+<br>| id | name   |<br>+—-+——–+<br>|  1 | 一班   |<br>|  2 | 二班   |<br>|  3 | 三班   |<br>|  4 | 四班   |<br>+—-+——–+<br>4 rows in set (0.00 sec)<br>–删除主表中的数据</p>
<p>mysql&gt; delete from classes where id=4;<br>Query OK, 1 row affected (0.01 sec)</p>
<p>mysql&gt; select * from classes;<br>+—-+——–+<br>| id | name   |<br>+—-+——–+<br>|  1 | 一班   |<br>|  2 | 二班   |<br>|  3 | 三班   |<br>+—-+——–+<br>3 rows in set (0.00 sec)</p>
<p>insert into students values(1001,’zhangsan’,1);<br>insert into students values(1002,’zhangsan’,2);<br>insert into students values(1003,’zhangsan’,3);<br>//因为刚才通过delete和删除了四班 所以只输入前三组数据<br>insert into students values(1004,’zhangsan’,4);<br>//查看结果没有问题 classses父表中的班级数据被子表引用<br>mysql&gt; select * from students;<br>+——+———-+———-+<br>| id   | name     | class_id |<br>+——+———-+———-+<br>| 1001 | zhangsan |        1 |<br>| 1002 | zhangsan |        2 |<br>| 1003 | zhangsan |        3 |<br>+——+———-+———-+<br>3 rows in set (0.00 sec)<br>再次尝试删除主表数据</p>
<p>mysql&gt; delete from classes where id=3;<br>ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (<code>test</code>.<code>students</code>, CONSTRAINT <code>students_ibfk_1</code> FOREIGN KEY (<code>class_id</code>) REFERENCES <code>classes</code> (<code>id</code>))<br>得到的结果是erro 说明当主表的记录被副表引用后，是不可以被删除的。但是被引用前可以随意删除</p>
<h2><span id="5数据库的三大设计范式sql">5.数据库的三大设计范式.sql</span></h2><h3><span id="1nf">1NF</span></h3><p>  INF<br>  –数据表中的 所有字段都是不可分割的原子值<br>  create table student2(<br>  id int primary key,<br>  name varchar(20),<br>  address varchar(30)<br>  );</p>
<p>  insert into student2 values(1,’zhangsan’,’武侯区武侯大道100号’);<br>  insert into student2 values(2,’lisi’,’武侯区京城大道200号’);<br>  insert into student2 values(3,’wang5’,’高新区王府大道300号’);<br>mysql&gt; select * from student2;<br>+—-+———-+—————————–+<br>| id | name     | address                     |<br>+—-+———-+—————————–+<br>|  1 | zhangsan | 武侯区武侯大道100号         |<br>|  2 | lisi     | 武侯区京城大道200号         |<br>|  3 | wang5    | 高新区王府大道300号         |<br>+—-+———-+—————————–+<br>3 rows in set (0.00 sec)</p>
<p>–字段值还可以继续拆分的就不满足第一范式<br> create table student3(<br> id int primary key,<br> name varchar(20),<br> district varchar(30),<br> number varchar(30));</p>
<p>先创建了一个数据表，之后发现数据表中数据不完善，需要再添加一个变量的时候，这里使用alter命令。<br>mysql&gt; alter table student3 add details varchar(30);<br>Query OK, 0 rows affected (0.01 sec)<br>Records: 0  Duplicates: 0  Warnings: 0</p>
<p>mysql&gt; desc student3;<br>+———-+————-+——+—–+———+——-+<br>| Field    | Type        | Null | Key | Default | Extra |<br>+———-+————-+——+—–+———+——-+<br>| id       | int         | NO   | PRI | NULL    |       |<br>| name     | varchar(20) | YES  |     | NULL    |       |<br>| district | varchar(30) | YES  |     | NULL    |       |<br>| number   | varchar(30) | YES  |     | NULL    |       |<br>| details  | varchar(30) | YES  |     | NULL    |       |<br>+———-+————-+——+—–+———+——-+<br>//添加<br>mysql&gt; alter table student3 add details varchar(30);<br>//指定某一个位置添加新变量<br>mysql&gt; alter table student3 add details varchar(30) after district;</p>
<p>//删除<br>mysql&gt; alter table student3 drop details varchar(30);</p>
<p>insert into student3 values(1,’zhangsan’,’武侯区’,’武侯大道’,’100号’);<br>insert into student3 values(2,’lisi’,’武侯区’,’京城大道’,’200号’);<br>insert into student3 values(3,’wang5’,’高新区’,’王府大道’,’300号’);</p>
<p>mysql&gt; select *from student3;<br>+—-+———-+———–+————–+——–+<br>| id | name     | district  | details      | number |<br>+—-+———-+———–+————–+——–+<br>|  1 | zhangsan | 武侯区    | 武侯大道     | 100号  |<br>|  2 | lisi     | 武侯区    | 京城大道     | 200号  |<br>|  3 | wang5    | 高新区    | 王府大道     | 300号  |<br>+—-+———-+———–+————–+——–+<br>3 rows in set (0.00 sec)</p>
<!--more-->
<p>–范式设计的越详细，对于某些实际操作可能更好，但不一定都是好的</p>
<h3><span id="2nf">2NF</span></h3><p>–2.第二范式<br>–必须满足第一范式的前提下，第二范式要求，除主键外的每一列都必须完全依赖于主键<br>–如果要出现不完全依赖，只可能发生在联合逐渐的情况下<br>–订单表<br>create table myorder(<br>product_id int,<br>customer_id int,<br>product_name varchar(20),<br>customer_name varchar(20),<br>primary key(product_id,customer_id)<br>);<br>–除主键以外的其他列，只依赖于主键的部分字段<br>–拆表<br>create table myorder(<br>order_id int primary key,<br>product_id int,<br>customer_id);<br>create table product(<br>id int primary key,<br>name varchar(20));<br>create table customer(<br>id int primary key,<br>name varchar(20));<br>–分成三个表之后，就满足了第二范式的设计！</p>
<h3><span id="3nf">3NF</span></h3><p>–3.第三范式<br>–3NF<br>–必须先满足第二范式，除开主键列的其他列之间不能有传递依赖关系</p>
<p>create table myorder(<br>    order_id int primary key,<br>    product_id int,<br>    customer_id int，<br>    //customer_phone varchar(20)<br>);<br>create table customer(create table customer(<br>id int primary key,<br>name varchar(20));<br>    id int primary key,<br>    name varchar(20)<br>    phone varchar(20)<br>    );<br>customer_phone 和 customer_id可能存在联系，和除主键外的其他列存在联系不符合第三范式<br>所以在这里将phone这一列放到table customer中</p>
<h2><span id="例题查询边学边练">例题(查询边学边练）</span></h2><p>– 创建数据库<br>CREATE DATABASE select_test;<br>– 切换数据库<br>USE select_test;</p>
<h3><span id="创建学生表">创建学生表</span></h3><p>CREATE TABLE student (<br>    no VARCHAR(20) PRIMARY KEY,<br>    name VARCHAR(20) NOT NULL,<br>    sex VARCHAR(10) NOT NULL,<br>    birthday DATE, – 生日<br>    class VARCHAR(20) – 所在班级<br>);</p>
<h3><span id="创建教师表">创建教师表</span></h3><p>CREATE TABLE teacher (<br>    no VARCHAR(20) PRIMARY KEY,<br>    name VARCHAR(20) NOT NULL,<br>    sex VARCHAR(10) NOT NULL,<br>    birthday DATE,<br>    profession VARCHAR(20) NOT NULL, – 职称<br>    department VARCHAR(20) NOT NULL – 部门<br>);</p>
<h3><span id="创建课程表">创建课程表</span></h3><p>CREATE TABLE course (<br>    no VARCHAR(20) PRIMARY KEY,<br>    name VARCHAR(20) NOT NULL,<br>    t_no VARCHAR(20) NOT NULL, – 教师编号<br>    – 表示该 tno 来自于 teacher 表中的 no 字段值<br>    FOREIGN KEY(t_no) REFERENCES teacher(no)<br>);</p>
<h3><span id="成绩表">成绩表</span></h3><p>CREATE TABLE score (<br>    s_no VARCHAR(20) NOT NULL, – 学生编号<br>    c_no VARCHAR(20) NOT NULL, – 课程号<br>    degree DECIMAL, – 成绩<br>    – 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值<br>    FOREIGN KEY(s_no) REFERENCES student(no),<br>    FOREIGN KEY(c_no) REFERENCES course(no),<br>    – 设置 s_no, c_no 为联合主键<br>    PRIMARY KEY(s_no, c_no)<br>);</p>
<p>– 查看所有表<br>SHOW TABLES;<br>mysql&gt; show tables;<br>+———————–+<br>| Tables_in_select_test |<br>+———————–+<br>| course                |<br>| score                 |<br>| student               |<br>| teacher               |<br>+———————–+<br>4 rows in set (0.00 sec)</p>
<h3><span id="添加学生表数据">添加学生表数据</span></h3><p>INSERT INTO student VALUES(‘101’, ‘曾华’, ‘男’, ‘1977-09-01’, ‘95033’);<br>INSERT INTO student VALUES(‘102’, ‘匡明’, ‘男’, ‘1975-10-02’, ‘95031’);<br>INSERT INTO student VALUES(‘103’, ‘王丽’, ‘女’, ‘1976-01-23’, ‘95033’);<br>INSERT INTO student VALUES(‘104’, ‘李军’, ‘男’, ‘1976-02-20’, ‘95033’);<br>INSERT INTO student VALUES(‘105’, ‘王芳’, ‘女’, ‘1975-02-10’, ‘95031’);<br>INSERT INTO student VALUES(‘106’, ‘陆军’, ‘男’, ‘1974-06-03’, ‘95031’);<br>INSERT INTO student VALUES(‘107’, ‘王尼玛’, ‘男’, ‘1976-02-20’, ‘95033’);<br>INSERT INTO student VALUES(‘108’, ‘张全蛋’, ‘男’, ‘1975-02-10’, ‘95031’);<br>INSERT INTO student VALUES(‘109’, ‘赵铁柱’, ‘男’, ‘1974-06-03’, ‘95031’);</p>
<h3><span id="添加教师表数据">添加教师表数据</span></h3><p>INSERT INTO teacher VALUES(‘804’, ‘李诚’, ‘男’, ‘1958-12-02’, ‘副教授’, ‘计算机系’);<br>INSERT INTO teacher VALUES(‘856’, ‘张旭’, ‘男’, ‘1969-03-12’, ‘讲师’, ‘电子工程系’);<br>INSERT INTO teacher VALUES(‘825’, ‘王萍’, ‘女’, ‘1972-05-05’, ‘助教’, ‘计算机系’);<br>INSERT INTO teacher VALUES(‘831’, ‘刘冰’, ‘女’, ‘1977-08-14’, ‘助教’, ‘电子工程系’);</p>
<h3><span id="添加课程表数据">添加课程表数据</span></h3><p>INSERT INTO course VALUES(‘3-105’, ‘计算机导论’, ‘825’);<br>INSERT INTO course VALUES(‘3-245’, ‘操作系统’, ‘804’);<br>INSERT INTO course VALUES(‘6-166’, ‘数字电路’, ‘856’);<br>INSERT INTO course VALUES(‘9-888’, ‘高等数学’, ‘831’);</p>
<h3><span id="添加成绩表数据">添加成绩表数据</span></h3><p>INSERT INTO score VALUES(‘103’, ‘3-105’, ‘92’);<br>INSERT INTO score VALUES(‘103’, ‘3-245’, ‘86’);<br>INSERT INTO score VALUES(‘103’, ‘6-166’, ‘85’);<br>INSERT INTO score VALUES(‘105’, ‘3-105’, ‘88’);<br>INSERT INTO score VALUES(‘105’, ‘3-245’, ‘75’);<br>INSERT INTO score VALUES(‘105’, ‘6-166’, ‘79’);<br>INSERT INTO score VALUES(‘109’, ‘3-105’, ‘76’);<br>INSERT INTO score VALUES(‘109’, ‘3-245’, ‘68’);<br>INSERT INTO score VALUES(‘109’, ‘6-166’, ‘81’);</p>
<h2><span id="例题操作">例题操作</span></h2><h3><span id="1查询student表中的所有数据">–1.查询student表中的所有数据</span></h3><p>mysql&gt; select * from student;<br>+—–+———–+—–+————+——-+<br>| no  | name      | sex | birthday   | class |<br>+—–+———–+—–+————+——-+<br>| 101 | 曾华      | 男  | 1977-09-01 | 95033 |<br>| 102 | 匡明      | 男  | 1975-10-02 | 95031 |<br>| 103 | 王丽      | 女  | 1976-01-23 | 95033 |<br>| 104 | 李军      | 男  | 1976-02-20 | 95033 |<br>| 105 | 王芳      | 女  | 1975-02-10 | 95031 |<br>| 106 | 陆军      | 男  | 1974-06-03 | 95031 |<br>| 107 | 王尼玛    | 男  | 1976-02-20 | 95033 |<br>| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |<br>| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |<br>+—–+———–+—–+————+——-+<br>9 rows in set (0.00 sec)</p>
<h3><span id="2查询student表中的所有记录的snamessex和class列">–2.查询student表中的所有记录的sname，ssex和class列</span></h3><p>mysql&gt; select name,sex,class from student;<br>+———–+—–+——-+<br>| name      | sex | class |<br>+———–+—–+——-+<br>| 曾华      | 男  | 95033 |<br>| 匡明      | 男  | 95031 |<br>| 王丽      | 女  | 95033 |<br>| 李军      | 男  | 95033 |<br>| 王芳      | 女  | 95031 |<br>| 陆军      | 男  | 95031 |<br>| 王尼玛    | 男  | 95033 |<br>| 张全蛋    | 男  | 95031 |<br>| 赵铁柱    | 男  | 95031 |<br>+———–+—–+——-+<br>9 rows in set (0.00 sec)</p>
<h3><span id="3查询教师所有的单位不重复的department">–3.查询教师所有的单位，不重复的department</span></h3><p>//直接查询会有重复部分<br>mysql&gt; select department from teacher;<br>+—————–+<br>| department      |<br>+—————–+<br>| 计算机系        |<br>| 计算机系        |<br>| 电子工程系      |<br>| 电子工程系      |<br>+—————–+<br>4 rows in set (0.00 sec)</p>
<p>//这里使用distinct语句来排除重复<br>mysql&gt; select distinct department from teacher;<br>+—————–+<br>| department      |<br>+—————–+<br>| 计算机系        |<br>| 电子工程系      |<br>+—————–+<br>2 rows in set (0.00 sec)</p>
<h3><span id="4-查询score表中成绩在60-80之间的所有记录">–4 查询score表中成绩在60-80之间的所有记录</span></h3><p>–查询区间between …and ..<br>mysql&gt; select * from score where degree between 60 and 80;<br>+——+——-+——–+<br>| s_no | c_no  | degree |<br>+——+——-+——–+<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>+——+——-+——–+<br>–直接使用运算符比较<br>mysql&gt; select * from score where degree&gt;60 and degree&lt;80;<br>+——+——-+——–+<br>| s_no | c_no  | degree |<br>+——+——-+——–+<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>+——+——-+——–+</p>
<h3><span id="5查询score表中成绩为8586或88的记录">–5.查询score表中成绩为85，86或88的记录</span></h3><p>mysql&gt; select * from score where degree in(85,86,88);<br>+——+——-+——–+<br>| s_no | c_no  | degree |<br>+——+——-+——–+<br>| 103  | 3-245 |     86 |<br>| 103  | 6-166 |     85 |<br>| 105  | 3-105 |     88 |<br>+——+——-+——–+</p>
<h3><span id="6-查询student表中95301班或性别为女的记录">–6  查询student表中“95301班”或性别为“女”的记录</span></h3><p>–or表示或者<br>mysql&gt; select * from student where class=’95301’ or’sex=’女’;<br>    ‘&gt; select * from student where class=’95031’ or’sex=’女’;<br>ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘女’<br>//上述问题也是由于单引号位置问题，仔细检查即可，有错误的时候看erro提示<br>mysql&gt; select * from student where class=’95031’ or sex=’女’;<br>+—–+———–+—–+————+——-+<br>| no  | name      | sex | birthday   | class |<br>+—–+———–+—–+————+——-+<br>| 102 | 匡明      | 男  | 1975-10-02 | 95031 |<br>| 103 | 王丽      | 女  | 1976-01-23 | 95033 |<br>| 105 | 王芳      | 女  | 1975-02-10 | 95031 |<br>| 106 | 陆军      | 男  | 1974-06-03 | 95031 |<br>| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |<br>| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |<br>+—–+———–+—–+————+——-+</p>
<h3><span id="7-以class降序查询student表的所有记录">–7 以class降序查询student表的所有记录</span></h3><p>–升序 降序<br>desc 降序<br>asc  升序 （不写也默认升序）<br>mysql&gt; select *from student order by class desc;<br>+—–+———–+—–+————+——-+<br>| no  | name      | sex | birthday   | class |<br>+—–+———–+—–+————+——-+<br>| 101 | 曾华      | 男  | 1977-09-01 | 95033 |<br>| 103 | 王丽      | 女  | 1976-01-23 | 95033 |<br>| 104 | 李军      | 男  | 1976-02-20 | 95033 |<br>| 107 | 王尼玛    | 男  | 1976-02-20 | 95033 |<br>| 102 | 匡明      | 男  | 1975-10-02 | 95031 |<br>| 105 | 王芳      | 女  | 1975-02-10 | 95031 |<br>| 106 | 陆军      | 男  | 1974-06-03 | 95031 |<br>| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |<br>| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |<br>+—–+———–+—–+————+——-+</p>
<h3><span id="8以cno升序degree降序查询score表的记录">–8.以cno升序，degree降序查询score表的记录</span></h3><p>mysql&gt; select * from score order by c_no asc, degree desc;<br>//课程编号首先按照升序排列，同一课程编号内的score按照降序排列<br>+——+——-+——–+<br>| s_no | c_no  | degree |<br>+——+——-+——–+<br>| 103  | 3-105 |     92 |<br>| 105  | 3-105 |     88 |<br>| 109  | 3-105 |     76 |<br>| 103  | 3-245 |     86 |<br>| 105  | 3-245 |     75 |<br>| 109  | 3-245 |     68 |<br>| 103  | 6-166 |     85 |<br>| 109  | 6-166 |     81 |<br>| 105  | 6-166 |     79 |<br>+——+——-+——–+</p>
<h3><span id="9查询95301班级的人数">–9.查询‘95301’班级的人数</span></h3><p>–统计count</p>
<p>mysql&gt; select count(<em>)from student where class=’95031’;<br>+———-+<br>| count(</em>) |<br>+———-+<br>|        5 |<br>+———-+</p>
<!--more-->
<h3><span id="10-查询score表中的最高分的学生学号和课程号">–10 查询score表中的最高分的学生学号和课程号</span></h3><p>–mysql&gt; select s_no,c_no from score where degree=(select max(degree) from score);<br>//按照括号内首先找出表中的最高分 select  max(degree) from score;<br>然后来查询最高分的学生学号和课程号 select s_no,c_no score where degree =select  max(degree) from score;</p>
<p>+——+——-+<br>| s_no | c_no  |<br>+——+——-+<br>| 103  | 3-105 |<br>+——+——-+<br>–第二种做法：排序<br>首先将分数按升序或者降序排序，然后找出排在首位或者末尾的数据</p>
<p>mysql&gt; select s_no,c_no,degree from score order by degree;<br>+——+——-+——–+<br>| s_no | c_no  | degree |<br>+——+——-+——–+<br>| 109  | 3-245 |     68 |<br>| 105  | 3-245 |     75 |<br>| 109  | 3-105 |     76 |<br>| 105  | 6-166 |     79 |<br>| 109  | 6-166 |     81 |<br>| 103  | 6-166 |     85 |<br>| 103  | 3-245 |     86 |<br>| 105  | 3-105 |     88 |<br>| 103  | 3-105 |     92 |<br>然后找出排在首位或者末尾的数据<br>这里是通过desc找到从最后开始倒数的第一个数据<br>limit<br>第一个数字表示从哪个位置开始<br>第二个数字代表插入几组数据<br>limit 0,1<br>mysql&gt; select s_no,c_no,degree from score order by degree desc limit 0,1;<br>+——+——-+——–+<br>| s_no | c_no  | degree |<br>+——+——-+——–+<br>| 103  | 3-105 |     92 |<br>+——+——-+——–+</p>
<h3><span id="11查询每门课的平均成绩">–11.查询每门课的平均成绩</span></h3><p>//查询有几门课程<br>select * from course;<br>–avg<br>select avg(degree) from score where c_no=’3-105’;<br>mysql&gt; select avg(degree) from score where c_no=’3-105’;</p>
<p>+————-+<br>| avg(degree) |<br>+————-+<br>|     85.3333 |<br>+————-+</p>
<p>select avg(degree) from score where c_no=’3-245’;<br>select avg(degree) from score where c_no=’6-166’;<br>select avg(degree) from score where c_no=’9-888’;</p>
<p>–能不能在一个sql语句中写呢？<br>select c_no,avg(degree) from score group by c_no;</p>
<p>mysql&gt; select c_no,avg(degree) from score group by c_no;<br>+——-+————-+<br>| c_no  | avg(degree) |<br>+——-+————-+<br>| 3-105 |     85.3333 |<br>| 3-245 |     76.3333 |<br>| 6-166 |     81.6667 |<br>+——-+————-+<br>//这里尝试不通过课程编号进行分组，通过学生编号进行分组，这里求出的数值代表每名学生所有成绩的平均值.<br>//因此这个语句主要取决于group by的后半部分<br>mysql&gt; select s_no,avg(degree) from score group by s_no;</p>
<p>+——+————-+<br>| s_no | avg(degree) |<br>+——+————-+<br>| 103  |     87.6667 |<br>| 105  |     80.6667 |<br>| 109  |     75.0000 |</p>
<h3><span id="12-查询score表中至少有两名学生选修的并以3开头的课程的平均分数">–12 查询score表中至少有两名学生选修的，并以3开头的课程的平均分数</span></h3><p>3%模糊查询<br>select c_no ,avg(degree),count(*)from score group by c_no<br>having count(c_no)&gt;=2<br>and c_no like ‘3%’;</p>
<p>mysql&gt; select c_no ,avg(degree),count(<em>)from score group by c_no<br>    -&gt; having count(c_no)&gt;=2 and c_no like ‘3%’;<br>+——-+————-+———-+<br>| c_no  | avg(degree) | count(</em>) |<br>+——-+————-+———-+<br>| 3-105 |     85.3333 |        3 |<br>| 3-245 |     76.3333 |        3 |</p>
<h3><span id="13-查询分数大于70-小于90的-s_no-列">–13 查询分数大于70 小于90的 s_no 列</span></h3><p> select s_no,degree from score where degree&gt;70 and degree&lt;90;<br> select s_no,degree from score where degree between 70 and 90;</p>
<p> mysql&gt; select s_no,degree from score where degree&gt;70 and degree&lt;90;<br>+——+——–+<br>| s_no | degree |<br>+——+——–+<br>| 103  |     86 |<br>| 103  |     85 |<br>| 105  |     88 |<br>| 105  |     75 |<br>| 105  |     79 |<br>| 109  |     76 |<br>| 109  |     81 |<br>+——+——–+</p>
<h3><span id="14-查询所有学生的sname">–14 查询所有学生的sname</span></h3><p>select no,name from student;<br>+—–+———–+<br>| no  | name      |<br>+—–+———–+<br>| 101 | 曾华      |<br>| 102 | 匡明      |<br>| 103 | 王丽      |<br>| 104 | 李军      |<br>| 105 | 王芳      |<br>| 106 | 陆军      |<br>| 107 | 王尼玛    |<br>| 108 | 张全蛋    |<br>| 109 | 赵铁柱    |</p>
<p>select s_no,c_no ,degree from score;</p>
<p>| s_no | c_no  | degree |<br>+——+——-+——–+<br>| 103  | 3-105 |     92 |<br>| 103  | 3-245 |     86 |<br>| 103  | 6-166 |     85 |<br>| 105  | 3-105 |     88 |<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+——+——-+——–+</p>
<p>select name,no,degree from student,score where student.no=score.s_no;<br>+———–+—–+——–+<br>| name      | no  | degree |<br>+———–+—–+——–+<br>| 王丽      | 103 |     92 |<br>| 王丽      | 103 |     86 |<br>| 王丽      | 103 |     85 |<br>| 王芳      | 105 |     88 |<br>| 王芳      | 105 |     75 |<br>| 王芳      | 105 |     79 |<br>| 赵铁柱    | 109 |     76 |<br>| 赵铁柱    | 109 |     68 |<br>| 赵铁柱    | 109 |     81 |<br>+———–+—–+——–+</p>
<h3><span id="15-查询所有学生的s_nocname和degree列">–15 查询所有学生的s_no,cname,和degree列</span></h3><p>首先分别查看score，course表格</p>
<p>mysql&gt; select c_no,s_no,degree from score;<br>+——-+——+——–+<br>| c_no  | s_no | degree |<br>+——-+——+——–+<br>| 3-105 | 103  |     92 |<br>| 3-245 | 103  |     86 |<br>| 6-166 | 103  |     85 |<br>| 3-105 | 105  |     88 |<br>| 3-245 | 105  |     75 |<br>| 6-166 | 105  |     79 |<br>| 3-105 | 109  |     76 |<br>| 3-245 | 109  |     68 |<br>| 6-166 | 109  |     81 |<br>+——-+——+——–+</p>
<p>mysql&gt; select no,name from course;<br>+——-+—————–+<br>| no    | name            |<br>+——-+—————–+<br>| 3-105 | 计算机导论      |<br>| 3-245 | 操作系统        |<br>| 6-166 | 数字电路        |<br>| 9-888 | 高等数学        |</p>
<p>+——-+—————–+<br>制定新的表格包含no，name（来自course）和degree(score)<br>增加条件（course里的课程编号与score里的c_no 相等）</p>
<p>mysql&gt; select no,name,degree from course,score where course.no=score.c_no;<br>+——-+—————–+——–+<br>| no    | name            | degree |<br>+——-+—————–+——–+<br>| 3-105 | 计算机导论      |     92 |<br>| 3-105 | 计算机导论      |     88 |<br>| 3-105 | 计算机导论      |     76 |<br>| 3-245 | 操作系统        |     86 |<br>| 3-245 | 操作系统        |     75 |<br>| 3-245 | 操作系统        |     68 |<br>| 6-166 | 数字电路        |     85 |<br>| 6-166 | 数字电路        |     79 |<br>| 6-166 | 数字电路        |     81 |<br>+——-+—————–+——–+</p>
<h3><span id="16-查询所有学生的snamecname和degree">–16 查询所有学生的sname，cname和degree</span></h3><h4><span id="更改数据表的列尝试">更改数据表的列尝试</span></h4><p>mysql&gt; select name,name,degree from student,course,score where student.no=score.s_no and where course.no=score.c_no;<br>ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘where course.no=score.c_no’ at line 1</p>
<p>!!我这里尝试按照视频中操作，但因为course和student里的name相同起了冲突<br>这里按照之前操作数据表的方法 将student中的name改为sname！！<br>mysql&gt; alter table student drop name;<br>Query OK, 0 rows affected (0.01 sec)<br>Records: 0  Duplicates: 0  Warnings: 0</p>
<p>mysql&gt; alter table student add sname varchar(20) first;<br>Query OK, 0 rows affected (0.01 sec)<br>Records: 0  Duplicates: 0  Warnings: 0<br>desc查看 发现更改成功！<br>mysql&gt; desc student;<br>+———-+————-+——+—–+———+——-+<br>| Field    | Type        | Null | Key | Default | Extra |<br>+———-+————-+——+—–+———+——-+<br>| sname    | varchar(20) | YES  |     | NULL    |       |<br>| no       | varchar(20) | NO   | PRI | NULL    |       |<br>| sex      | varchar(10) | NO   |     | NULL    |       |<br>| birthday | date        | YES  |     | NULL    |       |<br>| class    | varchar(20) | YES  |     | NULL    |       |<br>+———-+————-+——+—–+———+——-+</p>
<p>select sname,name,degree from student,course,score where student.no=score.s_no and where course.no=score.c_no;<br>这里再次尝试操作发现还是错误 检查得知虽然数据表中name改为sname<br>但是sname中的数据为NULL空 所以需要通过对于数据进行操作 </p>
<p>+—–+———–+<br>| no  | name      |<br>+—–+———–+<br>| 101 | 曾华      |<br>| 102 | 匡明      |<br>| 103 | 王丽      |<br>| 104 | 李军      |<br>| 105 | 王芳      |<br>| 106 | 陆军      |<br>| 107 | 王尼玛    |<br>| 108 | 张全蛋    |<br>| 109 | 赵铁柱    |<br>–更改数据<br>UPDATE student SET sname = ‘曾华 ‘ where no = 101;<br>UPDATE student SET sname = ‘匡明’ where no = 102;<br>UPDATE student SET sname = ‘王丽’ where no = 103;<br>UPDATE student SET sname = ‘李军’ where no = 104;<br>UPDATE student SET sname = ‘王芳’ where no = 105;<br>UPDATE student SET sname = ‘陆军’ where no = 106;<br>UPDATE student SET sname = ‘王尼玛’ where no = 107;<br>UPDATE student SET sname = ‘张全蛋’ where no = 108;<br>UPDATE student SET sname = ‘赵铁柱’ where no = 109;</p>
<p>mysql&gt; select * from student;<br>+——-+—–+—–+————+——-+<br>| sname | no  | sex | birthday   | class |<br>+——-+—–+—–+————+——-+<br>| NULL  | 101 | 男  | 1977-09-01 | 95033 |<br>| NULL  | 102 | 男  | 1975-10-02 | 95031 |<br>| NULL  | 103 | 女  | 1976-01-23 | 95033 |<br>| NULL  | 104 | 男  | 1976-02-20 | 95033 |<br>| NULL  | 105 | 女  | 1975-02-10 | 95031 |<br>| NULL  | 106 | 男  | 1974-06-03 | 95031 |<br>| NULL  | 107 | 男  | 1976-02-20 | 95033 |<br>| NULL  | 108 | 男  | 1975-02-10 | 95031 |<br>| NULL  | 109 | 男  | 1974-06-03 | 95031 |<br>+——-+—–+—–+————+——-+</p>
<p>select sname,name,degree from student,course,score where student.no=score.s_no and course.no=score.c_no;<br>成功！</p>
<p>mysql&gt; select sname,name,degree from student,course,score where student.no=score.s_no and course.no=score.c_no;<br>+———–+—————–+——–+<br>| sname     | name            | degree |<br>+———–+—————–+——–+<br>| 王丽      | 计算机导论      |     92 |<br>| 王丽      | 操作系统        |     86 |<br>| 王丽      | 数字电路        |     85 |<br>| 王芳      | 计算机导论      |     88 |<br>| 王芳      | 操作系统        |     75 |<br>| 王芳      | 数字电路        |     79 |<br>| 赵铁柱    | 计算机导论      |     76 |<br>| 赵铁柱    | 操作系统        |     68 |<br>| 赵铁柱    | 数字电路        |     81 |<br>+———–+—————–+——–+</p>
<h4><span id="更改数据表的列不改变数据的简单方法">更改数据表的列不改变数据的简单方法</span></h4><p>!!重点 数据操作指令多加练习<br>前面更改数据表列名的方法很麻烦<br>查找后发现可以直接修改列名的方法</p>
<h4><span id="在操作里给得到的数据结果起别名原始数据名称不易读">在操作里给得到的数据结果起别名（原始数据名称不易读）</span></h4><p>ex<br>alter table student change sname name varchar(20);<br>change oldname newname +数据类型<br>mysql&gt; select sname,name,degree,student.no as stu_sno,course.no as cou_cno from<br>student,course,score where student.no=score.s_no and course.no=score.c_no;<br>+———–+—————–+——–+———+———+<br>| sname     | name            | degree | stu_sno | cou_cno |<br>+———–+—————–+——–+———+———+<br>| 王丽      | 计算机导论      |     92 | 103     | 3-105   |<br>| 王丽      | 操作系统        |     86 | 103     | 3-245   |<br>| 王丽      | 数字电路        |     85 | 103     | 6-166   |<br>| 王芳      | 计算机导论      |     88 | 105     | 3-105   |<br>| 王芳      | 操作系统        |     75 | 105     | 3-245   |<br>| 王芳      | 数字电路        |     79 | 105     | 6-166   |<br>| 赵铁柱    | 计算机导论      |     76 | 109     | 3-105   |<br>| 赵铁柱    | 操作系统        |     68 | 109     | 3-245   |<br>| 赵铁柱    | 数字电路        |     81 | 109     | 6-166   |<br>+———–+—————–+——–+———+———+</p>
<h3><span id="17查询95031班学生每门课的平均分">–17查询“95031”班学生每门课的平均分</span></h3><p>查询score中课程c_no,并计算成绩（degree）的平均值avg<br>score的数据通过子查询（ ）来选择要操作的班级“95031”<br>最后成绩需要按每门课程操作 将数据分类group by c_no<br> mysql&gt; select c_no,avg(degree) from score<br> where s_no in (select no from student<br> where class=’95031’) group by c_no;<br>+——-+————-+<br>| c_no  | avg(degree) |<br>+——-+————-+<br>| 3-105 |     82.0000 |<br>| 3-245 |     71.5000 |<br>| 6-166 |     80.0000 |<br>+——-+————-+</p>
<h3><span id="18-查询选修3-105课程的成绩高于109号同学3-105成绩的所有同学的记录">–18 查询选修“3-105”课程的成绩高于“109”号同学“3-105”成绩的所有同学的记录</span></h3><p>mysql&gt; select * from score where c_no=’3-105’<br>and degree &gt;<br>(select degree from score where s_no =’109’ and c_no=’3-105’);<br>+——+——-+——–+<br>| s_no | c_no  | degree |<br>+——+——-+——–+<br>| 103  | 3-105 |     92 |<br>| 105  | 3-105 |     88 |<br>+——+——-+——–+</p>
<h3><span id="19-查询成绩高于学号为109课程号3-105的成绩的所有记录">–19  查询成绩高于学号为“109”课程号“3-105”的成绩的所有记录</span></h3><p>/和18的区别在于只要成绩比这名同学的3-105成绩高就可以，不限制课程成绩类型/</p>
<p>mysql&gt; select * from score where  degree &gt;(select degree from score where s_no =’109’ and c_no=’3-105’);<br>+——+——-+——–+<br>| s_no | c_no  | degree |<br>+——+——-+——–+<br>| 103  | 3-105 |     92 |<br>| 103  | 3-245 |     86 |<br>| 103  | 6-166 |     85 |<br>| 105  | 3-105 |     88 |<br>| 105  | 6-166 |     79 |<br>| 109  | 6-166 |     81 |<br>+——+——-+——–+</p>
<h3><span id="20-查询和学号为108101的同学同年出生的所有学生的s_nosname和sbirthday">–20 查询和学号为108，101的同学同年出生的所有学生的s_no,sname和sbirthday</span></h3><p>mysql&gt; select * from student where no in(108,101);<br>+———–+—–+—–+————+——-+<br>| sname     | no  | sex | birthday   | class |<br>+———–+—–+—–+————+——-+<br>| 曾华      | 101 | 男  | 1977-09-01 | 95033 |<br>| 张全蛋    | 108 | 男  | 1975-02-10 | 95031 |<br>+———–+—–+—–+————+——-+</p>
<p>mysql&gt; select year(birthday) from student where no in(108,101);<br>+—————-+<br>| year(birthday) |<br>+—————-+<br>|           1977 |<br>|           1975 |<br>+—————-+</p>
<p>mysql&gt; select * from student where year(birthday) in (select year(birthday) from student where no in(108,101));<br>+———–+—–+—–+————+——-+<br>| sname     | no  | sex | birthday   | class |<br>+———–+—–+—–+————+——-+<br>| 曾华      | 101 | 男  | 1977-09-01 | 95033 |<br>| 匡明      | 102 | 男  | 1975-10-02 | 95031 |<br>| 王芳      | 105 | 女  | 1975-02-10 | 95031 |<br>| 张全蛋    | 108 | 男  | 1975-02-10 | 95031 |<br>+———–+—–+—–+————+——-+<br>//这里的条件用in 不用= 是因为这是对于多个条件</p>
<h3><span id="21查询张旭教师任课的学生成绩">21.查询“张旭”教师任课的学生成绩</span></h3><p>理清思路<br>1.查询成绩 先选择课程号c_no(来源于score表)<br>2.选择的课程号根据任课教师编号 t_no（来源于course表）<br>3.选择任课教师根据教师名字（来源于teacher表）<br>mysql&gt; select * from score where c_no=(select no from course where t_no=(select<br>no from teacher where name= ‘张旭’));<br>+——+——-+——–+<br>| s_no | c_no  | degree |<br>+——+——-+——–+<br>| 103  | 6-166 |     85 |<br>| 105  | 6-166 |     79 |<br>| 109  | 6-166 |     81 |<br>+——+——-+——–+</p>
<h3><span id="22查询选修课课程的同学数多于5人的教师姓名">22.查询选修课课程的同学数多于5人的教师姓名</span></h3><h4><span id="数据不够自己凑">数据不够自己凑</span></h4><p>INSERT INTO score VALUES(‘101’, ‘3-105’, ‘90’);<br>INSERT INTO score VALUES(‘102’, ‘3-105’, ‘81’);<br>INSERT INTO score VALUES(‘104’, ‘3-105’, ‘89’);</p>
<h4><span id="无限套娃-一步步理解">无限套娃 一步步理解</span></h4><p>mysql&gt; select name from teacher where no=(select t_no from course where no=(select c_no from score group by c_no having count(<em>)&gt;5));<br>+——–+<br>| name   |<br>+——–+<br>| 王萍   |<br>+——–+<br>//</em> 来查询更多信息<br>mysql&gt; select * from teacher where no=(select t_no from course where no=(select c_no from score group by c_no having count(*)&gt;5));<br>+—–+——–+—–+————+————+————–+<br>| no  | name   | sex | birthday   | profession | department   |<br>+—–+——–+—–+————+————+————–+<br>| 825 | 王萍   | 女  | 1972-05-05 | 助教       | 计算机系     |<br>+—–+——–+—–+————+————+————–+</p>
<p>————————————————————————————————————————————————————————————————<br>End！</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机操作系统</title>
    <url>/2021/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="操作系统面试持续更新">操作系统面试(持续更新)</span></h2><h3><span id="1请说一下源码到可执行文件的过程">1.请说一下源码到可执行文件的过程</span></h3><p>1）预编译<br>主要处理源代码文件中以”#”开头的预编译指令。处理规则如下<br>1.删除所有的#define，展开所有的宏定义<br>2.处理所有的条件预编译指令<br>如”#if”,”#endif”,”#ifdef”,”#elif”和”#else”<br>3.处理”#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件<br>4.删除所有注释，”//“ 和” ** “<br>5.保留所有的”#pragma” 编译器指令，编译器需要用到他们。如”#pragma once”是为了防止有文件被重复引用<br>6.添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译是产生的编译错误或警告能够显示行号。</p>
<p>2)编译<br>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析，语法分析，语法分析及优化后，生成相对应的汇编代码文件。</p>
<p>1.词法分析：<br>将源代码程序导入到扫描机道中，将其中的字符序列分割成一系列的记号。<br>2.语法分析：<br>语法分析器对由扫描产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为结点的树。 在语法分析的同时，就把运算法优先级确定下来，如果出现表达式不合法，各种括号不匹配，表达式中缺少操作，编译器报错。<br>3.语义分析：<br>语法分析器只是完成对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义–在编译期能分清的语义，相对应的动态语义是在运行期间才能确定的语义。例如：将一个int型赋值给int * 型，语义分析程序就发现类型不匹配，就会报错。<br>4.优化：<br>源代码级别的一个优化过程。<br>5.目标代码生成：<br>由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列–汇编语言表示。<br>6.目标代码优化：<br>目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式，使用位移来替代乘法运算，删除多余的指令等。</p>
<p>3)汇编<br>将汇编代码转换成机器可以执行的指令(机器码文件)。汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件（与可执行文件格式几乎一样)xxx.o(windows),xxx.obj(linux)</p>
<p>4)链接<br>链接的过程:地址和空间的分配，符号决议(也叫做符号绑定，倾向于动态链接)和重定位。将不同的源文件产生的目标文件进行链接，从而形成一个可执行的程序。链接分为静态链接和动态链接。</p>
<p>1.静态链接：<br>函数和数据被编译进一个二进制文件。在静态库的情况下，在编译链接可执行文件时，链接器<br>从库中复制这些函数和数据并把他们和应用程序的其他模块组合起来创建最终的可执行文件。<br>空间浪费：<br>因为每个可执行程序中对所有需要的目标文件都要有一个副本，所以如果多个程序对同一个目标文件都有依赖的时候，会出现同一个目标文件都在内存存在多个副本。<br>更新困难：<br>每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。<br>运行速度快：<br>但是静态链接的优点就是，在可执行程序中已经具备所有执行程序所需要的任何东西，在执行的时候运行速度快。</p>
<p>2.动态链接<br>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将他们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。动态库就是在需要调用其中的函数时，根据函数映射表找到该函数，然后调入堆栈执行。<br>共享库：<br>就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本。<br>更新方便：<br>更新时只需要替换原来的目标文件，而无需将所有的程序重新链接一遍。当程序下一次运行时，新版本的目标文件会自动加载到内存并且链接起来，程序就完成了升级的目标。<br>性能损耗：<br>因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定的损失。</p>
<h3><span id="2-进程与线程的概念">2 进程与线程的概念</span></h3><p>进程是操作系统进行资源调度和分配的基本单位，实现了操作系统的并发。<br>线程时进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发。线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器，独自的寄存器组，指令计数器和处理器状态。每个线程完成不同任务，但是共享同一地址空间。(也就是同样的动态内存，映射文件，目标代码等等)，打开的文件队列和其他内核资源。</p>
<h3><span id="3-为什么要有进程线程其中有什么区别">3 为什么要有进程线程，其中有什么区别</span></h3><p>进程是指在系统中正在运行的一个应用程序，程序一旦运行起来就是进程。进程是系统资源分配的最小单位，且每个进程拥有独立的地址空间，实现了操作系统的并发。线程是进程的子任务，是CPU最小执行和调度的基本单位，实现了进程内部的并发。</p>
<p>线程是进程的一个实体，是进程的一条执行路径，比进程更小的独立运行的基本单位，线程也被称为轻量级进程，一个程序至少有一个进程，一个进程至少有一个线程。</p>
<p>每个线程都独自占用一个虚拟处理器，独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务但是共享同一地址空间(也就是同样的动态内存，映射文件和目标代码等)，打开的文件队列和其他内核资源。</p>
<p>为什么要有线程？</p>
<p>进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行，单进程各个函数之间不是并发执行，影响资源的使用效率，利用多进程解决维护进程系统开销大，创建进程时，分配资源，建立PCB,进程撤销时，回收资源，撤销PCB，进程切换，保存当前进程的状态信息。从通信机制上来讲，线程间有方便的通信机制。</p>
<p>区别：<br>1.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少由一个线程。线程依赖进程而存在。每个独立的进程有一个程序的入口，程序出口。但线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>2.进程是资源分配的最小单位，线程是CPU调度的最小单位。<br>3.进程在执行过程中拥有独立的地址空间，而多个线程共享进程的资源。（同一个进程中的多个线程共享代码段(代码和常量),数据段(全局变量和静态变量),扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。<br>4.系统开销：<br>由于在创建或者撤销进程时，系统都要为之分配或回收资源，如内存空间，I/O设备，PCB程序控制块等。因此操作系统所付出的开销将显著的大于在创建或撤销线程时的开销。类似的，在进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只需保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。<br>5.进程间不会相互影响，线程一个线程挂掉将导致整个进程挂掉。<br>6.通信：<br>由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。线程间可以直接读写进程数据段(如全局变量)来进行通信–需要进程同步和互斥手段的辅助，以保证数据的一致性。进程间通信主要包括管道，系统IPC(包括消息队列，信号量，信号，共享内存),以及套接字socket.</p>
<h3><span id="4什么是信号量">4.什么是信号量</span></h3><p>信号量(semaphore)与已经介绍过的IPC结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥和同步，而不是用于存储进程间通信数据。<br>特点：<br>1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。<br>2)信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作。抽象数据类型，信号量。</p>
<p>一个整形(semaphore)，两个原子操作，进入临界区之前执行P操作，离开临界区执行V操作。<br>P()：sem-1 如果sem&lt;0 等待，否则继续<br>V()：sem+1 如果sem&lt;=0就代表有进程在等待，唤醒一个挂在信号量上等待的P,FIFO原则<br>信号量是一个整数，被保护，只有PV操作能改变值</p>
<p>3)每次对信号量的PV操作不仅限于对信号值加1或减1，而是可以加减任意正整数。</p>
<pre class="line-numbers language-none"><code class="language-none">class semaphore&#123;
    int sem;
    &#x2F;&#x2F;等待队列，sem&lt;0 线程被存在等待队列
    waitQueue q;
&#125;
semaphore::P()&#123;
    sem--;his 
    if(sem&lt;0)&#123;
        Add this thread t to q
        &#x2F;&#x2F;线程放入等待队列
        block(p);
    &#125;
&#125;
semaphore::V()&#123;
    sem++;
    if(sem&lt;&#x3D;0)&#123;
        Remove a thread t from q
        &#x2F;&#x2F;唤醒一个在等待的线程
        wakeup(t);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其系统调用为<br>sem_wait(sem_t * sem):以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait被阻塞，直到信号量具有非0值。<br>sem_post(sem_t * sem)：以原子操作将信号量加1.当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。</p>
<h3><span id="5线程通信的方式">5.线程通信的方式</span></h3><p>临界区：<br>通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。<br>互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。当进入临界区时，需要获得互斥锁并且加锁；那么其他线程先要访问临界区就需要等待锁的释放。当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。<br>锁时一个抽象的数据结构<br>一个二进制状态(解锁/绑定)<br>Lock::Acquire() 锁被释放之前一直等待，然后得到锁<br>Lock::release() 释放锁，唤醒任何等待的进程<br>怎么实现：<br> 原子操作<br>    test-and-set<br>        从内存中读值<br>        测试该值是否为1，不为1进入临界区<br>        内存值设为1<br>其主要的系统调用如下：<br>pthread_mutex_init:初始化互斥锁<br>pthread_mutex_destroy：销毁互斥锁<br>pthread_mutex_lock:以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将其阻塞，直到该互斥锁的占有者将其解锁<br>pthread_mutex_unlock:以一个原子操作的方式给一个互斥锁解锁</p>
<p>信号量semphore:为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的<strong>最大线程数目</strong>。<br>条件变量，顾名思义，<strong>一个或多个线程等待某个布尔表达式为真，即等待别的线程唤醒它</strong>.信号量会与互斥量一起使用，条件本身是由互斥量保护的。线程在改变条件状态前必须锁住互斥量。<br>其主要的系统调用如下：<br>pthread_cond_init：初始化条件变量<br>pthread_cond_destroy：销毁条件变量<br>pthread_cond_signal： 唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。<br>pthread_cond_wait:等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在<strong>进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源的正确访问。</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;条件变量实现
&#x2F;&#x2F;需要维持在每个条件队列
&#x2F;&#x2F;线性等待的条件等待signal()
class Condition()&#123;
    &#x2F;&#x2F;等待的线程数
    int numwaiting &#x3D; 0;
    waitQueue q;
&#125;
Condition::Wait(lock)&#123;
    numwaiting++;
    Add this thread t to q
    &#x2F;&#x2F;一定要先释放锁
    release(lock);
    schedule();&#x2F;&#x2F;需要互斥锁，阻塞再这里，等待信号量满足条件
    require(lock);
&#125;
Condition::Signal()&#123;
    &#x2F;&#x2F;和信号量不一样，不一定执行--操作
    if(numwaiting &gt; 0)&#123;
        remove a thread from q
        wakeup(t);&#x2F;&#x2F;需要互斥锁
        numwaiting --;

    &#125;
&#125;
&#x2F;&#x2F;从管程看生产者消费者问题
class BoundBuffer&#123;
    &#x2F;&#x2F;保证互斥
    Lock lock;
    &#x2F;&#x2F;buffer 内容计数
    int count &#x3D; 0;
    &#x2F;&#x2F;两个条件变量
    Condition notFull,not Empty;

&#125;
BoundBuffer::Deposit(c)&#123;
    &#x2F;&#x2F;线程进入管程，只有一个线程能进去
    lock-&gt;Acquire();
    while(count &#x3D;&#x3D; n)
        &#x2F;&#x2F;当前已经满了，睡眠，在wait中一定要释放互斥锁
        notFull.wait(&amp;lock);
    Add c to Buffer;
    count++;
    notEmpty.Signal();
    lock-&gt;release;

&#125;
BoundBuffer::Remove(c)&#123;
    lock-&gt;Acquire();
    while(count &#x3D;&#x3D; 0)&#123;
        notEmpty.wait(&amp;lock);

    &#125;
    remove c from buffer;
    count--;
    &#x2F;&#x2F;有空闲了，唤醒notFull中的线程
    notFull.Signal();
    lock-&gt;release();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="6虚拟内存为什么要有虚拟内存什么是虚拟地址空间">6.虚拟内存？为什么要有虚拟内存？什么是虚拟地址空间？</span></h3><p>虚拟内存。虚拟内存是一种内存管理技术，它会使程序自己认为自己拥有一块很大且连续的内存，然而这个程序在内存中不是连续的，并且有些还在磁盘上，在需要的时候进行数据交换。<br>为什么要有虚拟内存？<br>在早期的计算机中，是没有虚拟内存的概念的。我们运行一个程序，会把程序全部装入内存中，然后运行。<br>当运行多个程序的时候，经常会出现如下的问题：<br>    地址空间不隔离，没有权限保护。<br>由于程序都是直接访问物理内存，所以一个进程可以修改其他进程的内存数据，甚至修改内核地址空间里的数据。<br>    内存使用效率低<br>当内存空间不足的时候，将其他程序暂时拷贝到硬盘，然后新程序装入内存运行。由于大量的数据装入装出，内存效率十分低下。<br>    程序运行地址不稳定<br>因为程序内存地址都是随机分配的，所以程序运行的地址也是不确定的，内存管理复杂。<br>虚拟地址的优点：<br>    避免用户直接访问物理地址，防止一些破坏性操作，保护操作系统。<br>    每个进程都分配4GB的虚拟内存，用户程序可使用比实际物理内存更大的地址空间。<br>    当进程通信时，可采用虚存共享的方式实现。当不同的进程使用相同的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了。    简化了链接器，加载器这样的程序的内存管理。<br>节省内存。<br>什么是虚拟空间？<br>虚拟地址空间是对于一个单一进程的概念，<strong>这个进程看到的将是从地址0000开始的整个内存空间</strong> 。虚拟存储器是一个抽象概念，它为每个进程提供了一个假象，好像每一个进程都在独占地使用主存。<strong>每个进程看到的存储器都是一致的</strong>,称为虚拟地址空间。从最低的地址看起：程序代码和数据，堆，共享库，栈，内存虚拟存储器。</p>
<p>虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的4G内存，所有进程共享同一物理内存，<strong>每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上</strong>。事实上，在每个进程创建加载时，内核只是为进程”创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上<strong>并不立即</strong>就把虚拟内存对应位置的程序数据和代码(.text.data段)拷贝到物理内存中，只是建立好虚拟内存和磁盘文件的映射就好(叫做存储器映射)，等到运行到对应程序时，才会通过<strong>缺页异常</strong>，来拷贝数据。还有进程运行过程中，要动态分配内存，比如<strong>malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</strong> 可以认为虚拟空间都被映射到了磁盘空间中(事实上也是按需要映射到磁盘空间上，通过mmap)，并且由页表记录映射位置。当<strong>访问到某个地址的时候，通过页表中的有效位，可以得知此数据是否在内存中</strong>,如果不是，则通过缺页异常，将磁盘对应的数据拷贝到内存中，如果没有空闲内存则选择牺牲页面，替换其他页面。</p>
<h3><span id="7mmap原理">7.mmap原理</span></h3><p>mmap是用来建立从虚拟空间到磁盘空间的映射的，可以将一个虚拟空间地址映射到一个磁盘文件上，当不设置这个地址时，则由系统自动设置，函数返回对应的内存地址(虚拟地址)。使用mmap分配内存，在<strong>堆和栈之间找一对空闲的内存分配</strong>.这两种方式分配的是虚拟内存，没有分配物理内存。真正的分配要在第一次访问已经分配的虚拟内存空间的时候，发生缺页中断，由操作系统分配物理内存，建立虚拟内存和物理内存之间的映射关系。</p>
<h3><span id="8进程控制块包含信息和组织方式">8.进程控制块包含信息和组织方式</span></h3><p>进程控制块(PCB)是系统为了管理进程设置的一个专门的数据结构。系统用它来记录进程的外部特征，进程描述的运动变化过程。同时，系统可以利用PCB来控制和管理进程。所以说，PCB是系统感知进程存在的唯一标志。<br>PCB含有以下三大类信息：<br>进程标识信息：本进程标识，父进程标识，用户标识<br>处理机状态信息保存区：<br>保存进程的运行现场信息。用户可见的寄存器，控制和状态寄存器，栈指针(过程调用，系统调用，中断处理和返回需要用到)<br>进程控制信息：<br>调度和状态信息：如进程状态，等待事件和等待原因，进程优先级<br>进程通信信息：如消息队列指针，信号量等互斥和同步机制，这些信息存放在接收方的进程块中。<br>存储管理信息：进程在辅存储器内的地址，包含指向本进程映像存储空间的数据结构。<br>进程所用资源：包含进程所需全部资源，已经分得的资源，如主存资源，I/O设备，打开文件表等。<br>有关数据结构连接信息：父子进程连接起来，进程可以连接到一个进程队列中，或连接到相关的其他进程PCB。<br>PCB组织方式<br>一般是链表：更好的完成动态插入和删除。一个状态的进程对应PCB中的一个链表，如就绪链表，阻塞链表。</p>
<h3><span id="9mallocrealloccalloc的区别">9.malloc,realloc,calloc的区别</span></h3><p>1.malloc函数</p>
<pre class="line-numbers language-none"><code class="language-none">void * malloc(unsigned int num_size);
int * p &#x3D; (int *)malloc(20*sizeof(int));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>申请20个int类型的空间<br>2.calloc函数</p>
<pre class="line-numbers language-none"><code class="language-none">void * calloc(size_t,size_t size);
int * p &#x3D; calloc(20,sizeof(int));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>malloc的申请空间是随机化的，callloc的申请的空间的值初始化为0<br>3.realloc 函数</p>
<pre class="line-numbers language-none"><code class="language-none">void realloc(void * p,size_t new_size);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>给分配的额外分配空间，用于扩充容量。<br>这里有几个问题：<br>1.堆和栈最大可分配的内存的大小<br>2.堆和栈的内存管理方式<br>3.堆和栈的分配效率<br>首先针对第一个问题，一般来说对于一个进程栈的大小远远小于堆的大小。在linux中你可以使用ulimit-s(单位kb)来查看一个进程栈的最大可分配大小，一般来说不超过8M，有的甚至不超过2M，不过这个可以设置，而对于堆你会发现，针对一个进程堆的最大可分配的大小在G的数量级上，不同的操作系统可能不一样，比如32位系统最大不超过2G,而64位系统最大不超过4G，所以当你需要一个分配的大小的内存时，请用new，即用堆。</p>
<p>其次针对第二个问题，<strong>栈是系统数据结构</strong>，对于进程/线程是唯一的，它的分配与释放由<strong>操作系统来维护</strong>，不需要开发者来管理。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时，这些存储单元会被自动释放。栈内存分配运算内置于处理器执行集中，效率很高。不同的操作系统对栈都有一定的限制。堆上的内存分配，也成为<strong>动态内存分配</strong> .程序在运行的期间用malloc申请的内存，这部分内存<strong>由程序员自己负责管理</strong>,其生存期由开发者决定：在何时分配，分配多少，并在何时用free来释放该内存。这是唯一可以由开发者参与管理的内存。使用的好坏直接决定系统的性能和稳定。</p>
<p>由上可知，<strong>当我们需要的内存很少，又能确定到底需要多少内存的时候，请使用栈。而当你需要在运行时才知道需要多少内存的时候，请用堆。</strong></p>
<p>最后针对第三个问题，栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放在栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆是C/C++函数提供的，它的机制是很复杂的，例如<strong>为了分配一块内存</strong>，库函数会按照一定的算法(具体的算法可以参考数据结构、操作系统)在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间(<strong>内存碎片过多</strong>),就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率要比栈要低的多。</p>
<h3><span id="10并行和并发">10.并行和并发</span></h3><p>并发（concurrency):指宏观上看起来两个程序同时运行，比如在单核cpu上的多任务。但是微观上看两个程序的指令是交织着运行的。你的指令之间穿插这我的指令，我的指令穿插这你的，在单个周期内只运行了一个指令。这种并发不能提高计算机的性能，只能提高效率。</p>
<p>并行(parallelism):指<strong>严格物理意义上统一时刻的同时运行</strong>,比如多核cpu，两个程序分别运行在两个核上，两者之间相互不影响。这样说来并行的确提高了计算机的效率，所以现在的cpu都是往多核方面发展的。</p>
<h3><span id="11如何修改文件的最大句柄数">11.如何修改文件的最大句柄数</span></h3><p>linux默认的最大文件句柄数是1024个，在linux服务器文件并发量比较大的情况下，系统会报”to many open files”的错误。所以在linux服务器高并发调优时，往往需要预先调优linux参数，修改linux最大文件句柄数。</p>
<p>有两种方法：<br>1.ulimit-n &lt;可以同时打开的文件数&gt; 。将当前进程的最大句柄数修改为指定的参数（注意：该方法只针对当前进程有效，重新打开shell或者重新开启一个进程，参数还是之前的值)<br>2.对所有进程都有效的方法，修改linux系统参数<br>vi/etc/security/limits.conf添加</p>
<p>soft nofile 65536<br>hard nofile 65536<br>将最大句柄数改为65536<br>修改以后保存，注销当前用户，重新登录，修改后的参数就生效了。</p>
<h3><span id="12进程加载和终止调用的函数fork和vfork的区别">12.进程加载和终止调用的函数？fork和vfork的区别</span></h3><p>fork()创建一个继承的子进程<br>当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把<strong>父进程的地址空间中的内容逐页的复制到子进程的地址空间中</strong>但从多核角度来说，逐页的复制方式是十分耗时的。</p>
<p>父进程返回子进程的id，子进程返回0 不成功id&lt;0<br>复制父进程所有的变量和内存<br>复制父进程所有的cpu寄存器</p>
<pre class="line-numbers language-none"><code class="language-none">int pid &#x3D; fork();
if(pid &#x3D;&#x3D; 0)&#123;
    &#x2F;&#x2F;做什么都行（关闭网络连接）
    &#x2F;&#x2F;调用exec()加载新程序取代当前运行进程，地址空间，代码数据也换掉了。
    exec(&quot;program&quot;,argc,argv0,argv1...)
&#125;
&#x2F;&#x2F;等待子进程结束child_status &#x3D; wait(pid);
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在fork()后立刻执行exec所造成的地址空间的浪费。vfork()轻量级fork，创建进程时<strong>不再创建同样的内存映像</strong></p>
<p>子进程必须要立刻执行一次对exec的系统调用，或者调用_exit()退出，<strong>vfork()会挂起父进程直到子进程终止或者运行了一个新的可执行文件的映像。通过这样的方式，vfork()避免了地址空间的按页复制。</strong><br>**<br>COP<strong>Y On Write (写的时候进行复制)，在实际地址空间复制的时候并没有真实的复制，而是复制父进程地址空间所需要的元数据（页表），指向同一块地址空间，</strong>当父进程或者子进程对某一个地址单元写操作会触发一个异常，使得触发异常的页复制成两份。只有写的时候才会。**</p>
<p>fork和vfork的区别<br>f<strong>ork(</strong>)的父子进程的执行次序不确定。<strong>vfork()保证子进程先运行</strong>在调用exec或exit僵尸与父进程数据是共享的，在它<strong>调用exec或exit之后父进程才可能被调度运行</strong></p>
<h3><span id="13孤儿进程-amp-僵尸进程">13.孤儿进程 &amp; 僵尸进程</span></h3><p><strong>孤儿进程</strong><br>父进程运行结束，但子进程还在运行（未运行结束），这样的子进程为孤儿进程。<br>每当出现一个孤儿进程，内核就把孤儿进程的父进程设置为init，而init进程会循环的wait()它的已经退出的子进程。这样当一个孤儿进程凄凉的结束了其生命周期的时候，init进程就会代表父进程回收。孤儿进程不会有什么危害。</p>
<p><strong>僵尸进程</strong><br>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。</p>
<h3><span id="14管道的读写特点">14.管道的读写特点</span></h3><p>使用管道时需要注意以下几种特殊的情况（假设都是阻塞的I/O操作）<br>1.所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为0），进程从管道的读端读数据，那么管道中剩余的数据被读取以后，再次read会返回0.就像读到文件末尾一样。</p>
<p>2.如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的进程也没有往管道中写数据 ，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后再次read会阻塞，直到管道中有数据可读，才读取数据并返回。</p>
<p>3.如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数为0），这个时候有进程向管道中写数据，那么该进程会收到一个信号SIGPIPE，通常会导致进程异常终止。</p>
<p>4.如果有指向管道读端的文件描述符没有关闭，（管道的读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写数据，那么在管道被写满的时候，再次write会被阻塞，直到管道中有空位置才能写入数据并返回。</p>
<p>总结：<br>    读管道：<br>        管道中有数据，read返回实际读到的字节数<br>        管道中无数据：<br>            写端全部关闭，read返回0 （相当于读到文件的末尾）<br>            写端没有完全关闭，read阻塞等待。<br>    写管道：<br>        管道读端全部被关闭，进程异常终止（进程收到SIFPIPE信号）<br>        管道读端没有完全关闭：<br>            管道已满，write阻塞<br>            管道没有满,write将数据写入并返回实际写入的字节数。</p>
<h3><span id="15常见io模型5种异步io应用场景有什么缺点">15.常见I/O模型？5种？异步IO应用场景？有什么缺点</span></h3><p>几个概念 ：同步，异步，阻塞，非阻塞<br>首先来解释同步和异步的概念，这两个概念与消息通知机制有关。也就是同步与异步主要是从消息通知机制角度来说的。<br><strong>同步异步概念</strong>：<br>所谓<strong>同步</strong>就是一个任务的完成需要依赖另外一个任务时，<strong>只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列</strong>。要么成功都成功，要么失败都失败，两个任务的状态可以保持一致。</p>
<p>所谓<strong>异步</strong>是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定。所以它是<strong>不可靠的任务序列</strong>。</p>
<p>1）同步<br>就是再发出一个功能调用时，<strong>没有得到结果之前，该调用就不返回</strong>,同步I/O指的是，必须等待IO操作完成后，控制权才返回给用户进程。也就是必须一件一件事情做，等前一件事情做完了才能做下一件事情。就是我们调用一个功能，该功能没有结束前，我死等结果。</p>
<p>2）异步<br>当一个异步调用发出后，调用者不能立即得到结果。实际处理这个调用的部件在完成后，通过状态，通知和调用来通知调用者。我调用一个功能，不知道该功能的结果，该功能有结果后通知我（回调通知）</p>
<p>阻塞与非阻塞<br>阻塞和非阻塞这两个概念与程序（线程）等待消息通知（无所谓同步或者异步）时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）<strong>等待消息通知时的状态角度来说的</strong>。</p>
<p>3)阻塞<br>阻塞调用是指调用结果返回前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之前才会返回。对于<strong>同步调用来说，很多时候当前进程还是激活的，只是逻辑上当前函数没有返回而已</strong>。就是调用函数，<strong>函数在没有接收完数据或者没有得到结果之前不会返回。</strong></p>
<p>4）非阻塞<br>指在不能立刻得到结果之前，该函数不会阻塞当前线程，而是会<strong>立刻返回</strong>。</p>
<p>5种常见IO模型<br>1.阻塞IO<br>应用程序调用一个IO函数，导致<strong>程序阻塞，等待数据准备好</strong>，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后再次read会阻塞，直到管道中有数据可读，才读取数据并返回。<br>2.非阻塞IO<br>我们把一个SOCKET接口设置为非阻塞就是告诉内核，<strong>当请求的I/O操作无法完成时，不要将进程睡眠，而是返回一个错误</strong>，这样我们的IO操作函数将不断的测试数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。在这个不断测试的过程中，会大量的占用CPU的时间。<br>3.IO复用模型会用到select,poll,epoll函数。这几个函数也会使进程阻塞，但是和阻塞IO不同的是，这三个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作，多个写操作的IO函数进行检测，直到有数据可读或可写时，才真正调用IO函数。<br>4.信号驱动<br><strong>开启套接字的信号驱动式IO功能。通过sigaction系统调用安装一个信号处理函数</strong>，该系统调用让内核在描述符就绪时发送SIGIO信号通知我们，在信号处理函数中调用IO操作函数处理数据。<br>5.异步IO模型<br><strong>当一个异步过程调用发出后，调用者不能立刻得到结果。</strong>，实际处理这个调用的部件在完成后，通过状态，通知，回调来通知调用者的输入输出操作。与信号驱动IO的主要区别，信号驱动IO主要是通知我们何时开启一个IO操作，<strong>而异步IO模型是由内核通知我们IO操作何时完成。</strong>。</p>
<h3><span id="16进程控制块包含信息和组织方式">16.进程控制块包含信息和组织方式</span></h3><p>进程控制块（PCB）是系统为了管理进程设置的一个专门的数据结构。系统用它来记录进程的外部特征，描述进程的运动变化过程。同时，系统可以利用PCB来控制和管理进程，所以说PCB是系统感知进程存在的唯一标志。</p>
<p>PCB含有以下三大类信息：<br>进程标识信息：本进程标识，父进程标识，用户标识<br>处理机状态信息保存区：<br>保存进程的运行现场信息，<strong>用户可见到的寄存器，控制和状态寄存器</strong>，栈指针（过程调用，系统调用，中断处理和返回需要用到）</p>
<p>进程控制信息：<br>调度和状态信息：如进程状态，等待事件和等待原因，进程优先级，进程通信信息：如消息队列指针，信号量等互斥和同步机制，这些信息存放在接收方的进程控制块中。存储管理信息:进程在辅存储器内的地址，包含指向本进程映像存储空间的数据结构。进程所用资源：包括进程所需全部资源，已经分得的资源，如主存资源，IO设备，打开文件表等。有关数据结构连接信息：父子进程连接起来，进程可以连接到一个进程队列中，或连接到相关的其他进程PCB。<br>PCB组织方式<br>一般是链表，更好的完成动态插入删除。一个状态的进程对应PCB中的一个链表。如就绪链表，阻塞链表。</p>
<h3><span id="17请说一说操作系统中的程序的内存结构">17.请说一说操作系统中的程序的内存结构</span></h3><p>可以看到一个可执行程序存储在（没有调入内存）时分为<strong>代码段，数据区和未初始化数据区三部分。</strong><br>BSS段（未初始化数据区）：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。<strong>BSS段属于静态分配，程序结束后静态变量资源由系统自动释放。</strong><br>数据段：存放程序中<strong>已初始化的全局变量的一块内存区域</strong>。数据段也属于静态内存分配</p>
<p>代码段：存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中也有可能包含一些<strong>只读的常数变量。</strong><br>text段和data段在编译时已经分配了空间，而<strong>BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。</strong></p>
<p>bss段（未进行初始化的数据）的内容<strong>并不存放在磁盘上的程序文件中</strong>，其原因是在内核在程序开始运行前将他们置为0.需要存放在程序文件中的只有正文段和初始化数据段。BSS的大小从可执行文件中得到，然后<strong>链接器得到这个大小的内存块，紧跟在数据段的后面，当这个内存进入程序的地址空间后全部清零。</strong>包含数据段和BSS段的整个区段此时称之为数据区。<br>可执行程序在运行时又多出两个区域：栈区和堆区</p>
<p>栈区：由编译器自动释放，存放函数的参数值，局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放在栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。<strong>栈区是从高地址为向低地址位增长的，是一个连续的内存区域，最大容量是由系统预先定义好的，申请的占空间超过这个界限就会提示溢出，用户能从栈中获取的空间较小。</strong></p>
<p>堆区：用于动态分配内存，位于BSS和栈中间的的地址区域。<strong>由程序员申请分配和释放。</strong> <strong>堆是从低地址位向高地址位增长，采用链式存储结构。频繁的malloc、free造成内存空间的不连续，产生碎片。</strong>当申请堆空间时，库函数是按照一定的算法搜索可用的足够大的空间，因此堆的效率要比栈低得多。</p>
<h3><span id="18虚拟内存的技术实现">18.虚拟内存的技术实现</span></h3><p>虚拟内存的实现需要加你了在离散分配的内存管理方式的基础上，虚拟内存的实现有以下三种方式：<br>1.请求分页存储管理：建立在基本分页系统的基础上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。<br>2.请求分段存储管理<br>3.请求段页式存储管理<br>不管是上面哪种实现方式，我们一般需要：<br>1.一定容量的内存和外存，在载入程序的时候，只需要将程序的一部分装入内存而将其他部分留在外存，然后程序就可以执行了。<br>2.缺页中断：如果需要执行的指令或访问的数据尚未在内存（称为缺页或缺段），则<strong>由处理器通知操作系统将相应的页面或段调入内存，然后执行程序。</strong><br>3.虚拟地址空间：逻辑地址到物理地址的变换。</p>
<h3><span id="19缺页步骤">19.缺页步骤</span></h3><p>缺页是指当CPU请求一个虚拟地址时，虚拟地址所对应的页在物理内存中不存在。此时MMU会产生缺页错误，然后由内核的缺页处理程序从磁盘中调入对应的页到主存中。在处理完成后，CPU会重新执行导致错误的指令，从而读取到对应的内存数据。<br>下面时缺页时的地址翻译的过程（第一步到第三步与页命中时相同）<br>1.处理器生成一个虚拟地址，并把它传送给MMU<br>2.MMU生成根据地址生成VPN，然后请求高速缓存、主存，获取PTE的数据。<br>3.高速缓存，主存向MMU返回PTE数据<br>4.由于判断出PTE有效位是0，所以CPU将发出一次异常，将控制权转移给内核中的缺页异常处理程序。<br>5.缺页或异常处理程序确定出物理内存中的牺牲页，如果这个页面被修改过了（D标志位位1），那么将牺牲页换出到磁盘。<br>6.缺页处理程序从磁盘中调入新的页面到主存，并且更新PTE<br>7.缺页处理程序将控制权返回给原来的进程。再次执行导致缺页的指令。再次执行后，就会产生页命中时的情况了。</p>
<h3><span id="20页面置换算法">20.页面置换算法</span></h3><p>上文提到缺页，但是当内存满了的时候，就需要从内存中按照一定的置换算法决定内存把哪个页面放弃，存入新的页<br>最佳置换算法OPT<br>算法思想：每次选择淘汰的页面将是以后永不使用，或者最长时间内不再被访问的页面。这样可以保证最低的缺页率。最佳置换算法可以保证最低的缺页率，但是实际上，只有进程执行的过程中才能知道接下来会访问到哪个页面。操作系统无法提前预判页面的访问序列，因此最佳置换算法是无法实现的。</p>
<p>先入先出置换算法FIFO<br>总是选择在主存中停留时间最长（即最老的）一页置换，即先进入内存的页，先退出内存。<br>当为进程分配的物理块数增大时，缺页次数不减反增的异常现象称之为贝莱蒂(belay)异常。<br><strong>只有FIFO算法会产生belay异常</strong>。另外FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应。因此<strong>先进入的页面也有可能时最经常被访问的。因此算法性能差。</strong></p>
<p>最长时间未用置换算法LRU<br>算法思想:每次淘汰的页面时最近最久未使用的页面<br>实现方法：赋予每个页面对应的页表项中，<strong>用访问字段记录该页面自上次访问以来所经历的时间t。</strong>当需要淘汰一个页面时，选择现有页面中t最大的页面，即最近最久未使用。<br>LRU置换算法虽然时比较好的算法，但要求系统有较多的支持硬件。为了了解一个进程在内存中各个页面各有多少时间未被进程访问，以及如何快速的知道那一页时最近最久未使用的页面，须有两类硬件之一的支持：<strong>寄存器和栈。</strong><br>寄存器<br>为了记录某进程在内存中各页的使用情况，须为每个在内存中的页面配置一个移位寄存器，可表示为<br>R= Rn-1 Rn-2 …R0<br>当进程访问某物理块时，要将<strong>相应的寄存器的Rn-1位置置成1，此时定时信号将每隔一定时间（例如100ms）将寄存器右移1位。如果我们把n位寄存器的数看作是一个整数，那么具有最小数值的寄存器所对应的页面</strong>，就是最近最久未使用的页面。</p>
<p>栈<br>可利用一个特殊的栈来保存当前使用的各个页面的页面号。每当进程访问某页面的时候，便将该页面从栈中移除，将它压入栈顶。因此，<strong>栈顶始终是最新被访问的编号，栈底则是最近最久未使用页面的页面号。</strong></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>八股文</title>
    <url>/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>C++面试常见问题</p>
<h2><span id="1-c和c的区别">1 C和C++的区别</span></h2><p><strong>C程序的设计首要考虑的如何设计一个过程</strong>，对输入进行运算处理得到输出。而对于C++而言我们在c的基础上增加了类，这就是面向对象这一个思想，我们在设计程序的时候首先要<strong>考录如何构造一个对象模型</strong>，让这个对象<strong>契合对应的问题域</strong>，这样就可以通过获得对象的状态信息得到输出。</p>
<p>C 和 C++<strong>动态管理内存的方法不一样</strong>,C 是使用 malloc/free 函数,而 C++除此之外还有 new/delete 关键字;(关于 malooc/free 与 new/delete 的不同又可以说一大堆,最后的扩展_1 部分列出十大区别);</p>
<p>接下来就不得不谈到 C 中的 struct 和 C++的类,C++的类是 C 所没有的,但是 C中的 struct 是可以在 C++中正常使用的,并且 C++对 struct 进行了进一步的扩展,使 struct 在 C++中可以和 class 一样当做类使用,而唯<strong>一和 class 不同的地方在于 struct 的成员默认访问修饰符是 public,而 class 默认的是 private;</strong></p>
<p><strong>C++支持函数重载,而 C 不支持函数重载</strong>,而 C++支持重载的依仗就在于 C++的名字修饰与 C 不同,例如在 C++中函数 int fun(int ,int)经过名字修饰之后变为 <code>_fun_int_int</code> ,而 C 是_fun,一般是这样的,所以 C++才会支持不同的参数调用不同的函数;</p>
<p><strong>C++中有引用,而 C 没有</strong>;这样就不得不提一下引用和指针的区别</p>
<h2><span id="2-如何理解抽象-封装-继承-多态">2 如何理解抽象、封装、继承、多态</span></h2><h3><span id="抽象">抽象</span></h3><p>就是把现实世界中的某一类东西，提取出来，用程序代码表示，抽象出来的一般叫做类或者接口。抽象并不打算了解全部问题，而是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一个数据抽象，而是过程抽象。</p>
<p>数据抽象 –&gt;表示世界中一类事物的特征，就是对象的属性。比如鸟有翅膀，羽毛等(类的属性)</p>
<p>过程抽象 –&gt;表示世界中一类事物的行为，就是对象的行为。比如鸟会飞，会叫(类的方法)</p>
<h3><span id="封装">封装</span></h3><p>封装又称信息的隐藏，利用抽象类型，也就是一个类，将数据和基于数据的操作封装在一起，使得数据被保护在抽象数据类型的内部，同时尽可能隐藏一些细节，只保留一些对外的接口与外界保持联系。用户无需直到对象内部的方法实现细节，但是可以根据对象提供的外部接口访问对象。</p>
<p>优点：实现了专业的分工，将某一个题顶功能的代码封装成独立的实体之后，各个程序员可以在需要的时候调用，从而实现了专业的分工。</p>
<p>同时我认为模块化是封装的本质。在软件设计的时候，进行模块化设计。将复杂的系统拆分成各种模块。各种模块可以单独设计调试，让很多人可以同时开发一个项目。封装是模块化不可缺少的一部分，和你一起开发的人员可以调用你的模块而不用管实现的细节，大大加快工作效率。比如。一块银特尔芯片，有强大的功能，但是我们不需要知道内部如何实现，就可以很好的应用他。</p>
<h3><span id="多态">多态</span></h3><p>多态指同一个对象同时具有多种形式。</p>
<p>多态分为静态多态和动态多态，静态多态主要是重载，动态多态使用虚函数机制实现的。</p>
<p>在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</p>
<h3><span id="继承">继承</span></h3><p>继承可以使得子类具有父类的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。</p>
<h3><span id="重新理解面向对象">重新理解面向对象</span></h3><p>变化是复用的天敌，面向对象设计最大的优势在于抵御变化。将变化的范围降到最小。</p>
<p>隔离变化</p>
<ul>
<li>从宏观角度上，面向对象的构建方式更能适应软件的变化，能将变化带来的影响降低到最小。</li>
</ul>
<p>各司其职</p>
<ul>
<li>从微观角度上来看，面向对象的方式更强调对象的“责任”。</li>
<li>由于需求变化导致的新增的类型不应该影响原来类型的实现，——各负其责，主要使用了多态机制，接口一样，实现不一样，多态机制也实现了责任的分派。</li>
</ul>
<p>对象是什么？</p>
<ul>
<li>从语言角度上来看，<strong>对象封装了代码和数据。</strong></li>
<li>从规格上讲，对象<strong>是一系列可被使用的公共接口。</strong></li>
<li>从概念上讲，<strong>对象是某种拥有责任的抽象。</strong></li>
</ul>
<h3><span id="五大基本原则">五大基本原则</span></h3><ul>
<li><strong>单一职责原则</strong>SRP(Single Responsibility Principle)</li>
</ul>
<p>一个类应该<strong>仅有一个引起变化的原因</strong>。<strong>变换的方向隐藏着类的责任</strong>。<strong>是指一个类的功能要单一，不能包罗万象。</strong>如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。</p>
<ul>
<li><strong>开放封闭原则</strong>OCP(Open－Close Principle)</li>
</ul>
<p>一个模块在<strong>扩展性方面应该是开放</strong>的而在<strong>更改性方面应该是封闭的。</strong>在不改动原有的功能上添加新的功能。</p>
<ul>
<li>里式替换原则LSP(the Liskov Substitution Principle LSP)</li>
</ul>
<p><strong>子类应当可以替换父类</strong>并出现在父类能够出现的任何地方。</p>
<ul>
<li><strong>接口隔离原则</strong>ISP(the Interface Segregation Principle ISP)</li>
</ul>
<p>不应该强迫客户程序依赖他们不用的方法，接口应该小而完备。有必要暴露的方法才做成public。</p>
<ul>
<li><strong>依赖倒置原则D</strong>IP(the Dependency Inversion Principle DIP)</li>
</ul>
<p>高层模块（稳定）不应该依赖于低层模块（变化），二者应该依赖于抽象（稳定）。</p>
<p>抽象（稳定）不应该依赖于实现细节（变化），实现细节（变化）依赖于抽象（稳定）。</p>
<ul>
<li>优先使用对象的组合，而不是类继承</li>
</ul>
<p>类继承在莫种程度上破坏了封装性，暴露的东西过多，也就是说子类父类耦合度高。而对象组合则只要求被组合的对象具有良好定义的接口。耦合度低。</p>
<ul>
<li>封装变化点</li>
</ul>
<p>一侧变化，一侧稳定。使用封装来创建对象之间的分界层，让这设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现松耦合</p>
<ul>
<li>针对接口编程，而不是针对实现编程</li>
</ul>
<p><strong>不将变量类型声明为莫个特定的具体类，而是声明为某个接口。</strong>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。减少系统中的依赖关系，从而实现，高內聚，松耦合。</p>
<h2><span id="3-虚函数的作用及实现原理">3 虚函数的作用及实现原理</span></h2><p>虚函数的作用：虚函数实现了多态的机制。基类定义了虚函数，子类重新定义父类的虚函数之后，父类根据赋值给他的子类指针，动态的调用子类的该函数。</p>
<p>实现原理：当一个类声明了一个虚函数的时候，那么在这个类实例化的时候，类的对象模型就会生成一个额外的数据，就是一个虚函数表指针，这个虚函数表指针就指向虚函数表的地址，虚函数表就是一个函数的指针数组，虚函数表中的每个元素对应一个函数指针指向该类的一个虚函数。当我们调用虚函数的时候，就跟据虚函数指针找到虚函数表，在根据虚函数表找到虚函数的具体实现。</p>
<p>如果子类覆盖了父类的虚函数，将覆盖虚函数表中该虚函数的地址。</p>
<h2><span id="4-深拷贝和浅拷贝">4 深拷贝和浅拷贝</span></h2><p>深拷贝指定的是对整个对象所有的资源进行一个拷贝，两个对象的内存资源不同释放一个不会影响另一个。浅拷贝值来嗯个对象均指向同一个内存空间，释放一个对象，另一个对象的资源也没了，造成野指针。</p>
<h2><span id="5-虚函数-纯虚函数怎么实现">5 虚函数、纯虚函数怎么实现</span></h2><p>1.用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。</p>
<p>2.存在虚函数的类都有一个1维的虚函数表，类的对象都有一个指向虚表的虚指针。虚指针是和对象对应的，虚表是和类对应的。</p>
<p>3.多态是一个接口多种实现，是面向对象的核心。</p>
<p>4.多态由虚函数来实现，结合动态绑定。</p>
<p>5.纯虚函数是虚函数在加上=0</p>
<p>6.抽象类是指至少包括一个纯虚函数的类。抽象基类不能定义对象。必须在子类实现这个函数，即现有名称，没有内容，在派生类中实现内容。</p>
<h2><span id="6-为什么有纯虚函数">6 为什么有纯虚函数</span></h2><p>1，为了方便使用多态的特性,我们常常在需要的基类定义虚函数。</p>
<p>2 ，很多情况下，基类本身生成对象是不合情理的。例如作为一个动物基类可以派生出老虎，熊猫等子类。但是生成动物对象明显不合理。</p>
<p>所以引入了纯虚函数，将函数定义为纯虚函数，则编译器要求在派生类中必须重写该虚函数以实现多态的特性，同时含有纯虚函数的对象称为抽象类，它不能生成对象。</p>
<h2><span id="7-为什么有虚析构函数">7 为什么有虚析构函数</span></h2><p>C++中基类采用virtual虚析构函数是为了防止泄漏。具体的说，如果派生类中申请了内存空间，并且在其析构函数中对这些内存空间的内容进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象的时候，调用基类的析构函数，而不会发生动态绑定调用派生类的析构函数。导致申请的内存没得到释放产生内存泄漏。</p>
<h2><span id="8-构造函数可以是虚函数吗">8 构造函数可以是虚函数吗</span></h2><p>不能，</p>
<p>从存储的角度来讲，虚函数相应一个存储在虚函数表中的函数指针，但是指向这个虚函数表的指针，虚函数指针是存储在对象的内存空间的。那么问题来了，我们还没有实例化对象，也就没有虚函数表指针，也就找不到虚构造函数，也就不能实例化对象。</p>
<p>从应用的角度上来说，虚函数的目的就是为了在不完全了解细节的情况下也能正确的处理对象。另虚函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数完成你想完成的动作。</p>
<h2><span id="9-c里面构造函数能有返回值吗">9 C++里面构造函数能有返回值吗？</span></h2><p>构造函数是没有返回值的，他知识描述了类的初始化行为。但是new一个类实例是有返回值的，因为new返回的是类实例的指针。</p>
<h2><span id="10-构造函数和析构函数能被继承吗">10 构造函数和析构函数能被继承吗</span></h2><p>子类可以继承父类的所有构造方法，但是不能继承父类的构造和析构函数。因此，在创建子类对象的时候，为了初始化从父类继承来的数据成员，系统需要调用父类的构造方法。</p>
<p>构造原则：</p>
<p>1 如果子类没有定义构造方法，则调用父类的构造方法。</p>
<p>2 如果子类定义了构造方法，不论无参数还是有参数，在创建子类对象的时候，首先执行父类无参数的构造方法，然后执行自己的构造方法。</p>
<p>3 创建子类对象的时候，如果子类的构造函数没有显示调用父类构造函数，则会调用父类的默认无参数构造函数。</p>
<p>4 在创建子类对象的时候，如果子类的构造函数没有显示调用父类的构造函数，且父类只定义了自己的有参构造函数，则会出错。</p>
<p><strong>子类只有在构造对象的时候才能默认（或者用初始化列表显示调用特定的父类构造函数）</strong>调用父类的构造函数，在构造完成后不能向调用父类成员函数一样调用父类的构造函数，这样保证了父类构造函数只能调用一次的原则。</p>
<h2><span id="11-c中重载和覆盖-隐藏的区别">11 C++中重载和覆盖、隐藏的区别</span></h2><p>Overload重载（模板），静态多态：在C++程序中，可以将语义，功能相似的函数用同一个名字表示，但是参数或者返回值不同，即为函数重载。（在相同范围内，同一个类中）</p>
<p>Override覆盖，<strong>动态多态</strong>：值派生类函数覆盖父类的函数;其特征是1在不同的范围内基类和派生类中，函数名字相同，参数相同，基类必须要有virtual关键字</p>
<p>隐藏：值得是<strong>派生类屏蔽了与其同名的基类函数</strong>，派生类与基类的方法同名，参数不同时，不论有无virtual关键字，基类函数将被隐藏。</p>
<p>如果参数相同，但是基类没有virtual关键字，基类的函数将被隐藏。</p>
<h2><span id="12-一个空的class-里有什么">12 一个空的class 里有什么</span></h2><p>构造函数，析构函数 ，拷贝复制构造函数，赋值运算符重载，取地址运算符重载，被const修饰的取地址值操作符号重载</p>
<h2><span id="13-c中一个空类的大小为什么是1">13 C++中一个空类的大小为什么是1</span></h2><p>这是实例化的原因，实例化一个对象一定在内存中有独一无二的地址，那么这个地址就一定要有实际指向的位置，编译器就会往往给空类隐含的加一个字节，这样空类在实例化之后才能在内存中获得一个独一无二的地址。</p>
<h2><span id="14-一个结构体有int-charstactic-int这个结构体占多少内存">14 一个结构体有int ,char,stactic int这个结构体占多少内存</span></h2><p>假设结构体运行环境都是64位，那么结构体中int占4字节，char为了对其占4个字节，静态不计算，解哦固体一共占8字节内存。</p>
<p>特别注意的是: c结构体中不允许定义static变量; C++结构体中可以定义static变量,sizeof时不计算该变量。</p>
<p>对其原则，当结构体内元素小于处理器位数的时候，便以结构体里最长的元素作为对其单位。如果结构体里有元素大于处理器位数，就已处理器位数作为对其单位。</p>
<h2><span id="15-结构体与联合体的区别">15 结构体与联合体的区别</span></h2><p><strong>结构体</strong></p>
<p>结构体中各成员拥有自己的内存，各自使用互补相干涉，同时存在的遵循内存对其规则。</p>
<p><strong>联合体union</strong></p>
<p>各个变量共用一块内存空间，并且同时只有一个成员能得到这块内存的使用权，各个变量共用一个内存的首地址。因此，联合体比结构体更节省内存。</p>
<h2><span id="16-函数和宏的差别">16 函数和宏的差别</span></h2><p>1 宏在预处理的阶段展开，进行文本替换，占用的是编译过程的时间，而函数占用执行时间。</p>
<p>2 宏直接展开，没有函数执行时候的压栈消耗，所以比函数执行快，规模小。</p>
<p>3 函数执行的的时候需要空间开销，既要保存现场，函数执行完之后又要恢复现场，宏则不需要。</p>
<p>4 宏在使用的时候会出现优先级问题，导致程序出错</p>
<p>5 宏函数定义的参数没有类型，预处理只负责形式上的替换，不做类型检查，危险性高。</p>
<p>6 宏不方便调试，也不允许递归</p>
<h2><span id="17-define和typedef的区别">17 define和typedef的区别</span></h2><p>1 执行时间不同，define只是在预处理阶段进行机械简单的文本难题，不做正确性检查。typedef在编译阶段有效，有类型检查的功能。</p>
<p>2 功能不同 typedef 用来定义类型的别名起到便于记忆的功能。另一个是定义机器无关的类型。比如定义一个REAL的浮点类型，在目标机器上，他可以获最高精度：typdef long doubl REAL;不支持long double的机器上看起来是这样的typedef double REAL; 在不支持double的机器上看起来是这样的typedef float REAL;</p>
<p>#define 不止可以为变量取名，还可以定义常量，变量等等其他的东西。</p>
<p>3 作用域不同，define没有作用域的限制，只要是之前定义过的宏，在以后的程序中都可以使用。而typedef有自己的作用域</p>
<h2><span id="18-在c中include和include-ltgt有什么区别">18 在C++中include”“”和include &lt;&gt;有什么区别</span></h2><p>include &lt;&gt;一般从编译器自带的库文件中寻找文件，而“”一般是从自定义的文件夹中寻找文件，如果不存在从函数库中寻找文件。</p>
<h2><span id="19-c语言中的mallocnew和c中的freedelete的区别和联系">19 C语言中的malloc/new和C++中的free/delete的区别和联系</span></h2><p>区别1：类型</p>
<p>malloc/free是函数，需要函数库支持，而new/delete是关键字，操作符，需要编译器支持。</p>
<p>区别2：作用</p>
<p>malloc和free知识简单的进行内存的申请和释放，new和delete除了内存的申请和释放还会调用对象的构造函数和析构函数对分配到的空间进行初始化和清理 。</p>
<p>3：参数和返回值</p>
<p>malloc/free需要手动计算申请空间的大小，返回值是void*,需要自己转换为自己需要的类型。new/和delete可以根据对象自动计算要分配内存的大小，返回相应对象的指针。</p>
<p>4 分配失败的时候new会跑粗bac_alloc异常。malloc分配内存失败时返回NULL.</p>
<h2><span id="20-new和delete的实现原理delete是如何知道释放内存的大小">20 new和delete的实现原理，delete是如何知道释放内存的大小</span></h2><p>new 的实现过程，先调用operator new（operator new[]） 申请足够的内存（内部通常由malloc实现），然后在分配的内存上调用构造函数，对象分配了空间并且构造完成，返回一个指向该对象的指针。</p>
<p>delete的实现过程，先调用析构函数，然后由operator delete 函数释放内存（底层通常由free实现）。</p>
<p>delete怎么知道要释放的大小，需要在new[]一个数组对象的时候，分配数组空间的时候多分配了4个字节的大小，专门保护数组的大小，用delete[]的时候就会取出这个保存的数，就知道调用几次析构函数了。</p>
<h2><span id="21-malloc申请的内存能用delete释放吗">21 malloc申请的内存能用delete释放吗</span></h2><p>不能，new和delete完全可以取代malloc和free的。malloc/和free操作的对象必须是明确大小的。new和delete会自动进行类型的检查和大小,malloc和free不能执行构造函数和析构函数，如果我的内存中有一个指针指向堆中的一块内存，我指定对象内存大小，调用了free释放到了我本身的内存，就会产生内存泄漏的情况，有一块之前在创建对象时分配的内存没有被释放。</p>
<h2><span id="22-malloc和free的实现原理">22 malloc和free的实现原理</span></h2><p>在标准c库中，提供了malloc/free函数分配和释放内存，两个函数是通过brk、mmap、munmap来实现的;</p>
<p>malloc小于128k的内存的时候，使用brk分配内存，brk是将数据段的最该地址指针_edata往高地址推，在malloc大于128k的时候，使用mmap分配内存，在堆和栈之间找一对空闲的内存分配。这两种方式分配的是虚拟内存，没有分配物理内存。真正的分配要在第一次访问已经分配的虚拟地址空间的时候，发生缺页中断，由操作希用分配物理内存，建立虚拟内存和物理内存之间的映射关系。</p>
<p><strong>工作机制</strong></p>
<p>　　malloc函数的实质体现在它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。操作系统中记录一个记录空闲内存地址的链表。调用malloc函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。</p>
<h2><span id="23-malloc-realloc-calloc的区别">23 malloc 、realloc、calloc的区别</span></h2><p>1malloc函数</p>
<p><code>void* malloc(unsigned int num_size);</code></p>
<p><code>int *p = (int *)malloc(20*sizeof(int));</code></p>
<p>申请20个int类型的空间</p>
<p>2 calloc函数</p>
<p><code>void* calloc(size_t n,size_t size);</code></p>
<p><code>int *p = calloc(20,sizeof(int));</code></p>
<p>malloc的申请空间是随机化的，calloc申请的空间的值是初始化为0的。</p>
<p>3 realloc函数</p>
<p><code>void realloc(void *p,size_t new_size)</code></p>
<p>给分配的额外分配空间，用于扩充容量。</p>
<p><strong>这里面有几个问题：</strong></p>
<h3><span id="1堆和栈最大可分配的内存的大小">1.堆和栈最大可分配的内存的大小</span></h3><h3><span id="2堆和栈的内存管理方式">2.堆和栈的内存管理方式</span></h3><h3><span id="3堆和栈的分配效率">3.堆和栈的分配效率</span></h3><p>首先针对第一个问题，一般来说对于一个进程栈的大小远远小于堆的大小，在linux中，你可以使用ulimit -s (单位kb)来查看一个进程栈的最大可分配大小，一般来说不超过8M，有的甚至不超过2M，不过这个可以设置，而对于堆你会发现，针对一个进程堆的最大可分配的大小在G的数量级上，不同系统可能不一样，比如32位系统最大不超过2G，而64为系统最大不超过4G，所以当你需要一个分配的大小的内存时，请用new，即用堆。</p>
<p>其次针对第二个问题，栈是系统数据结构，对于进程/线程是唯一的，它的分配与释放由操作系统来维护，不需要开发者来管理。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时，这些存储单元会被自动释放。栈内存分配运算内置于处理器的指令集中，效率很高，不同的操作系统对栈都有一定的限制。 堆上的内存分配，亦称动态内存分配。程序在运行的期间用malloc申请的内存，这部分内存由程序员自己负责管理，其生存期由开发者决定：在何时分配，分配多少，并在何时用free来释放该内存。这是唯一可以由开发者参与管理的内存。使用的好坏直接决定系统的性能和稳定。</p>
<p>由上可知，但我们需要的内存很少，你又能确定你到底需要多少内存时，请用栈。而当你需要在运行时才知道你到底需要多少内存时，请用堆。</p>
<p>最后针对第三个问题，栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率 比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在 堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会 分 到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p>
<h2><span id="24-c关键字mutable的作用">24 C++关键字mutable的作用</span></h2><p><strong>如果需要修改在const成员方法里的成员变量值，那么需要将这个成员变量修饰为mutable。</strong>即用mutable修饰的成员变量不受const成员方法的限制;</p>
<p>我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成 const 的。但是，有些时候，我们需要在 const 的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被 mutalbe 来修饰。</p>
<h2><span id="25-引用和指针有什么区别">25 引用和指针有什么区别</span></h2><p>1 引用必须被初始化，指针可以不用</p>
<p>2 引用是变量的一个别名，内部实现是只读指针</p>
<p>3 引用初始化之后不能改变，指针改变指向不同的对象。</p>
<h2><span id="26-什么是黑盒测试和白盒测试">26 什么是黑盒测试和白盒测试</span></h2><p>白盒测试：是通过程序的源代码进行测试而不是用户界面。这种类型的测试需要从代码语句发现内部代码在的算法，溢出，路径，条件等等中的缺点或者错误，进而加以改正。</p>
<p>黑盒测试：通过使用整个软件或者莫种软件功能来严格的测试，而并没有通过检查程序的源码或者很清晰的了解软件的源代码程序是怎样设计的。测试人员通过输入他们的数据然后看输出结果从而了解软件怎样工作。在测试其间，把程序看作一个不能打开的黑匣子，完全不考虑内部结构和内部特性，测试者在程序接口进行测试，它只检查程序是否能适当地接受和正确的输出。</p>
<h2><span id="27-野指针是什么如何检测内存泄漏">27 野指针是什么？如何检测内存泄漏</span></h2><p>野指针，指向被释放的内存或者没有访问权限的内存指针。</p>
<p>野指针主要分为三种</p>
<p>1 指针变量没有被初始化，指针变量没有被初始化它的值将会是随机的。</p>
<p>2 指针p别free或者delete之后没有设置为NULL</p>
<p>3 指针操作超越了变量的作用范围</p>
<p>如何避免野指针</p>
<p>1 对指针变量进行初始化</p>
<p>2 指针用完释放内存之后，将指针赋值为null.</p>
<h2><span id="28-悬空指针和野指针的区别">28 悬空指针和野指针的区别</span></h2><p>1 野指针:访问一个已经删除或者访问受限的内存区域的指针。</p>
<p>2 悬空指针：一个指针的指向对象已经被删除，那么就成了悬空指针。野指针指的是那些未初始化的指针。</p>
<h2><span id="29-内存泄漏">29 内存泄漏</span></h2><p>内存泄漏是由于疏忽或者误操作造成程序未能释放掉不再使用的内存情况。</p>
<p>内存泄漏的分类：</p>
<ol>
<li><p>堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.</p>
</li>
<li><p>系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</p>
</li>
<li><p>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</p>
</li>
</ol>
<p>后果: 只发生一次小的泄漏可能并不在意，但是泄漏大量的内存的程序将会出现各种症状，性能下降到内存逐渐用完，导致另一个程序失败。</p>
<p>如何排查：使用工具软件</p>
<p>LeakTracer: Linux、Solaris和HP-UX下跟踪和分析C++程序中的内存泄漏</p>
<p>BoundsCheacker,BoundsCheaker是一个运行错误检查工具，它主要定位程序运行其间发生的各种错误。</p>
<p>调试运行DEBUG版本程序，</p>
<p>定位错误：</p>
<p>) 检查、定位内存泄漏<br>检查方法:在 main 函数最后面一行,加上一句_CrtDumpMemoryLeaks()。调<br>试程序,自然关闭程序让其退出,查看输出:<br>输出这样的格式{453}normal block at 0x02432CA8,868 bytes long<br>被{}包围的 453 就是我们需要的内存泄漏定位值,868 bytes long 就是说这个<br>地方有 868 比特内存没有释放。<br>定位代码位置</p>
<p>在 main 函数第一行加上_CrtSetBreakAlloc(453);意思就是在申请 453 这块内<br>存的位置中断。然后调试程序,程序中断了,查看调用堆栈。加上头文件<br>#include &lt;crtdbg.h&gt;</p>
<h2><span id="30-内存泄漏的解决方案">30 内存泄漏的解决方案</span></h2><p>1 使用内存分配函数一定记得要释放掉</p>
<p>2 将分配内存的指针以链表的形式进行管理，使用完毕之后从链表中删除，程序结束之后可以检查该链表，防止出现野指针。</p>
<p>3 使用智能指针</p>
<h2><span id="31-函数指针和指针函数是什么">31 函数指针和指针函数是什么</span></h2><p>函数指针本质就是一个指针，指向一个函数</p>
<p><code>int (*fun)(int x,int y);</code></p>
<p>指针函数就是返回值为指针的函数</p>
<p><code>int *fun(int x,int y);</code></p>
<h2><span id="32-c11新特性了解吗">32 c++11新特性了解吗</span></h2><p>一般从这四方面回答</p>
<p>1 nullptr,auto,decltype自动类型推导，范围for循环，初始化列表，lambda表达式等等。</p>
<p>2 右值引用和移动语义</p>
<p>3 智能指针</p>
<p>4 C++11多线程编程，thread库及配套原语mutex,lock_guard,condtion_varieable,以及异步std::furture</p>
<p>5 新增容器std::array保存在栈内存中，相比堆内存的std::vector,我们能够灵活的访问这里面的元素，从而获得高性能。</p>
<h3><span id="1-nullptr">1 nullptr</span></h3><p>传统C++会把NULL、0视为一种东西。c++不允许void*隐式转换为其他类型，但是如果将NULL定义为（(void) *） 那么当编译 <code>char * ch = NULL</code>时，NULL只好被定义为0;而这依然产生问题，c++重载发生问题</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>对于这两个函数，调用foo(NULL)时会调用fun(int)，自从导致代码违反直观。</p>
<p>c++引入nullptr关键字专门区分空指针和0。nullptr能够隐士的转化为任何指针。</p>
<h3><span id="2-类型推导">2 类型推导</span></h3><p>auto 和 decltype</p>
<p>auto对一个变量自动进行推导,最常见的例子就死和迭代器以前我们需要一个迭代器需要</p>
<p><code>for(vector&lt;int&gt;::const_iterator itr = vec.begin(); itr != vec.end();++itr)</code></p>
<p>有了auto之后</p>
<p><code>for(auto itr = vec.begin()....)</code></p>
<p><strong>注意</strong> auto不能用于传递参数，不能推导数组类型，无法通过编译</p>
<p>decltype关键字解决关键字只能对变量推导的缺陷。可以对表达式的类型进行推倒</p>
<p><code>decltype(表达式)</code></p>
<p>C++11 还引入了一个叫做<strong>拖尾返回类型（trailing return type）</strong>，利用 auto 关键字将返回类型后置：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typedef T,typedef U&gt;
auto add(T x,U y) -&gt; decltype(x+y)&#123;
    return x+y;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>C++14中开始可以直接让普通的函数具备返回值推导，，下面写法合法</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typedef T,typedef U&gt;
auto add(T x,U y)&#123;
    return x+y;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="3-范围for循环">3 范围for循环</span></h3><p>基于范围的迭代写法，简洁</p>
<p><code>for(auto &amp;i : arr)</code></p>
<h3><span id="4-初始化列表">4 初始化列表</span></h3><p>统一语法在初始化对象</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct A&#123;
    int a;
    float b;
&#125;
struct B&#123;
    B(int _a,float _b):a(_a),b(_b)&#123;&#125;
    private:
        int a;
        float b;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




<p><code>A a&#123;1,1.1&#125;</code> <code>B b&#123;1,1.1&#125;</code></p>
<h3><span id="5-构造函数">5 构造函数</span></h3><p>委托构造函数，这使得构造函数可以在一个构造函数中调用另一个构造函数，从而达到简化代码的目的。</p>
<p><strong>继承构造函数</strong></p>
<p>在继承体系中，如果派生类想要使用基类的构造函数，需要在构造函数中显式声明。<br>假若基类拥有为数众多的不同版本的构造函数，这样，在派生类中得写很多对应的“透传”构造函数。如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct A&#123;
 2     A(int i)&#123;&#125;
 3     A(double d,int i)&#123;&#125;
 4     A(float f,int i,const char* c)&#123;&#125;
 5     &#x2F;&#x2F;....等等系列的构造函数版本
 6 &#125;；
 7 struct B:A&#123;
 8     B(int i):A(i)&#123;&#125;
 9     B(double d,int i):A(d,i)&#123;&#125;
10     B(float f,int i,const char* c):A(f,i,e)&#123;&#125;
11     &#x2F;&#x2F;....等等好多个和基类构造函数对应的构造函数
12 &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct A&#123;
 2     A(int i)&#123;&#125;
 3     A(double d,int i)&#123;&#125;
 4     A(float f,int i,const char* c)&#123;&#125;
 5     &#x2F;&#x2F;....等等系列的构造函数版本
 6 &#125;；
 7 struct B:A&#123;
 8     B(int i):A(i)&#123;&#125;
 9     B(double d,int i):A(d,i)&#123;&#125;
10     B(float f,int i,const char* c):A(f,i,e)&#123;&#125;
11     &#x2F;&#x2F;....等等好多个和基类构造函数对应的构造函数
12 &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>C++11继承构造函数</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"> 1 struct A&#123;
 2     A(int i)&#123;&#125;
 3     A(double d,int i)&#123;&#125;
 4     A(float f,int i,const char* c)&#123;&#125;
 5     &#x2F;&#x2F;....等等系列的构造函数版本
 6 &#125;；
 7 struct B:A&#123;
 8     using A::A;
 9     &#x2F;&#x2F;关于基类各构造函数的继承一句话搞定
10     &#x2F;&#x2F;.....
11 &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果继承构造函数不被相干的代码使用，编译器不会产生真正的函数代码，这样比产头基类各种构造按数更加节省目标空间。</p>
<h3><span id="6-lambda-表达式">6 Lambda 表达式</span></h3><p> Lambda表达式，实际上就是提供了一个类似<strong>匿名函数</strong>的特性，而匿名函数则是<strong>在需要一个函数，但是又不想费力去命名一个函数的情况下</strong>去使用的。</p>
<p>可将lambda表达式视为包含公有operator()的匿名结构或类。</p>
<p>编译器见到lambda表达式时，自动张开类似于结构或类的形式</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">[](int&amp; element) &#123;cout &lt;&lt; element &lt;&lt; &#39; &#39;;&#125;
&#x2F;&#x2F;自动展开
struct Node&#123;
    void operator() (const int&amp; element)&#123;  &#x2F;&#x2F;  默认为const无法修改
        cout &lt;&lt; element &lt;&lt; &#39; &#39;;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Lambda表达式的基本语法如下：</p>
<pre class="line-numbers language-none"><code class="language-none">1 [caputrue](params)opt-&gt;ret&#123;body;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ol>
<li>capture是捕获列表； </li>
<li>params是参数表；(选填) </li>
<li>opt是函数选项；可以填mutable,exception,attribute（选填）<br>mutable说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-const方法。<br>exception说明lambda表达式是否抛出异常以及何种异常。<br>attribute用来声明属性。 </li>
<li>ret是返回值类型（拖尾返回类型）。(选填) </li>
<li>body是函数体。</li>
</ol>
<p>捕获列表：lambda表达式的<strong>捕获列表精细控制了lambda表达式能够访问的外部变量，以及如何访问这些变量</strong>。</p>
<ol>
<li><p>[]不捕获任何变量。 </p>
</li>
<li><p>[&amp;]捕获外部作用域中所有变量，并作为引用在函数体中使用（<strong>按引用捕获</strong>）。 </p>
</li>
<li><p>[=]捕获外部作用域中所有变量，并作为副本在函数体中使用(<strong>按值捕获</strong>)。注意值捕获的前提是变量可以拷贝，且被捕获的变量在 lambda 表达式被创建时拷贝，而非调用时才拷贝。如果希望lambda表达式在调用时能即时访问外部变量，我们应当使用引用方式捕获。</p>
</li>
<li><p>[=,&amp;foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量。 </p>
</li>
<li><p>[bar]按值捕获bar变量，同时不捕获其他变量。 </p>
</li>
<li><p>[this]捕获当前类中的this指针，<strong>让lambda表达式拥有和当前类成员函数同样的访问权限。</strong>如果已经使用了&amp;或者=，就默认添加此选项。捕获this的目的是可以在lambda中使用当前类的成员函数和成员变量。</p>
</li>
</ol>
<p>7)<strong>如果希望去修改按值捕获的外部变量，需要显示指明lambda表达式为mutable。被mutable修饰的lambda表达式就算没有参数也要写明参数列表。</strong></p>
<p>在多种捕获方式中，<strong>最好不要使用[=]和[&amp;]默认捕获所有变量。</strong></p>
<p>默认引用捕获所有变量，你有很大可能会出现悬挂引用（Dangling references），因为引用捕获不会延长引用的变量的生命周期：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">1 std::function&lt;int(int)&gt; add_x(int x)&#123;
2     return [&amp;](int a)&#123;return x+a;&#125;;
3 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>上面函数返回了一个lambda表达式，参数x仅是一个临时变量，函数add_x调用后就被销毁了，但是返回的lambda表达式却引用了该变量，当调用这个表达式时，引用的是一个垃圾值，会产生没有意义的结果。上面这种情况，使用默认传值方式可以避免悬挂引用问题。</p>
<h3><span id="7-右值引用和move语义">7 右值引用和move语义</span></h3><p>首先什么是引用，引用就是给一个变量起了别名，那右值引用就是将一个右值起了别名，主要用途有两个，右值引用实现了转移语义和完美转发。</p>
<p>移动语义：对于一个包含指针成员变量的类，由于编<strong>译器默认的拷贝构造函数都是浅拷贝</strong>，所有我们一般需要通过实现深拷贝的拷贝构造函数，为指针成员分配新的内存并进行内容拷贝，从而避免悬挂指针的问题。<strong>移动构造函数，可以将资源（堆，系统对象等）从一个对象转移到另一个对象。这样可以减少不必要的拷贝，创建和销毁。</strong></p>
<p>完美转发：<strong>需要将一组参数原封不懂的传递给另一个函数。不仅仅是值不变，还有两组属性：左值右值，const/non_const。为了保证这些属性，泛型函数需要重载各种版本，，还需要对应各种const关系。但是如果指定义一个右值引用就迎刃而解了，</strong>原因在于：</p>
<p>C++11对T&amp;&amp;的类型推导，右值实参依然是右值，左值实参依然是左值。</p>
<h3><span id="8-智能指针">8 智能指针</span></h3><p>c++里有四个智能指针auto_ptr,shared_ptr,weak_ptr,unique_ptr其中后三个是c++11支持，并且第一个已经被c++11弃用。</p>
<p>作用，<strong>智能指针的作用是管理一个指针，防止申请内存后忘记释放造成内存泄漏。智能指针可以很大程度的避免这个问题，因为智能指针就是一个类，用一个对象管理指针，构造时候获得管理权限，析构时自动delete.</strong></p>
<p>1 auto_ptr(c++98的方案)，采用所有权的模型。缺点存在潜在的内存崩溃问题。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">auto_ptr&lt;string&gt; p1(new string (&quot;i am great&quot;));
auto_ptr&lt;string&gt; p2; p2&#x3D;p1;
&#x2F;&#x2F; auto_ptr不会报错，此时不会报错，p2剥夺了p1的所有权，当程序运行时，访问p1会报错。相当于对左值进行了一个转移，相当危险的操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>2 unique_ptr 实现独占式拥有或者严格拥有的概念<strong>，保证同一时间只有一个指针能够指向该对象。避免资源泄漏。当离开作用域时自动析构。</strong>资源所有权转移只能通过std::move();</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">unique_ptr&lt;string&gt; p3 (new string (&quot;auto&quot;));
unique_ptr&lt;string&gt; p4；
p4 &#x3D; p3;&#x2F;&#x2F;此时会报错！！
&#x2F;&#x2F;编译器认为p4&#x3D;p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>3 shared_ptr，基于引用计数智能指针，<strong>多个指针可以指向相同的对象</strong>，会统计有多少个对象会同时拥有该内部指针，它使用计数机制来表明资源被几个指针共享，当引用计数为0的时候，自动释放资源。可以通过成员函数use_count()来查看资源的所有者个数。<strong>除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。</strong>当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p>
<p>成员函数：</p>
<p>use_count 返回引用计数的个数</p>
<p>unique 返回是否是独占所有权( use_count 为 1)</p>
<p>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)</p>
<p>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</p>
<p>get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的</int></p>
<p>4 weak_ptr 是一种<strong>不控制对象生命周期的智能指针,</strong> 它<strong>指向一个 shared_ptr 管理的对象.</strong> 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了<strong>对管理对象的一个访问手段</strong>。**,两个shared_ptr相互引用造成死锁，两个指针的引用计数不能下降为0,资源永远不释放。** 基于引用计数的智能指针在面对循环引用的时候无能为力，这个时候就引入了weak_ptr值引用，不计数。w<strong>eak只可以从一个shared_ptr或者weak_ptr构造，</strong>他的构造和析构函数不会引起引用计数的增加或者减小，<strong>和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class B;
class A
&#123;
public:
shared_ptr&lt;B&gt; pb_;
~A()
&#123;
cout&lt;&lt;&quot;A delete\n&quot;;
&#125;
&#125;;
class B
&#123;
public:
shared_ptr&lt;A&gt; pa_;
~B()
&#123;
cout&lt;&lt;&quot;B delete\n&quot;;
&#125;
&#125;;
void fun()
&#123;
shared_ptr&lt;B&gt; pb(new B());
shared_ptr&lt;A&gt; pa(new A());
pb-&gt;pa_ &#x3D; pa;
pa-&gt;pb_ &#x3D; pb;
cout&lt;&lt;pb.use_count()&lt;&lt;endl;
cout&lt;&lt;pa.use_count()&lt;&lt;endl;
&#125;
int main()
&#123;
fun();
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的<code>shared_ptr pb_; </code>改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。</p>
<p>注意的是我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，<code>pa-&gt;pb_-&gt;print(); </code>英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：_</p>
<p><code>_shared_ptr p = pa-&gt;pb_.lock();</code></p>
<p><code> p-&gt;print();</code></p>
<h4><span id="81autoptr简单实现">8.1autoptr简单实现</span></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"> 1 template&lt;class T&gt;
 2 class AutoPointer
 3 &#123;
 4 public:
 5     AutoPointer(T* ptr)
 6       :mPointer(ptr)&#123;&#125;
 7 
 8     AutoPointer(AutoPointer&lt;T&gt;&amp; other)
 9     &#123;
10         mPointer&#x3D; other.mPointer;  &#x2F;&#x2F;管理权进行转移
11         other.mPointer&#x3D; NULL;
12     &#125;
13 
14     AutoPointer&amp; operator &#x3D; (AutoPointer&lt;T&gt;&amp; other)
15     &#123;
16         if(this !&#x3D; &amp;other)
17         &#123;
18             delete mPointer;
19             mPointer &#x3D; other.mPointer;  &#x2F;&#x2F;管理权进行转移
20             other.mPointer&#x3D; NULL;
21         &#125;
22 
23         return *this;
24     &#125;
25 
26     ~AutoPointer()
27     &#123;
28         delete mPointer;
29     &#125;
30 
31     T&amp; operator * ()
32     &#123;
33         return *mPointer;
34     &#125;
35 
36     T* operator -&gt; ()
37     &#123;
38         return mPointer;
39     &#125;
40 
41 private:
42 
43     T* mPointer;
44 &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4><span id="82-shared_ptr">8.2 shared_ptr</span></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">1 template &lt;typename T&gt;
 2 class SharedPointer
 3 &#123;
 4 private:
 5     
 6     class Implement
 7     &#123;
 8     public:
 9         Implement(T* p) : mPointer(p), mRefs(1)&#123;&#125;
10         ~Implement()&#123; delete mPointer;&#125;
11         
12         T* mPointer;  &#x2F;&#x2F;实际指针
13         size_t mRefs;  &#x2F;&#x2F; 引用计数
14     &#125;;
15     
16     Implement* mImplPtr;
17     
18 public:
19     
20     explicit SharedPointer(T* p)
21       : mImplPtr(new Implement(p))&#123;&#125;
22         
23     ~SharedPointer()
24     &#123;
25         decrease();  &#x2F;&#x2F; 计数递减
26     &#125;
27     
28     SharedPointer(const SharedPointer&amp; other)
29       : mImplPtr(other.mImplPtr)
30     &#123;
31         increase();  &#x2F;&#x2F; 计数递增
32     &#125;
33     
34     SharedPointer&amp; operator &#x3D; (const SharedPointer&amp; other)
35     &#123;
36         if(mImplPtr !&#x3D; other.mImplPtr)  &#x2F;&#x2F; 避免自赋值
37         &#123;
38             decrease();
39             mImplPtr &#x3D; other.mImplPtr;
40             increase();
41         &#125;
42         
43         return *this;
44     &#125;
45     
46     T* operator -&gt; () const
47     &#123;
48         return mImplPtr-&gt;mPointer;
49     &#125;
50     
51     T&amp; operator * () const
52     &#123;
53         return *(mImplPtr-&gt;mPointer);
54     &#125;
55     
56 private:
57     
58     void decrease()
59     &#123;
60         if(--(mImplPtr-&gt;mRefs) &#x3D;&#x3D; 0)
61         &#123;
62             delete mImplPtr;
63         &#125;
64     &#125;
65     
66     void increase()
67     &#123;
68         ++(mImplPtr-&gt;mRefs);
69     &#125;
70 &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h3><span id="9-noexcept">9 noexcept</span></h3><p>我们通过提供noexcept说明，指定某个函数不会抛出异常。其形式是关键字noexcept紧跟在函数的参数列表后面。对于编译器来说，直到函数不会抛出异常有助于简化调用该函数的代码；其次，如果编译器确定函数不会抛出异常，他就能执行某些特殊的优化操作，这些优化操作不适用于可能出错的代码。</p>
<p>需要清楚的一点是，编译器并不会在编译是检查noexcept说明，实际上，如果一个函数在说明了noexcept的同时又含有throw语句或调用了可能抛出异常的其他函数，编译器将顺利的编译通过，并不会因为这种违反异常说明的情况而报错。一旦一个noexcept函数抛出了异常，程序就会<strong>调用terminate以确保遵守不再运行时抛出异常的承诺。</strong>因此noexcept可以在两种情况下使用：意识我们确定啊哈你输buhl抛出异常，而是我们根本不知道如何处理异常。</p>
<p><strong>noxcept有两层含义</strong>，当跟在函数参数列表后边时它是异常<strong>说明符</strong>号；而当作noexcept异常说明的bool参数出现的时候，它是一个<strong>运算符</strong>。</p>
<p>异常说明的实参,实参必须是一个可以转化为bool类型：如果实参为true，则函数不会抛出异常，如果为false则函数可能抛出异常。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void excpt_func() noexcept;
void excpt_func() noexcept (常量表达式);
void recoup(int) noexcept(true); &#x2F;&#x2F;recoup不会抛出异常
&#x2F;&#x2F;声明了recoup使用了noexcept说明符，下列表达式为true
noexcept(recoup(i))
&#x2F;&#x2F;更加一般的用法,f和g的异常说明一致
    void f() noexcept(noexcept(g()));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>noexcept更大的作用是保证应用程序的安全。比如<strong>一个类析构函数不应该抛出异常</strong>，那么对于常被析构函数调用的delete函数来说，C++11默认将delete函数设置成noexcept，就可以提高应用程序的安全性。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void operator delete(void*) noexcept;
void operator delete[](void*) noexcept;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>而同样出于安全考虑，C++11标准中让类的析构函数默认也是noexcept(true)的。</strong>当然，如果程序员显式地为析构函数指定了noexcept，或者类的基类或成员有noexcept(false)的析构函数，析构函数就不会再保持默认值。我们可以看看下面的例子：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt; 
#include &lt;exception&gt; 
using namespace std;
  
struct A &#123;  
    ~A() noexcept(true)&#123; throw 1; &#125;  
&#125;;  
  
struct B &#123;  
    ~B() noexcept(false) &#123; throw 2; &#125;  
&#125;;  
  
struct C &#123;  
    B b;  
&#125;;  
  
int funA() &#123; A a; &#125;  
int funB() &#123; B b; &#125;  
int funC() &#123; C c; &#125;  
  
int main() &#123;  
    try &#123;  
        funB();  
    &#125;  
    catch(...)&#123;  
        cout &lt;&lt; &quot;caught funB.&quot; &lt;&lt; endl; &#x2F;&#x2F; caught funB.  
    &#125;  
  
    try &#123;  
        funC();  
    &#125;  
    catch(...)&#123;  
        cout &lt;&lt; &quot;caught funC.&quot; &lt;&lt; endl; &#x2F;&#x2F; caught funC.  
    &#125;  
  
    try &#123;  
        funA(); &#x2F;&#x2F; terminate called after throwing an instance of &#39;int&#39;  
    &#125;  
    catch(...)&#123;  
        cout &lt;&lt; &quot;caught funA.&quot; &lt;&lt; endl;  
    &#125;  
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码中，无论是析构函数声明为noexcept(false)的类B，还是包含了B类型成员的类C，其析构函数都是可以抛出异常的。只有什么都没有声明的类A，其析构函数被默认为noexcept(true)，从而阻止了异常的扩散。这在实际的使用中，应该引起程序员的注意。</p>
<p><strong>异常说明与指针、虚函数和拷贝控制</strong></p>
<p><strong>函数指针以及该指针所指的函数</strong>必须具有一致的异常说明。也就是说，如果我们为了莫个指针做了不抛出异常的声明，则该指针只能执行不抛出异常的函数。如果指针显示或者隐式说明了指针可能抛出异常，则该指针可以指向任何函数。</p>
<p><code>void (*pf1)(int) noexcept = recoup;</code></p>
<p><code>void (*pf1)(int) = recoup;</code></p>
<p><strong>虚函数</strong>承诺不会抛出异常，则后续派生出来的虚函数页必须作出同样的承诺；与之相反，基类虚函数允许抛出异常，则派生类对应的函数任意。</p>
<h3><span id="10-可变模板参数">10、可变模板参数</span></h3><p>C++11的可变参数模板，<strong>对参数进行了高度泛化，可以表示任意数目、任意类型的参数，</strong>其语法为：在class或typename后面带上省略号”。</p>
<p>一个典型的可变模版参数的定义是这样的：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class... T&gt;
void f(T... args);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>上面的可变模版参数的定义当中，省略号的作用有两个：<br>1.声明一个参数包T… args，<strong>args就相当于一个参数包，这个参数包中可以包含0到任意个模板参数；</strong><br>2.<strong>省略号在模板定义的右边，</strong>可以将参数包展开成一个一个独立的参数。</p>
<p>可变模版参数和普通的模版参数语义是一致的，所以可以应用于函数和类，即可变模版参数函数和可变模版参数类，然而，模版函数不支持偏特化</p>
<p>C++11可以使用<strong>递归函数的方式展开参数包</strong>，获得可变参数的每个值。通过递归函数展开参数包，<strong>需要提供一个参数包展开的函数和一个递归终止函数</strong>。例如：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
&#x2F;&#x2F;递归终止函数
template &lt;class T&gt;
void print(T t)
&#123;
   cout &lt;&lt; t &lt;&lt; endl;
&#125;
&#x2F;&#x2F;递归终止函数
void print()
&#123;
   cout &lt;&lt; &quot;empty&quot; &lt;&lt; endl;
&#125;
&#x2F;&#x2F;展开函数,参数包Args...在展开的过程中递归调用自己，每调用一次参数包中的参数就会少一个，直到所有的参数都展开为止，当没有参数时，则调用非模板函数print终止递归过程。
template &lt;class T, class ...Args&gt;
void print(T head, Args... rest)
&#123;
   cout &lt;&lt; &quot;parameter &quot; &lt;&lt; head &lt;&lt; endl;
   print(rest...);
&#125;


int main(void)
&#123;
   print(1,2,3,4);
   return 0;
&#125;
&#x2F;&#x2F;例子2 通过可变参数模板求和
template&lt;typename T&gt;
T sum(T t)
&#123;
    return t;
&#125;
template&lt;typename T, typename ... Types&gt;
T sum (T first, Types ... rest) 
&#123;
    return first + sum&lt;T&gt;(rest...);
&#125;

sum(1,2,3,4); &#x2F;&#x2F;10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>还可以用，逗号和初始化列表展开参数包</strong>这种展开参数包的方式，不需要通过递归终止函数，</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;是直接在expand函数体中展开的, printarg不是一个递归终止函数，只是一个处理参数包中每一个参数的函数。这种就地展开参数包的方式实现的关键是逗号表达式。
template &lt;class T&gt;
void printarg(T t)
&#123;
   cout &lt;&lt; t &lt;&lt; endl;
&#125;

template &lt;class ...Args&gt;
void expand(Args... args)
&#123;
   int arr[] &#x3D; &#123;(printarg(args), 0)...&#125;;
&#125;

expand(1,2,3,4);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们知道逗号表达式会按顺序执行逗号前面的表达式，比如：</p>
<p><code>d = (a = b, c); </code></p>
<p>这个表达式会按顺序执行：b会先赋值给a，接着括号中的逗号表达式返回c的值，因此d将等于c。</p>
<p>expand函数中的逗号表达式：(printarg(args), 0)，也是按照这个执行顺序，先执行printarg(args)，再得到逗号表达式的结果0。同时还用到了C++11的另外一个特性——初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)…}将会展开成<code>((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0),  etc... )，</code>最终会创建一个元素值都为0的数组int arr[sizeof…(Args)]。由于是逗号表达式，在创建数组的过程中会先执行逗号表达式前面的部分<code>printarg(args)</code>打印出参数，也就是说在构造int数组的过程中就将参数包展开了，<strong>这个数组的目的纯粹是为了在数组构造的过程展开参数包。</strong></p>
<p>我们可以把上面的例子再进一步改进一下，将函数作为参数，就可以支持lambda表达式了，从而可以少写一个递归终止函数了，具体代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class F, class... Args&gt;void expand(const F&amp; f, Args&amp;&amp;...args) 
&#123;
  &#x2F;&#x2F;这里用到了完美转发
  initializer_list&lt;int&gt;&#123;(f(std::forward&lt; Args&gt;(args)),0)...&#125;;
&#125;
expand([](int i)&#123;cout&lt;&lt;i&lt;&lt;endl;&#125;, 1,2,3);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4><span id="模版偏特化和递归方式来展开参数包"><strong>模版偏特化和递归方式来展开参数包</strong></span></h4><p>可变参数模板类的展开一般需要定义两到三个类，包括类声明和偏特化的模板类。如下方式定义了一个基本的可变参数模板类：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;前向声明
template&lt;typename... Args&gt;
struct Sum;

&#x2F;&#x2F;基本定义
template&lt;typename First, typename... Rest&gt;
struct Sum&lt;First, Rest...&gt;
&#123;
    enum &#123; value &#x3D; Sum&lt;First&gt;::value + Sum&lt;Rest...&gt;::value &#125;;
&#125;;

&#x2F;&#x2F;递归终止，是特化的递归终止类：
template&lt;typename Last&gt;
struct Sum&lt;Last&gt;
&#123;
    enum &#123; value &#x3D; sizeof (Last) &#125;;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个Sum类的作用是在编译期计算出参数包中参数类型的size之和，通过sum&lt;int,double,short&gt;::value就可以获取这3个类型的size之和为14。</p>
<h3><span id="11-可变模板参数类tuple">11、可变模板参数类tuple</span></h3><p>可变参数模板类是一个带可变模板参数的模板类，类模板 <code>std::tuple</code> 是固定大小的异类值汇集。它是 <a href="https://zh.cppreference.com/w/cpp/utility/pair">std::pair</a> 的推广。它的定义如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt; class... Types &gt;
class tuple;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这个可变参数模板类可以携带任意类型任意个数的模板参数：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
std::tuple&lt;int&gt; tp1 &#x3D; std::make_tuple(1);
std::tuple&lt;int, double&gt; tp2 &#x3D; std::make_tuple(1, 2.5);
std::tuple&lt;int, double, string&gt; tp3 &#x3D; std::make_tuple(1, 2.5, “”);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>常用的非成员函数：</p>
<table>
<thead>
<tr>
<th><a href="https://zh.cppreference.com/w/cpp/utility/tuple/make_tuple">make_tuple</a></th>
<th>创建一个 <code>tuple</code> 对象，其类型根据各实参类型定义  (函数模板)</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://zh.cppreference.com/w/cpp/utility/tuple/tie">tie</a></td>
<td>创建左值引用的 <code>tuple</code>，或将 tuple 解包为独立对象  (函数模板)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/utility/tuple/forward_as_tuple">forward_as_tuple</a></td>
<td>创建<a href="https://zh.cppreference.com/w/cpp/language/reference#.E8.BD.AC.E5.8F.91.E5.BC.95.E7.94.A8">转发引用</a>的 <code>tuple</code>  (函数模板)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/utility/tuple/tuple_cat">tuple_cat</a></td>
<td>通过连接任意数量的元组来创建一个<code>tuple</code>  (函数模板)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/utility/tuple/get">std::get(std::tuple)</a></td>
<td>元组式访问指定的元素  (函数模板)</td>
</tr>
</tbody></table>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;tuple&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;
 
std::tuple&lt;double, char, std::string&gt; get_student(int id)
&#123;
    if (id &#x3D;&#x3D; 0) return std::make_tuple(3.8, &#39;A&#39;, &quot;Lisa Simpson&quot;);
    if (id &#x3D;&#x3D; 1) return std::make_tuple(2.9, &#39;C&#39;, &quot;Milhouse Van Houten&quot;);
    if (id &#x3D;&#x3D; 2) return std::make_tuple(1.7, &#39;D&#39;, &quot;Ralph Wiggum&quot;);
    throw std::invalid_argument(&quot;id&quot;);
&#125;
 
int main()
&#123;
    auto student0 &#x3D; get_student(0);
    std::cout &lt;&lt; &quot;ID: 0, &quot;
              &lt;&lt; &quot;GPA: &quot; &lt;&lt; std::get&lt;0&gt;(student0) &lt;&lt; &quot;, &quot;
              &lt;&lt; &quot;grade: &quot; &lt;&lt; std::get&lt;1&gt;(student0) &lt;&lt; &quot;, &quot;
              &lt;&lt; &quot;name: &quot; &lt;&lt; std::get&lt;2&gt;(student0) &lt;&lt; &#39;\n&#39;;
 
    double gpa1;
    char grade1;
    std::string name1;
    std::tie(gpa1, grade1, name1) &#x3D; get_student(1);
    std::cout &lt;&lt; &quot;ID: 1, &quot;
              &lt;&lt; &quot;GPA: &quot; &lt;&lt; gpa1 &lt;&lt; &quot;, &quot;
              &lt;&lt; &quot;grade: &quot; &lt;&lt; grade1 &lt;&lt; &quot;, &quot;
              &lt;&lt; &quot;name: &quot; &lt;&lt; name1 &lt;&lt; &#39;\n&#39;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>






<h2><span id="33-堆和栈的区别">33 堆和栈的区别</span></h2><p>堆是由低地址向高地址扩展，栈是由高地址向低扩展</p>
<p>堆总的内存是程序员分配和释放的，栈中的内存是有操作系统分配和释放的，里面存局部变量，参数等等。</p>
<p>堆中频繁的调用内存会产生内存碎片，降低程序效率。由于栈的先进现出特性不会产生碎片。</p>
<p>栈是操作系统提供的数据结构，计算机底层提供了一系列支持，分配专有的寄存器存储栈地址，压栈出栈独有指令;而堆是由c/c++库函数提供的，机制复杂，需要分配内存，合并内存和释放内存算法，效率低。</p>
<h2><span id="34-数组和指针区别数组和链表呢双向链表和单向链表">34 数组和指针区别？数组和链表呢？双向链表和单向链表？</span></h2><p>数组和指针区别：<br>1、把数组作为参数传递的时候，会退化为指针<br>2、数组名可作为指针常量<br>3、数组是开辟一块连续的内存空间,数组本身的标示符代表整个数组,可以用sizeof取得真实的大小；指针则是只分配一个指针大小的内存,并可把它的值指向某个有效的内存空间 </p>
<p><strong>数组和链表区别：</strong><br>不同：</p>
<ol>
<li>链表是链式的存储结构；数组是顺序的存储结构。 </li>
<li>链表通过指针来连接元素与元素，数组则是把所有元素按次序依次存储。 </li>
<li>链表的插入删除元素相对数组较为简单，不需要移动元素，且较为容易实现长度扩充，但是寻找某个元素较为困难；数组寻找某个元素较为简单，但插入与删除比较复杂，由于最大长度需要再编程一开始时指定，故当达到最大长度时，扩充长度不如链表方便。 </li>
</ol>
<p>相同：<br>两种结构均可实现数据的顺序存储，构造出来的模型呈线性结构。</p>
<h2><span id="35-四种类型转换cast">35 四种类型转换cast</span></h2><ul>
<li><p>static_cast:用于相关联类型指针之间的转换，还可以显示执行标准数据类型的类型转换，这种转换原本应该自动或隐士的进行。不执行运行阶段的检查。</p>
</li>
<li><p>dynamic_cast:在运行阶段执行类型转换，常用于将<strong>基类指针转化为子类指针</strong>。可检查dynamic_cast是否转化成功。</p>
<ul>
<li>转型失败会返回null(转型对象为指针时)或抛出异常 bad_cast(转型对象为引用时)。 dynamic_cast <strong>会动用运行时信息(RTTI)**来进行类型安全检查 ,因此 dynamic_cast 存在一定的效率损失。当使用 dynamic_cast 时,该类型必须含有虚函数,这是因为dynamic_cast 使用了存储在 VTABLE 中的信息来判断实际的类型,**RTTI 运行时类型识别用于判断类型。</strong><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">destination_type* pDest &#x3D; dynamic_cast&lt;class_type*&gt;(pSource);
if(pDest)
    pDest -&gt; Callfuc;         &#x2F;&#x2F;检查dynamic_cast的操作结果，以判断转换是否成功。  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>reinterpret_cast(重新解释)：与C风格相近，不管相关与否强行重新解释类型。</p>
</li>
<li><p>const_cast: 让程序员关闭对象的访问修饰符const,其去除常量性的对象必须为指针或引用。</p>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Someclass
&#123;
    public :
        void DisplayMember();  &#x2F;&#x2F;在这里没有定义为CONST
&#125;
viod DisplayDate(const Someclass&amp; mDate)
&#123;
    mDate.DisplayMembers();  &#x2F;&#x2F;编译失败，以const引用传入mDate对象，不能调用非CONST函数。
    &#x2F;&#x2F;这样写,也可以用与指针。
    Someclass&amp; refDate &#x3D; cosnt_cast&lt;Someclass&amp;&gt;(mDate);
    refDate.DisplayMembers;
    &#x2F;&#x2F;用指针的方式
    Someclass *refData &#x3D; const_cast&lt;Someclass*&gt;(mData)
    refData -&gt; DisplayMembers;
&#125;
&#x2F;&#x2F;都可以用c风格的类型转换代替
Derived* pDerivedSimple &#x3D; (Derived*)pBase;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2><span id="36迭代器it和it哪个好为什么">36.迭代器++it,和it++哪个好，为什么</span></h2><p>前置返回一个引用，后置返回一个对象，后置产生临时对象的过程会导致效率降低。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int &amp; operator++()&#123;
    *this +&#x3D; 1;
    return *this;
&#125;
int operator++()&#123;
    int temp &#x3D; *this;
    ++*this;
    return temp;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="37-static关键字的用法">37 static关键字的用法</span></h2><ul>
<li>将全局变量，函数修饰为静态全局变量，存储在静态存储区域，静态全局变量<strong>在声明它的文件之外是不可见的，</strong>只要声明他的文件可见，而普通的全局变量则是所有文件可见。</li>
<li>将局部变量修饰为静态局部变量</li>
</ul>
<p>当局部比那量离开作用域的时候，并没有销毁，而是依然存储在内存中，只不过目前暂时不能对他进行访问，直到函数再次调用，值不变，只初始化一次。</p>
<ul>
<li>将类的成员修饰为静态成员函数</li>
</ul>
<p>静态成员函数属于类的，而不属于对象，需要注意的是在静态成员函数的实现中，不可以直接引用类中的非静态数据成员，但是可以引用静态成员，如果非要引用非静态成员，则可以通过对象来引用。</p>
<ul>
<li>类成员变量修饰为静态成员变量</li>
</ul>
<p>静态成员变量是属于类的，而不是属于对象的，实现多个对象之间数据共享。</p>
<h2><span id="38-const">38 const?</span></h2><ul>
<li><p>阻止一个变量发生变化，可以使用const关键字。在定义一个变量的时候一定要初始化，因为以后没有机会改变他了。</p>
</li>
<li><p>将const变量用于指针，有三种情况。1指针指向的数据为常量，但是指针本身可以更改const int*，2指针本身不能修改，但是可以修改指向的数据，int * const，3两者都不能修改。</p>
</li>
<li><p>在函数声明中，将一个参数设置为const，在函数内部不能改变其值。</p>
</li>
<li><p>对于类成员函数，若是指定为cosnt，函数内部不能改变类的成员变量，类的对象只能访问类的成员函数。</p>
</li>
<li><p>函数返回值为const，使得返回值不能是左值，返回后不能被修改。</p>
</li>
<li><p>编译阶段，只有引用传递和指针传递可以用是否加const来区分开来。</p>
</li>
</ul>
<h2><span id="39-c模板是什么底层怎么实现">39 C++模板是什么，底层怎么实现</span></h2><p>模板是C++支持参数化多态的工具，<strong>使用模板可以使用户为类或者函数声明一种一般模式，使得类中的某些数据成员或者成员函数的参数、返回值取得任意类型。</strong></p>
<p>编译器并不是把函数模板能处理成能够处理任意类的函数：<strong>编译器从函数模板通过具体类型产生不同的函数，</strong>实现函数重载的这样一个目的;编译器对函数模板进行两次编译，<strong>在声明的地方编译一次，在调用的地方对参数替换后的代码进行编译。</strong></p>
<p><strong>函数模板要被实例化之后才能称为真正的函数。</strong>在使用函数模板的源文件中包含函数模板的头文件,如果该头文件中只有声明,没有定义,那编译器无法实例化该模板,最终导致链接错误。<strong>使用模板的目的就是能够让程序员编写与类型无关的代码。</strong></p>
<h3><span id="391模板非类型形参的详细阐述">39.1模板非类型形参的详细阐述</span></h3><p>什么是非类型形参？顾名思义，就是表示一个固定类型的常量而不是一个类型。先举一个简单的例子（模板类与模板函数都可以用非类型形参）</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;例子1：
template&lt;class T, int MAXSIZE&gt; 
class List &#123;
  private:
    T elems[MAXSIZE];  
  public:
    Print() &#123; 
      cout&lt;&lt;&quot;The maxsize of list is&quot;&lt;&lt;MAXSIZE; 
    &#125;
&#125;
List&lt;int,5&gt; list;
list.Print(); &#x2F;&#x2F;打印&quot;The maxsize of list is 5&quot;
&#x2F;&#x2F;c++11的特性
&#x2F;&#x2F;c++11以前的版本对于函数模板而言，非类型参数不能设置默认值
&#x2F;&#x2F;非类型参数必须是整形类数据（bool、char、int、long、long long）
template &lt;typename T,int num&#x3D;10&gt;
int func(T x,T y)
&#123;
    return x*y*num;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个固定类型是有局限的，<strong>只有整形，指针和引用才能作为非类型形参</strong>，而且绑定到该形参的实参必须是<strong>常量表达式</strong>，即编译期就能确认结果。常量表达式基本上是字面值以及const修饰的变量</p>
<p>这里要强调一点，我们对于非类型形参的限定要分两个方面看</p>
<p>1.对模板形参的限定，即template&lt;&gt;里面的参数</p>
<p>2.对模板实参的限定，即实例化时&lt;&gt;里面的参数</p>
<p>下面逐个解释一下<strong>非类型形参的局限</strong></p>
<p>1.浮点数不可以作为非类型形参，包括float，double。具体原因可能是历史因素，也许未来C++会支持浮点数。</p>
<p>2.类不可以作为非类型形参。</p>
<p>3.字符串不可以作为非类型形参</p>
<p>4.<strong>整形，可转化为整形的类型都可以作为形参，</strong>比如int，char，long，unsigned，bool，short（enum声明的内部数据可以作为实参传递给int，但是一般不能当形参）</p>
<p>5.指向对象或函数的指针与引用（左值引用）可以作为形参</p>
<p>下面解释一下<strong>非类型实参的局限</strong></p>
<p>1.<strong>实参必须是编译时常量表达式，</strong>不能使用非const的局部变量，局部对象地址及动态对象</p>
<p>2.非Const的全局指针，全局对象，全局变量（下面可能有个特例）都不是常量表达式。</p>
<p>3.由于形参的已经做了限定，<strong>字符串，浮点型即使是常量表达式也不可以作为非类型实参</strong></p>
<p>备注：常量表达式基本上是字面值以及const修饰的变量</p>
<h3><span id="392模板的实例化">39.2模板的实例化</span></h3><p>模板本身不会生成函数或类定义，它只是一个用于生成函数或类的方案，编译器<strong>使用模板为特定类型生成函数或类定义</strong>的过程叫做模板的实例化。</p>
<p>1.隐式实例化<br>式实例化就是这种情况:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename Any&gt;  
void swap(Any &amp;a, Any &amp;b)&#123;  
    Any temp;  
    temp &#x3D; a;  
    a &#x3D; b;  
    b &#x3D; temp;  
&#125;  
int main()&#123;  
    ....  
    swap&lt;int&gt;(a,b);  
    ....  
&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>函数模板隐式实例化指的是在发生函数调用的时候，如果没有发现相匹配的函数存在，编译器就会寻找同名函数模板，如果可以成功进行参数类型推演，就对函数模板进行实例化。</strong>很显然的影响效率这里顺便提一下swap(a,b);中的是可选的,因为编译器可以根据函数参数类型自动进行判断,也就是说如果编译器不不能自动判断的时候这个就是必要的;</p>
<p>2.显式实例化</p>
<p>前面已经提到隐式实例化可能影响效率,所以需要提高效率的显式实例化,<strong>显示实例化也称为外部实例化。在不发生函数调用的时候将函数模板实例化，</strong>或者在不适用类模板的时候将类模板实例化称之为模板显示实例化。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template void swap&lt;int&gt;(int &amp;a,int &amp;b);  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="393-特化偏特化">39.3 特化偏特化</span></h3><p><strong>有时候需要在为特殊类型实例化时，</strong>对模板进行修改使其行为不同。</p>
<p>具体化模板定义的格式如下：<br><code>template &lt;&gt; class 类名&lt;具体化类型名&gt;   &#123;...&#125;;</code></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
template&lt;typename T1,typename T2&gt;
class Test&#123;
public:
    Test(T1 i,T2 j):a(i),b(j)&#123;cout&lt;&lt;&quot;模板类&quot;&lt;&lt;endl;&#125;
private:
    T1 a;
    T2 b;
&#125;;
template&lt;&gt;   &#x2F;&#x2F;全特化，由于是全特化，参数都指定了，参数列表故为空。
class Test&lt;int ,char&gt;&#123;
public:
    Test(int i,char j):a(i),b(j)&#123;cout&lt;&lt;&quot;全特化&quot;&lt;&lt;endl;&#125;
private:
    int a;
    int b;
&#125;;
template&lt;typename T2&gt; &#x2F;&#x2F;由于只指定了一部分参数，剩下的未指定的需在参数列表中，否则报错。
class Test&lt;char,T2&gt;&#123;
public:
    Test(char i,T2 j):a(j),b(j)&#123;cout&lt;&lt;&quot;个数偏特化&quot;&lt;&lt;endl;&#125;
private:
    char a;
    T2 b;
&#125;;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="394模板类和模板函数的区别是什么">39.4模板类和模板函数的区别是什么?</span></h3><p>函数模板的实例化是由编译程序在处理函数调用时自动完成的,而类模板的实例化必<br>须由程序员在程序中显式地指定。即函数模板允许隐式调用和显式调用而类模板只能<br>显示调用。在使用时类模板必须加&lt; T &gt;,而函数模板不必</p>
<h3><span id="395为什么模板类一般都是放在一个-h-文件中">39.5为什么模板类一般都是放在一个 h 文件中</span></h3><p>1）模板定义很特殊。由 template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间,<strong>它一直处于等待状态直到被一个模板实例告知。</strong>在编译器和连接器的某一处,有一机制能去掉指定模板的多重定义。<strong>所以为了容易使用,几乎总是在头文件中放置全部的模板声明和定义。</strong></p>
<ol start="2">
<li>在分离式编译的环境下**,编译器编译某一个.cpp 文件时并不知道另一个.cpp 文件的**</li>
</ol>
<p><strong>存在,也不会去查找(当遇到未决符号时它会寄希望于连接器)。</strong>这种模式在没有模板的情况下运行良好,但遇到模板时就傻眼了,因为模板仅在需要的时候才会实例化出来,所以**,当编译器只看到模板的声明时,它不能实例化该模板**,只<strong>能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。</strong>然而当实现该模板的.cpp 文件中没有用到模板的实例时,编译器懒得去实例化,所以,整个工程的.obj 中就找不到一行模板实例的二进制代码,于是连接器也黔驴技穷了。</p>
<h2><span id="vector底层实现">vector底层实现</span></h2><p>底层数据结构是一个动态数组。默认构造的大小是0， 之后插入按照1 2  4  8  16 二倍扩容。注（<strong>GCC是二倍扩容，VS13是1.5倍扩容。</strong>原因可以考虑内存碎片和伙伴系统，内存的浪费）。<strong>扩容后是一片新的内存，需要把旧内存空间中的所有元素都拷贝进新内存空间中去，之后再在新内存空间中的原数据的后面继续进行插入构造新元素，并且同时释放旧内存空间</strong>，并且，由于vector 空间的重新配置，导致旧vector的所有迭代器都失效了。</p>
<p>vector的初始的扩容方式代价太大,初始扩容效率低， 需要频繁增长，不仅操作效率比较低，而且频繁的向操作系统申请内存容易造成过多的内存碎片，所以这个时候需要合理使用resize()和reserve()方法提高效率减少内存碎片的。</p>
<p><strong>resize()：</strong><br><code>void resize (size_type n);</code><br><code>void resize (size_type n, value_type val);</code><br>1、resize方法被用来改变vector中元素的数量，我们可以说，<strong>resize方法改变了容器的大小，且创建了容器中的对象；</strong><br>2、如果resize中所指定的n小于vector中当前的元素数量，则会删除vector中多于n的元素，使vector得大小变为n；<br>3、如果所指定的n大于vector中当前的元素数量，则会在vector当前的尾部插入适量的元素，使得vector的大小变为n，在这里，如果为resize方法指定了第二个参数，则会把后插入的元素值初始化为该指定值，如果没有为resize指定第二个参数，则用默认值填充新位置，一般为0；<br>4、如果resize所指定的n不仅大于vector中当前的元素数量，还大于vector当前的capacity容量值时，则会自动为vector重新分配存储空间；   </p>
<p><strong>reserve():避免了频繁的申请内存空间，造成过多内存碎片</strong><br><code>void reserve (size_type n);</code><br>1、<strong>reserve的作用是更改vector的容量，使vector至少可以容纳n个元素。</strong><br>2、如果n大于vector当前的容量，reserve会对vector进行扩容。其他情况下都不会重新分配vector的存储空间<br>3、reserve方法对于vector元素大小没有任何影响，<strong>不创建对象。</strong></p>
<p>vector中数据的随机存取效率很高，O(1)的时间的复杂度，但是在vector 中随机插入元素，需要移动的元素数量较多，效率比较低</p>
<h2><span id="40-请你来说一下什么时候会发生段错误">40 请你来说一下什么时候会发生段错误</span></h2><p>段错误通常发生在访<strong>问非法内存地址的时候</strong>，具体来说分为以下几种情况：</p>
<p>使用野指针</p>
<p>试图修改字符串常量的内容</p>
<h2><span id="41-cstl的内存优化">41 C++STL的内存优化</span></h2><p>1）二级配置器结构<br>STL内存管理使用二级内存配置器。<br>1、第一级配置器<br>第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。<br>一级空间配置器分配的是大于128字节的空间<br>如果分配不成功，调用句柄释放一部分内存<br>如果还不能分配成功，抛出异常<br>2、第二级配置器<br>在STL的第二级配置器中多了一些机制，避免太多小区块造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。<br>3、分配原则<br>如果要分配的区块大于128bytes，则移交给第一级配置器处理。<br>如果要分配的区块小于128bytes，则以<strong>内存池管理（memory pool</strong>），又称之次层配置（sub-allocation）：<strong>每次配置一大块内存，并维护对应的16个空闲链表（free-list）。</strong>下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。<br>当用户申请的空间小于128字节时，将字节数扩展到8的倍数，然后在自由链表中查找对应大小的子链表<br>如果在自由链表查找不到或者块数不够，则向内存池进行申请，一般一次申请20块如果内存池空间足够，则取出内存<br>如果不够分配20块，则分配最多的块数给自由链表，并且更新每次申请的块数<br>如果一块都无法提供，则把剩余的内存挂到自由链表，然后向系统heap申请空间，如果申请失败，则看看自由链表还有没有可用的块，如果也没有，则最后调用一级空间配置器<br>2）二级内存池<br>二级内存池采用了16个空闲链表，这里的16个空闲链表分别管理大小为8、16、24……120、128的数据块。这里空闲链表节点的设计十分巧妙，这里用了一个联合体既可以表示下一个空闲数据块（存在于空闲链表中）的地址，也可以表示已经被用户使用的数据块（不存在空闲链表中）的地址。</p>
<p>1、空间配置函数allocate<br>首先先要检查申请空间的大小，如果大于128字节就调用第一级配置器，小于128字节就检查对应的空闲链表，如果该空闲链表中有可用数据块，则直接拿来用（拿取空闲链表中的第一个可用数据块，然后把该空闲链表的地址设置为该数据块指向的下一个地址），如果没有可用数据块，<strong>则调用refill重新填充空间。</strong><br>2、空间释放函数deallocate<br>首先先要检查释放数据块的大小，如果大于128字节就调用第一级配置器，小于128字节则根据数据块的大小来判断回收后的空间会被插入到哪个空闲链表。<br>3、重新填充空闲链表refill<br>在用allocate配置空间时，<strong>如果空闲链表中没有可用数据块，就会调用refill来重新填充空间，新的空间取自内存池。缺省取20个数据块，如果内存池空间不足，那么能取多少个节点就取多少个。</strong><br>从内存池取空间给空闲链表用是chunk_alloc的工作，首先根据end_free-start_free来判断内存池中的剩余空间是否足以调出nobjs个大小为size的数据块出去，如果内存连一个数据块的空间都无法供应，需要用malloc去堆中申请内存。<br>假如山穷水尽，整个系统的堆空间都不够用了，malloc失败，那么chunk_alloc会从空闲链表中找是否有大的数据块，然后将该数据块的空间分给内存池（这个数据块会从链表中去除）。<br>3、总结：</p>
<ol>
<li>使用allocate向内存池请求size大小的内存空间，如果需要请求的内存大小大于128bytes，直接使用malloc。</li>
<li>如果需要的内存大小小于128bytes，allocate根据size找到最适合的自由链表。<br>a. 如果链表不为空，返回第一个node，链表头改为第二个node。<br>b. 如果链表为空，使用blockAlloc请求分配node。<br>x. 如果内存池中有大于一个node的空间，分配竟可能多的node(但是最多20个)，将一个node返回，其他的node添加到链表中。<br>y. 如果内存池只有一个node的空间，直接返回给用户。<br>z. 若果如果连一个node都没有，再次向操作系统请求分配内存。<br>①分配成功，再次进行b过程。<br>②分配失败，循环各个自由链表，寻找空间。<br>I. 找到空间，再次进行过程b。<br>II. 找不到空间，抛出异常。</li>
<li>用户调用deallocate释放内存空间，如果要求释放的内存空间大于128bytes，直接调用free。</li>
<li>否则按照其大小找到合适的自由链表，并将其插入。</li>
</ol>
<h2><span id="42-python-与c的区别">42、Python 与C++的区别</span></h2><p>PYTHON是一种脚本语言，是解释执行的，不需要经过编译，所以很方便快捷，且能够很好地跨平台，写一些小工具小程序特别合适。<br>而C++则是一种需要编译后运行语言，在特定的机器上编译后在特定的机上运行，运行效率高，安全稳定。但编译后的程序一般是不跨平台的。</p>
<p>python<strong>内存管理是由私有堆空间管理的</strong>，所有的python对象和数据结构都存储在私有堆空间中。程序员没有访问堆的权限，只有解释器才能操作。为python的堆空间分配内存的是python的内存管理模块进行的，核心api会提供一些访问该模块的方法供程序员使用。python自有的<strong>垃圾回收机制</strong>回收并释放没有被使用的内存供别的程序使用。</p>
<h2><span id="43-python内存管理">43、python内存管理</span></h2><p>关于python的存储问题</p>
<p>（1）由于python中万物皆对象，所以python的存储问题是对象的存储问题，并且对于每个对象，python会分配一块内存空间去存储它</p>
<p>（2）对于整数和短小的字符等，python会执行缓存机制，即将这些对象进行缓存，不会为相同的对象分配多个内存空间</p>
<p>（3）容器对象，如列表、元组、字典等，存储的其他对象，仅仅是其他对象的引用，即地址，并不是这些对象本身</p>
<p>关于引用计数器</p>
<p>（1）一个对象会记录着引用自己的对象的个数，每增加一个引用，个数加一，每减少一个引用，个数减一</p>
<p>（2）查看引用对象个数的方法：导入sys模块，使用模块中的getrefcount(对象)方法，由于这里也是一个引用，故输出的结果多1</p>
<p>（3）增加引用个数的情况：1.对象被创建p = Person()，增加1；2.对象被引用p1 = p，增加1；3.对象被当作参数传入函数func(object)，增加2，原因是函数中有两个属性在引用该对象；4.对象存储到容器对象中l = [p]，增加1</p>
<p>（4）减少引用个数的情况：1.对象的别名被销毁del p，减少1；2.对象的别名被赋予其他对象，减少1；3.对象离开自己的作用域，如getrefcount(对象)方法，每次用完后，其对对象的那个引用就会被销毁，减少1；4.对象从容器对象中删除，或者容器对象被销毁，减少1</p>
<p>（5）引用计数器用法：</p>
<p>import sys<br>class Person(object):<br>    pass<br>p = Person()<br>p1 = p<br>print(sys.getrefcount(p))<br>p2 = p1<br>print(sys.getrefcount(p))<br>p3 = p2<br>print(sys.getrefcount(p))<br>del p1<br>print(sys.getrefcount(p))<br>多一个引用，结果加1，销毁一个引用，结果减少1</p>
<p>（6）引用计数器机制：利用引用计数器方法，在检测到对象引用个数为0时，对普通的对象进行<strong>释放内存</strong>的机制</p>
<p>关于循环引用问题</p>
<p>（1）循环引用即对象之间进行相互引用，出现循环引用后，利用上述引用计数机制无法对循环引用中的对象进行释放空间，这就是循环引用问题</p>
<p>（2）循环引用形式：</p>
<p>class Person(object):<br>    pass<br>class Dog(object):<br>    pass<br>p = Person()<br>d = Dog()<br>p.pet = d<br>d.master = p<br>即对象p中的属性引用d，而对象d中属性同时来引用p，从而造成仅仅删除p和d对象，也无法释放其内存空间，因为他们依然在被引用。深入解释就是，循环引用后，p和d被引用个数为2，删除p和d对象后，两者被引用个数变为1，并不是0，而python只有在检查到一个对象的被引用个数为0时，才会自动释放其内存，所以这里无法释放p和d的内存空间。</p>
<h2><span id="44-python垃圾回收">44、python垃圾回收</span></h2><p>从基本原理上，当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。</p>
<p>垃圾回收时，Python不能进行其它的任务。频繁的垃圾回收将大大降低Python的工作效率。如果内存中的对象不多，就没有必要总启动垃圾回收。所以，Python只会在特定条件下，自动启动垃圾回收。当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。</p>
<p><strong>分代回收</strong><br>Python同时采用了分代(generation)回收的策略。这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。</p>
<p>Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。</p>
<h3><span id="孤立的引用环">孤立的引用环</span></h3><p>引用环的存在会给上面的垃圾回收机制带来很大的困难。这些引用环可能构成无法使用，但引用计数不为0的一些对象。为了回收这样的引用环，Python复制每个对象的引用计数，可以记为gc_ref。假设，每个对象i，该计数为gc_ref_i。Python会遍历所有的对象i。对于每个对象i引用的对象j，将相应的gc_ref_j减1。</p>
<p>在结束遍历后，gc_ref不为0的对象，和这些对象引用的对象，以及继续更下游引用的对象，需要被保留。而其它的对象则被垃圾回收。</p>
<h2><span id="45-说一下c的内存管理是怎么样的">45、说一下C++的内存管理是怎么样的？</span></h2><p>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。</p>
<p>代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</p>
<p>数据段：存储程序中已初始化的全局变量和静态变量</p>
<p>bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。</p>
<p>堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。</p>
<p>映射区:存储动态链接库以及调用mmap函数进行的文件映射</p>
<p>栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值</p>
<h2><span id="46-extern-用法">46 extern 用法?</span></h2><p><strong>1) extern 修饰变量的声明</strong><br>如果文件 a.c 需要引用 b.c 中变量 int v,就可以在 a.c 中声明 extern int v,然后<br>就可以引用变量 v。<br><strong>2) extern 修饰函数的声明</strong><br>如果文件 a.c 需要引用 b.c 中的函数,比如在 b.c 中原型是 int fun(int mu),那么就可以在 a.c 中声明 extern int fun(int mu),然后就能使用 fun 来做任何事情。就像变量的声明一样,extern int fun(int mu)可以放在 a.c 中任何地方,而不一定非要放在 a.c 的文件作用域的范围中。<br>3) extern 修饰符可用于<strong>指示 C 或者 C++函数的调用规范。</strong>比如在 <strong>C++中调用 C 库函数</strong>,就需要在 C++程序中用 extern “C”声明要引用的函数。这是给链接器用的,告诉链接器在链接的时候用 C 函数规范来链接。主要原<br>因是 <strong>C++和 C 程序编译完成后在目标代码中命名规则不同。</strong></p>
<h2><span id="47-类的初始化方式构造函数执行顺序为什么用成员初始化列表会快一些">47、类的初始化方式？构造函数执行顺序？为什么用成员初始化列表会快一些？</span></h2><ol>
<li><strong>赋值初始化</strong>,通过在函数体内进行赋值初始化;<strong>列表初始化,**在冒号后使用初始化列表进行初始化。<br>这两种方式的主要区别在于:<br>对于</strong>在函数体中初始化**,是在所有的数据成员被<strong>分配内存空间后才进行的</strong>。列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),那么分配了内存空间后在进入函数体之前给数据成员赋值,就是说<strong>初始化这个数据成员此时函数体还未执行。</strong></li>
<li>一个派生类构造函数的执行顺序如下:<br>1<strong>虚拟基类的构造函数</strong>(多个虚拟基类则按照继承的顺序执行构造函数)。<br>2<strong>基类的构造函数</strong>(多个普通基类也按照继承的顺序执行构造函数)。<br>3<strong>类类型的成员对象</strong>的构造函数(按照初始化顺序)<br>4<strong>派生类自己的构造函数。</strong></li>
<li>方法一是在构造函数当中做赋值的操作,而方法二是做纯粹的初始化操作。我们都知道,C++的<strong>赋值操作是会产生临时对象的。临时对象的出现会降低程序的效</strong></li>
</ol>
<p><strong>率。</strong></p>
<h2><span id="48-c-cout-保留小数点位">48、c++ cout 保留小数点位</span></h2><p>需要头文件 <iomanip></iomanip></p>
<p>输出时需要用 fixed 和 setprecision()</p>
<p>fixed代表输出浮点数，setprecision()设置精度。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#96;#include &lt;iostream&gt;&#96;&#96;#include &lt;iomanip&gt;&#96;&#96;#include &lt;cstdio&gt;&#96; &#96;using&#96; &#96;namespace&#96; &#96;std;&#96; &#96;int&#96; &#96;main(&#96;&#96;int&#96; &#96;argc, &#96;&#96;char&#96; &#96;const&#96; &#96;*argv[]) &#123;&#96;&#96;    &#96;&#96;printf&#96;&#96;(&#96;&#96;&quot;%.2lf\n&quot;&#96;&#96;, 12.345);&#96;&#96;    &#96;&#96;cout &lt;&lt;&#96;&#96;&#x2F;* fixed &lt;&lt; *&#x2F;&#96;&#96;setprecision(2) &lt;&lt; 12.345 &lt;&lt; endl;&#96;&#96;    &#96;&#96;cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; 12.345 &lt;&lt; endl;&#96;&#96;    &#96;&#96;return&#96; &#96;0;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2><span id="49-了解c默默编写并调用哪些函数">49、了解C++默默编写并调用哪些函数</span></h2><ol>
<li><strong>成员函数只有被需要(被调用)才必须有定义</strong>,同理,只有当默认构造函数,拷贝构造函数,赋值操作符,析构函数被需要而类定义它们时,它们才会被编译器创建出来(除非函数在基类中被声明为虚函数,编译器产生的函数是非虚的,public的).</li>
<li>并不是只要类没有定义默认构造函数,拷贝构造函数,赋值操作符时编译器就会自动合成它们,它们只有在”被需要”的时候才被产生.</li>
<li>虽然编译器在类的创建者没有声明但是需要的情况下产生赋值操作符,但是有些时候编译器无法产生它,包括以下两种情况:</li>
</ol>
<p>​    1). 数据成员是const对象或引用.</p>
<p>​    2). 某个基类将赋值操作符声明为private.</p>
<h2><span id="49-c编译器合成默认构造函数和复制控制成员拷贝构造函数赋值操作符析构函数的条件">49、C++编译器合成默认构造函数和复制控制成员(拷贝构造函数,赋值操作符,析构函数)的条件</span></h2><p>”C++新手一般有两个常见的<strong>误解</strong>:</p>
<p>任何class如果没有定义default constructor,就会被合成一个出来.</p>
<p>编译器合成出来的default constructor会明确设定class 内每一个data member的默认值.”</p>
<p>现在主要解释第一条为什么是错误的,根据《深入理解C++对象模型》,”default constructo<strong>r 在需要的时候被编译器产生出来”,以下就是4种”需要的时候”:</strong></p>
<p>1). 该类<strong>含有一个成员对象</strong>而后者有一个默认构造函数.</p>
<p>如果一个类没有任何构造函数,但它含有一个成员函数,这个成员函数含有默认构造函数,那么编译器就需要为这个类合成一个默认构造函数并调用那个成员的默认构造函数.</p>
<p>2). 该类<strong>继承自一个基类且后者带有默认构造函数.</strong></p>
<p>原理和1)类似</p>
<p>3). 该类带有一个<strong>虚函数</strong></p>
<p>编译器需要合成一个默认构造函数并在编译期<strong>发生两种扩张操作:**”一个virtual function table(在cfront中被称为</strong>vtbl)会被编译器产生出来**,内放class的virtual function地址”,”在每一个class object中,<strong>一个额外的pointer member(也就是vptr)会被编译器合成出来</strong>,内含相关的class vtbl地址”.</p>
<p>4). 该类<strong>派生自一个继承串链,其中有一个或多个虚基类</strong></p>
<p>在派生类继承基类时，加上一个virtual关键词则为虚拟基copy类继承，虚基类主要解决在多重继承时，基类可能被多次继承，虚基类主要提供一个基类给派生类</p>
<p>不同编译器对虚基类的实现不同,但编译器需要合成一个默认构造函数并改变对虚基类”执行存取操作”的那些码,使得对虚基类的操作延迟至执行期才决定下来.</p>
<p>同理,如果类没有定义**拷构造函数,**那么编译器会视该类有没有展现”bitwise copy semantics“(位逐次拷贝语义来决定是否合成拷贝构造函数),在以下四种情况下类不展现出”bitwise copy semantics“:</p>
<p>1). 该类含有一个成员对象而后者有一个拷贝构造函数.</p>
<p>2). 该类继承自一个基类且后者带有拷贝构造函数.</p>
<p>3). 该类带有一个虚函数</p>
<p>4). 该类派生自一个继承串链,其中有一个或多个虚基类</p>
<p>可见,编译器在类没有定义拷贝构造函数时合成拷贝构造函数的要求与默认构造函数类似,唯一不同的是如果编译器不合成默认构造函数,那么将不会对成员进行任何初始化操作,如果编译器不合成拷贝构造函数,那么将会进行”b<strong>itwise copy”(位逐次拷贝,按位逐位拷贝),如果成员有指针,那么位逐次拷贝进行的是浅复制.</strong></p>
<h2><span id="50-讲讲移动构造函数">50 、讲讲移动构造函数</span></h2><p>1 为什么要有移动构造函数呢？我们想这个问题，我们用a初始化对象b，之后对象a我们就不用了，但是a的空间还在啊，既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么我们为什么不直接用a的空间呢？这样就避免了新的空间的分配，大大降低了构造成本。这就是设置移动构造函数的初衷。</p>
<p>2 拷贝构造函数中,对于指针,我们一定要采用深层复制,而移动构造函数中,对于指针,我们采用浅层复制。浅层复制之所以危险,是因为两个指针共同指向一片内存空间,若第一个指针将其释放,另一个指针的指向就不合法了。<strong>所以我们只要避免第一个指针释放空间就可以了</strong>。避免的方法就是将第一个指针(比如 a-&gt;value)置为NULL,这样在调用析构函数的时候,由于有判断是否为 NULL 的语句,所以析构 a的时候并不会回收 a-&gt;value 指向的空间;</p>
<p>3 移动构造函数的参数和拷贝构造函数不同,拷贝构造函数的参数是一个左值引用,但是移动构造函数的初值是一个右值引用。意味着,移动构造函数的参数是一个右值或者将亡值的引用。也就是说,只用用一个右值,或者将亡值初始化另一个对象的时候,才会调用移动构造函数。而那个 move 语句,就是将一个左值变成一个将亡值。</p>
<h2><span id="51-vector-与list的区别与应用">51、vector 与list的区别与应用？</span></h2><p>vector 和数组类似,<strong>拥有一段连续的内存空间</strong>,并且起始地址不变。因此能高效的进行随机存取,时间复杂度为 o(1);但因为内存空间是连续的,所以在进行<strong>插入和删除操作时,会造成内存块的拷贝,**时间复杂度为 o(n)。另外,当数组中内存空间不够时,会</strong>重新申请一块内存空间并进行内存拷贝。<strong>它与数组最大的区别就是 vector **不需程序员自己去考虑容量问题</strong>,库里面本身已经实现了容量的动态增长,而数组需要程序员手动写入扩容函数进形扩容。</p>
<p>ist 是由双向链表实现的,因此内存空间是不连续的。只能通过指针访问数据,所以 list 的随机存取非常没有效率,时间复杂度为 o(n);但由于链表的特点,能高效地进行插入和删除。非连续存储结构:list 是一个双链表结构,支持对链表的双向遍历。每个节点包括三个信息:元素本身,指向前一个元素的节点( prev)和指向下一个元素的节点(next)。因此 list 可以高效率的对数据元素任意位置进行访问和插入删除等操作。由于涉及对额外指针的维护,所以开销比较大。</p>
<h2><span id="52-vector的扩容机制">52、vector的扩容机制？</span></h2><p>我们知道，vector 在需要的时候会扩容，在 VS 下是 1.5倍，在 GCC 下是 2 倍。那么会产生两个问题：</p>
<p>（1）为什么是成倍增长，而不是每次增长一个固定大小的容量呢？</p>
<p>（2）为什么是以 2 倍或者 1.5 倍增长，而不是以 3 倍或者 4 倍等增长呢？</p>
<p>(1).如果已成倍方式增长。假定有 n 个元素,倍增因子为 m； 完成这 n 个元素往一个 vector 中的 push_back操作，需要重新分配内存的次数大约为 logm(n)； 第 i 次重新分配将会导致复制 m^(i) (也就是当前的vector.size() 大小)个旧空间中元素; *<em>n 次 push_back 操作所花费的时间复制度为O(n)**，$\sum_{i =1}^{\log_mn} m^i= n</em>m/(m-1)$</p>
<p>m / (m - 1)，这是一个常量，均摊分析的方法可知，vector 中 push_back 操作的时间复杂度为常量时间.</p>
<p> 如果一次增加固定值大小 。假定有 n 个元素,每次增加k个；第i次增加复制的数量为为：ki ；$\sum_{i=1}^{n/k}ki$</p>
<p>n次 push_back 操作所花费的时间复杂度为O(n^2):</p>
<p>均摊下来每次push_back 操作的时间复杂度为O(n)；</p>
<p>(2)使用 k=2 增长因子的问题在于,**每次扩展的新尺寸必然刚好大于之前分配的总和,**也就是说,之前分配的内存空间不可能被使用。这样对内存不友好。最好把增长因子设为(1,2).</p>
<h2><span id="53-请你来说一下map和set有什么区别分别又是怎么实现的">53、请你来说一下map和set有什么区别，分别又是怎么实现的？</span></h2><p>map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。</p>
<p>map和set区别在于：</p>
<p>（1）map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。</p>
<p>（2）<strong>set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。</strong>其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。</p>
<p>（3）<strong>map支持下标操作，set不支持下标操作。</strong>map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此<strong>下标运算符[ ]在map应用中需要慎用</strong>，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。</p>
<h2><span id="54-请你来介绍一下stl的allocator">54、请你来介绍一下STL的allocator</span></h2><p>STL的分配器用于封装STL容器在内存管理上的底层细节。在C++中，其内存配置和释放如下：</p>
<p>new运算分两个阶段：(1)调用::operator new配置内存;(2)调用对象构造函数构造对象内容</p>
<p>delete运算分两个阶段：(1)调用对象希构函数；(2)掉员工::operator delete释放内存</p>
<p>为了精密分工，STL allocator将两个阶段操作区分开来：内存配置有alloc::allocate()负责，内存释放由alloc::deallocate()负责；对象构造由::construct()负责，对象析构由::destroy()负责。</p>
<p>同时为了提升内存管理的效率，<strong>减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器，</strong>当分配的空间大小超过128B时，会使用第一级空间配置器；当分配的空间大小小于128B时，将使用第二级空间配置器。第一级空间配置器直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放，而第<strong>二级空间配置器采用了内存池技术，通过空闲链表来管理内存。</strong></p>
<h2><span id="55-volatile-关键字的作用">55、volatile 关键字的作用?</span></h2><p>volatile 关键字是一种类型修饰符,<strong>用它声明的类型变量表示可以被某些编译器未知的因素更改</strong>,比如:操作系统、硬件或者其它线程等。<strong>遇到这个关键字声明的变量,编译器对访问该变量的代码就不再进行优化,从而可以提供对特殊地址的稳定访问。</strong>声明时语法:int volatile vInt; 当要求使用 volatile 声明的变量的值的时候**,系统总是重新从它所在的内存读取数据,即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。**<br>volatile 用在如下的几个地方:</p>
<ol>
<li>中断服务程序中修改的<strong>供其它程序检测的变量需要加 volatile;</strong></li>
<li><strong>多任务环境下各任务间共享的标志应该加 volatile;</strong></li>
<li><strong>存储器映射的硬件寄存器通常也要加 volatile</strong> 说明,因为每次对它的读写都可能由不同意义;</li>
</ol>
<h2><span id="56-讲讲大端小端如何检测">56、讲讲大端小端，如何检测</span></h2><p>大端模式:是指数据的<strong>高字节保存在内存的低地址</strong>中,而数据的低字节保存在内存的高地址端。<br>小端模式,是指数据的<strong>高字节保存在内存的高地址中</strong>,低位字节保存在在内存的低地址端。</p>
<p>一个32位int数的十六进制值为0x01234567（<strong>最高有效位——最低有效位</strong>），位于地址0x100~0x103（每个地址单元一般容量为1字节）</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;将int 48存起来，然后取得其地址，再将这个地址转为char* 这时候，如果是小端存储，那么char*指针就指向48； 48对应的ASCII码为字符‘0’；
void judge_bigend_littleend1()
&#123;
    int i &#x3D; 48;
    int* p &#x3D; &amp;i;
    char c &#x3D; 0;
    c &#x3D; *((char*)p);

    if (c &#x3D;&#x3D; &#39;0&#39;)
        printf(&quot;小端\n&quot;);
    else
        printf(&quot;大端\n&quot;);
&#125;

&#x2F;&#x2F;定义变量int i&#x3D;1;将 i 的地址拿到，强转成char*型，这时候就取到了 i 的低地址，这时候如果是1就是小端存储，如果是0就是大端存储。
void judge_bigend_littleend2()
&#123;
    int i &#x3D; 1;
    char c &#x3D; (*(char*)&amp;i);

    if (c)
        printf(&quot;小端\n&quot;);
    else
        printf(&quot;大端\n&quot;);
&#125;
&#x2F;&#x2F;定义联合体，一个成员是多字节，一个是单字节，给多字节的成员赋一个最低一个字节不为0，其他字节为0 的值，再用第二个成员来判断，如果第二个字节不为0，就是小端，若为0，就是大端。
void judge_bigend_littleend3()
&#123;
    union
    &#123;
        int i;
        char c;
    &#125;un;
    un.i &#x3D; 1;

    if (un.c &#x3D;&#x3D; 1)
        printf(&quot;小端\n&quot;);
    else
        printf(&quot;大端\n&quot;);
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="57-讲一下友元">57、讲一下友元？</span></h2><p><strong>私有成员只能在类的成员函数内部访问</strong>，如果想在别处访问对象的私有成员，只能通过类提供的接口（成员函数）间接地进行。这固然能够带来数据隐藏的好处，利于将来程序的扩充，<strong>但也会增加程序书写的麻烦。</strong></p>
<p><a href="http://c.biancheng.net/cplus/">C++</a> 是从结构化的<a href="http://c.biancheng.net/c/">C语言</a>发展而来的，<strong>需要照顾结构化设计程序员的习惯，所以在对私有成员可访问范围的问题上不可限制太死。</strong></p>
<p>C++ 设计者认为， 如果有的程序员真的非常怕麻烦，<strong>就是想在类的成员函数外部直接访问对象的私有成员，</strong>那还是做一点妥协以满足他们的愿望为好，这也算是眼前利益和长远利益的折中。因此，C++ 就有了<strong>友元（friend）</strong>的概念。打个比方，这相当于是说：<strong>朋友是值得信任的，所以可以对他们公开一些自己的隐私。</strong></p>
<p>友元提供了一种 普通函数或者类成员函数 访问另一个类中的私有或保护成员 的机制。也就是说有两种形式的友元：</p>
<p>（1）<strong>友元函数</strong>：普通函数对一个访问某个类中的私有或保护成员。  friend 函数原型;</p>
<p>（2）<strong>友元类</strong>：友元类可以访问声明为朋友的类的私有成员和受保护成员。友元类的重要用途是用于表示<strong>由类表示的数据结构的一部分</strong>，以提供对表示该数据结构的主类的访问。 </p>
<p><strong>类A作为类B的友元时</strong>，类A称为友元类。A中的所有成员函数都是B的友元函数，都可以访问B中的所有成员。</p>
<p><strong>A可以在B的public部分或private部分进行声明</strong>，方法如下：</p>
<p>friend [class]&lt;类名&gt;; //友元类类名</p>
<p>友元函数的宣告可以放在类声明的任何地方，不受访问限定关键字private、protected、public的限制。</p>
<p><strong>友谊关键字应该谨慎使用。</strong>如果一个拥有private或者protected成员的类，<strong>宣告过多的友元函数，可能会降低封装性的价值，也可能对整个设计框架产生影响。</strong>友元的存在，使得类的接口<strong>扩展更为灵活</strong>，使用友元进行运算符重载从概念上也更容易理解一些，而且，C++规则已经极力地将友元的使用限制在了一定范围内，<strong>它是单向的、不具备传递性、不能被继承，所以，应尽力合理使用友元。</strong></p>
<p>要想使得一组重载函数全部成为类的友元，必须一一声明，否则只有匹配的那个函数会成为类的友元，编译器仍将其他的当成普通函数来处理。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
class Exp
&#123;
public:
firend void test(int);  
&#125;;
void test();
void test(int);
void test(double);
&#x2F;&#x2F;上述代码中，只有“void test(int)”函数是Exp类的友元函数，“void test()”和“void test(double)”函数都只是普通函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2><span id="58-说一下stl中迭代器的作用有指针为什么还要有迭代器">58、说一下STL中迭代器的作用，有指针为什么还要有迭代器？</span></h2><p>迭代器是一种抽象的设计理念**,通过迭代器可以在不了解容器内部原理的情况下遍历容器,**除此之外,STL 中迭代器一个最重要的作用就是作为容器与 STL 算法的粘合剂。</p>
<p><strong>迭代器的作用就是提供一个遍历容器内部所有元素的接口,因此迭代器内部必须保存一个与容器相关联的指针</strong>,然后重载各种运算操作来遍历,其中最重要的是*运算符与-&gt;运算符,以及++、–等可能需要重载的运算符重载。</p>
<p><strong>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，</strong></p>
<p>-&gt;、*、++、–等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，<strong>是指针概念的一种提升，提供了比指针更高级的行为</strong>，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</p>
<p>迭代器返回的是迭代器引用而不是对象的值，所以cout只能输出迭代器使用*取值后的值而不能直接输出其自身。</p>
<h2><span id="59-容器内部删除一个元素迭代器的变化">59、容器内部删除一个元素迭代器的变化？</span></h2><ol>
<li>顺序容器<br>erase 迭代器不仅使所指向被删除的迭代器失效,而且使被删元素之后的所有迭代器失效(list 除外),所以不能使用 erase(it++)的方式,但是 erase 的返回值是下一个有效迭代器;It = c.erase(it);</li>
<li>关联容器<br>erase 迭代器只是被删除元素的迭代器失效 ,但是返回值是 void,所以要采用erase(it++)的方式删除迭代器;<br>c.erase(it++)</li>
</ol>
<h2><span id="60-如何在共享内存上使用-stl-标准库">60、如何在共享内存上使用 stl 标准库?</span></h2><p>假设进程 A 在共享内存中放入了数个容器,进程 B 如何找到这些容器呢?一个方法就是进程 A 把容器放在共享内存中的确定地址上(fixed offsets),则进程 B可以从该已知地址上获取容器。另外一个改进点的办法是,**进程 A 先在共享内存某块确定地址上放置一个 map 容器,**然后进程 A 再创建其他容器,然后给其取个名字和地址一并保存到这个 map 容器里。进程 B 知道如何获取该保存了地址映射的map 容器,然后同样再根据名字取得其他容器的地址。</p>
<h2><span id="61-请你来说一下共享内存相关api">61、请你来说一下共享内存相关api</span></h2><p>Linux允许不同进程访问同一个逻辑内存，提供了一组API，头文件在sys/shm.h中。</p>
<p>1）新建共享内存shmget</p>
<p>int shmget(key_t key,size_t size,int shmflg);</p>
<p>key：共享内存键值，可以理解为共享内存的唯一性标记。</p>
<p>size：共享内存大小</p>
<p>shmflag：创建进程和其他进程的读写权限标识。</p>
<p>返回值：相应的共享内存标识符，失败返回-1</p>
<p>2）连接共享内存到当前进程的地址空间shmat</p>
<p>void *shmat(int shm_id,const void *shm_addr,int shmflg);</p>
<p>shm_id：共享内存标识符</p>
<p>shm_addr：指定共享内存连接到当前进程的地址，通常为0，表示由系统来选择。</p>
<p>shmflg：标志位</p>
<p>返回值：指向共享内存第一个字节的指针，失败返回-1</p>
<p>3）当前进程分离共享内存shmdt</p>
<p>int shmdt(const void *shmaddr);</p>
<p>4）控制共享内存shmctl</p>
<p>和信号量的semctl函数类似，控制共享内存</p>
<p>int shmctl(int shm_id,int command,struct shmid_ds *buf);</p>
<p>shm_id：共享内存标识符</p>
<p>command: 有三个值</p>
<p>IPC_STAT:获取共享内存的状态，把共享内存的shmid_ds结构复制到buf中。</p>
<p>IPC_SET:设置共享内存的状态，把buf复制到共享内存的shmid_ds结构。</p>
<p>IPC_RMID:删除共享内存</p>
<p>buf：共享内存管理结构体。</p>
<h2><span id="62-sizeofstring">62、sizeof(string)</span></h2><p><strong>sizeof关键字给出了与变量或类型(包括聚合类型)相关联的存储数量(以字节为单位)。</strong>这个关键字返回一个大小为t的值。</p>
<p>1、sizeof()返回的是string对象所占用的空间，而不是string所存储的字符串的大小。<br>2、string的实现在各库中可能有所不同，但是在同一库中相同的一点是，无论string里放多长的字符串，它的sizeof()都是固定的，字符串所占的空间是从堆中动态分配的，与sizeof()无关。   </p>
<h2><span id="63-函数调用过程栈的变化返回值和参数变量哪个先入栈">63、函数调用过程栈的变化,返回值和参数变量哪个先入栈?</span></h2><p>在x86处理器中，EIP(Instruction Pointer)是指令寄存器，指向处理器下条等待执行的指令地址(代码段内的偏移量)，每次执行完相应汇编指令EIP值就会增加。ESP(Stack Pointer)是堆栈指针寄存器，存放执行函数对应栈帧的栈顶地址(也是系统栈的顶部)，且始终指向栈顶；EBP(Base Pointer)是栈帧基址指针寄存器，存放执行函数对应栈帧的栈底地址，用于C运行库访问栈中的局部变量和参数。</p>
<p>1 、调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中 , 即 : 从<strong>右向左依次把被调函数所需要的参数压入栈 ;</strong><br>2 、调用者函数使用 call 指令调用被调函数 , 并把 call 指令的<strong>下一条指令的地址当成返回地址压入栈中</strong> ( 这个压栈操作隐含在 call 指令中 );<br>3 、在被调函数中 , 被调函数会先保存<strong>调用者函数的栈底地址EBP</strong> (push ebp), 并将调用者调函数的栈顶指针ESP值赋给被调函数的EBP(作为被调函数的栈底) (mov esp,ebp);<br>4 、接着改变ESP值来为函数局部变量预留空间。在被调函数中 , 从 ebp 的位置处开始存放被调函数中的局部变量和临时变量 , 并且这些变量的地址按照定义时的顺序依次减小 , 即 : 这些变量的地址是按照栈的延伸方向排列的 , 先定义的变量先入栈 , 后定义的变量后入栈 ;</p>
<p>调用结束后：将EBP指针值赋给ESP，使ESP再次指向被调函数栈底以释放局部变量；再将已压栈的主调函数帧基指针弹出到EBP，并弹出返回地址到EIP。ESP继续上移越过参数，最终回到函数调用前的状态，即恢复原来主调函数的栈帧。</p>
<p>访问函数的局部变量和访问函数参数的<strong>区别:**局部变量总是通过</strong>将ebp减去偏移量<strong>来访问，函数参数总是通过</strong>将ebp加上偏移量**来访问。对于32位变量而言，第一个局部变量位于ebp-4，第二个位于ebp-8，以此类推，32位局部变量在栈中形成一个逆序数组；第一个函数参数位于ebp+8，第二个位于ebp+12，以此类推，32位函数参数在栈中形成一个正序数组。</p>
<h2><span id="64-模板和实现可不可以不写在一个文件里面为什么">64、模板和实现可不可以不写在一个文件里面?为什么?</span></h2><p>因为在编译时模板并不能生成真正的二进制代码,而是在编译调用<strong>模板类或函数</strong>的 CPP 文件时才会去<strong>找对应的模板声明和实现,**在这种情况下编译器是</strong>不知道实现模板类或函数的 CPP 文件的存在**,所以它只能找到模板类或函数的声明而找不到实现,而<strong>只好创建一个符号寄希望于链接程序找地址</strong>。但<strong>模板类或函数的实现并不能被编译成二进制代码,结果链接程序找不到地址只好报错了。</strong></p>
<h2><span id="65-隐式转换如何消除隐式转换">65、隐式转换,如何消除隐式转换?</span></h2><p>C++的基本类型中并非完全的对立,部分数据类型之间是可以进行隐式转换的。所谓隐式转换,是指不需要用户干预,编译器私下进行的类型转换行为。很多时候用户可能都不知道进行了哪些转换</p>
<p>基本数据类型 **基本数据类型的转换以取值范围的作为转换基础(保证精度不丢失)**。隐式转换发生在从小-&gt;大的转换中。比如从 char 转换为 int。从 int-long。自定义对象 子类对象可以隐式的转换为父类对象。</p>
<p>C++面向对象的多态特性,就是通过父类的类型实现对子类的封装。通过隐式转换,你<strong>可以直接将一个子类的对象使用父类的类型进行返回。</strong></p>
<p>C++中提供了 explicit 关键字,在构造函数声明的时候加上 explicit 关键字,能够禁止隐式转换。</p>
<p><strong>如果构造函数只接受一个参数,则它实际上定义了转换为此类类型的隐式转换机制。</strong><br>可以通过将构造函数声明为 explicit 加以制止隐式类型转换,关键字 e**xplicit 只对一个实参的构造函数有效,**需要多个实参的构造函数不能用于执行隐式转换,所以无需将这些构造函数指定为 explicit。</p>
<h2><span id="66-cout-和-printf-有什么区别">66、cout 和 printf 有什么区别?</span></h2><p>cout&lt;&lt;是一个函数,cout&lt;&lt;后可以跟不同的类型是因为 <strong>cout&lt;&lt;已存在针对各种</strong><br><strong>类型数据的重载,所以会自动识别数据的类型。输出过程会首先将输出字符放入缓冲</strong><br><strong>区,然后输出到屏幕。</strong><br>cout 是有缓冲输出:<br>cout &lt; &lt; “abc “ &lt; &lt;endl;<br>或 cout &lt; &lt; “abc\n “;cout &lt; &lt;flush; 这两个才是一样的.<br>endl 相当于输出回车后,再强迫缓冲输出。<br>flush 立即强迫缓冲输出。<br><strong>printf 是无缓冲输出。有输出时立即输出</strong></p>
<h2><span id="67-c中类成员的访问权限和继承权限问题">67、C++中类成员的访问权限和继承权限问题</span></h2><p>三种访问权限<br>1 public:用该关键字修饰的成员表示公有成员,该成员不仅可以在类内可以被访问,在类外也是可以被访问的,是类对外提供的可访问接口;<br>2 private:用该关键字修饰的成员表示私有成员,该成员仅在类内可以被访问,在类体外是隐藏状态;<br>3 protected:用该关键字修饰的成员表示保护成员,保护成员在类体外同样是隐藏状态,但是对于该类的派生类来说,<strong>相当于公有成员,在派生类中可以被访问。</strong></p>
<p>三种继承方式</p>
<p>1若继承方式是 public,基类成员在派生类中的访问权限保持不变,也就是说,基类中的成员访问权限,在派生类中仍然保持原来的访问权限;</p>
<ul>
<li>派生类中的成员函数：可以直接访问基类的公有和保护成员，但不能访问基类的私有成员。</li>
<li>通过派生类的对象（即用“的”的方式）：只能访问基类的公有成员。</li>
</ul>
<p>2若继承方式是 private,基类所有成员在派生类中的访问权限都会变为私有(private)权限;都变成私有了，也就是说，继承到此为止了，该派生类曾经继承的基类，在该派生类下级的派生<br>类中完全被屏蔽了。因为是私有的，再往下继承，都变得对于下一代的派生类不可见的。<br>3 若继承方式是 protected,基类的<strong>共有成员和保护成员在派生类中的访问权限都会变为保护(protected)权限</strong>,私有成员在派生类中的访问权限仍然是私有(private)权限。</p>
<p><strong>终极原则：私有成员永远只能被本类的成员函数访问，或者是友元访问，除此以外，即使是其派生出的子类，也不能直接访问这些私有成员。</strong></p>
<h2><span id="68-动态联编与静态联编">68、动态联编与静态联编</span></h2><p>在 C++中,联编是指一个<strong>计算机程序的不同部分彼此关联的过程。</strong>按照联编所进行的阶段不同,可以分为静态联编和动态联编;</p>
<p>静态联编是指联编工作在<strong>编译阶段完成的,这种联编过程是在程序运行之前完成的,**又称为早期联编。要实现静态联编,在</strong>编译阶段就必须确定程序中的操作调用(如函数调用)与执行该操作代码间的关系,**确定这种关系称为束定,在编译时的束定称为静态束定。静态联编对函数的选择是基于指向对象的指针或者引用的类型。其优点是效率高,但灵活性差。</p>
<p>动态联编是指联编在程<strong>序运行时动态地进行,根据当时的情况来确定调用哪个同名函数,**实际上是在运行时虚函数的实现。这种联编又称为晚期联编,或动态束定。动态联编对成员函数的选择是基于对象的类型,针对不同的对象类型将做出不同的编译结果。C++中一般情况下的联编是静态联编,但是当涉及到多态性和虚函数时应该使用动态联编。动态联编的优点是灵活性强,但效率低。动态联编规定,只能通过指向基类的指针或基类对象的引用来调用虚函数,其格式为:**指向基类的指针变量名-&gt;虚函数名(实参表)或基类对象的引用名.虚函数名(实参表)</strong></p>
<h2><span id="69-动态链接和静态链接区别">69、动态链接和静态链接区别</span></h2><p>1 <strong>静态连接库</strong>就是把(lib)文件中用到的函数代码直接链接进目标程序 ,程序运行的时<br>候不再需要其它的库文件;<strong>动态链接</strong>就是把调用的函数所**在文件模块(DLL)和调用函数在文件中的位置等信息链接进目标程序,**程序运行的时候再从 DLL 中寻找相应函数代码,因此需要相应 DLL 文件的支持。</p>
<p>2 静态链接库与动态链接库都是共享代码的方式,如果采用静态链接库,则无论你愿不愿意,<strong>lib 中的指令都全部被直接包含在最终生成的 EXE 文件中了</strong>。但是若使用<br>DLL,该 DLL 不必被包含在 最终 EXE 文件中**,EXE 文件执行时可以 “ 动态 ” 地引用和卸载这个与 EXE 独立的 DLL 文件。**静态链接库和动态链接库的另外一个区别<br>在于静态链接库中不能再包含其他的动态链接库或者静态库,而在动态链接库中还可以再包含其他的动态或静态链接库。</p>
<p>3动态库就是在需要调用其中的函数时,根据函数映射表找到该函数然后调入堆栈执行。<strong>如果在当前工程中有多处对 dll 文件中同一个函数的调用,那么执行时,这个函</strong><br><strong>数只会留下一份拷贝。</strong>但是如果<strong>有多处对 lib 文件中同一个函数的调用,那么执行时,该函数将在当前程序的执行空间里留下多份拷贝,而且是一处调用就产生一份拷贝。</strong></p>
<h2><span id="70-为什么拷贝构造函数必须传引用不能传值">70、为什么拷贝构造函数必须传引用不能传值?</span></h2><p>拷贝构造函数的作用就是用来复制对象的,在使用这个对象的实例来初始化这个对象的一个新的实例。</p>
<p>i)值传递:<br>对于内置数据类型的传递时,直接赋值拷贝给形参(注意形参是函数内局部变量);<strong>对于类类型的传递时,需要首先调用该类的拷贝构造函数来初始化形参(局部对象);</strong></p>
<p>ii)引用传递:<br>无论对内置类型还是类类型,传递引用或指针最终都是传递的地址值!而地址总是指针类型(属于简单类型), 显然参数传递时,按简单类型的赋值拷贝,而不会有拷贝构造函数的调用(对于类类型).</p>
<p>拷贝构造函数用来初始化一个非引用类类型对象**,如果用传值的方式进行传参数,那么构造实参需要调用拷贝构造函数,而拷贝构造函数需要传递实参,**所以会一直递归。</p>
<h2><span id="71-深拷贝与浅拷贝">71、深拷贝与浅拷贝?</span></h2><p>浅复制仅仅是指向被<strong>复制的内存地址</strong>,如果原地址中对象被改变了,那么浅复制出来的对象也会相应改变。深复制 —-在计算机中<strong>开辟了一块新的内存地址</strong>用于存放复制的对象。</p>
<h2><span id="72-虚函数可以声明为-inline-吗">72、虚函数可以声明为 inline 吗?</span></h2><p><strong>虚函数用于实现运行时的多态,或者称为晚绑定或动态绑定。而内联函数用于提高效率。</strong>内联函数的原理是,在<strong>编译期间,对调用内联函数的地方的代码替换成函数代码。</strong>内联函数对于程序中需要频繁使用和调用的小函数非常有用。</p>
<p><strong>虚函数要求在运行时进行类型确定,而内敛函数要求在编译期完成相关的函数替换;</strong></p>
<h2><span id="73-类成员初始化方式构造函数的执行顺序-为什么用成员初始化列表会快一些">73、类成员初始化方式?构造函数的执行顺序 ?为什么用成员初始化列表会快一些?</span></h2><p><strong>1 赋值初始化,**通过在函数体内进行赋值初始化;列表初始化,在冒号后使用</strong>初始化列表进行初始化。**<br>这两种方式的主要区别在于:<br>对于在函数体中初始化,是在所有的<strong>数据成员被分配内存空间后才进行的。列表初始化是给数据成员分配内存空间时就进行初始化,**就是说分配一个数据成员<br>只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),**那么分配了内存空间后在进入函数体之前给数据成员赋值</strong>,就是说初始化这个数据成员此时函数体还未执行。</p>
<p>一个派生类构造函数的执行顺序如下:<br>1 虚拟基类的构造函数(多个虚拟基类则按照继承的顺序执行构造函数)。<br>2 基类的构造函数(多个普通基类也按照继承的顺序执行构造函数)。<br>3 <strong>类类型的成员对象</strong>的构造函数(按照初始化顺序)<br>4 <strong>派生类自己的构造函数。</strong></p>
<h2><span id="74-成员列表初始化好在哪里">74、成员列表初始化?好在哪里？</span></h2><p>但是在大多数情况下，两者实际上没有区别。有两个原因使得我们选择第二种语法，它被称为成员初始化列表：<strong>一个原因是必须的，另一个只是出于效率考虑。</strong></p>
<p>让我们先看一下第一个<strong>原因——必要性</strong>。设想你有一个类成员，它本身是一个类或者结构，而且只有一个带一个参数的构造函数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
class CMember &#123;
public:
    CMember(int x) &#123; ... &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为Cmember有一个<strong>显式声明的构造函数</strong>，编译器不产生一个缺省构造函数（不带参数），所以没有一个整数就无法创建Cmember的一个实例。</p>
<p><code>CMember* pm = new CMember;        // Error!!</code><br><code>CMember* pm = new CMember(2);     // OK</code></p>
<p><strong>如果Cmember是另一个类的成员，你怎样初始化它呢？你必须使用成员初始化列表。</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
class CMyClass &#123;
    CMember m_member;
public:
    CMyClass();
&#125;;
&#x2F;&#x2F;必须使用成员初始化列表
CMyClass::CMyClass() : m_member(2)
&#123;
•••
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>没有其它办法将参数传递给m_member，</strong>如果成员是一个常量对象或者引用也是一样。根据C++的规则，<strong>常量对象和引用不能被赋值，它们只能被初始化。</strong></p>
<p>必须使用成员初始化的四种情况<br>1当初始化一个<strong>引用成员</strong>时;<br>2当初始化一个<strong>常量成员</strong>时;<br>3当调用一个<strong>基类的构造函数,**而它拥有一组参数时;<br>4当调用一个</strong>成员类的构造函数**,而它拥有一组参数时;</p>
<p>为什么快一点？分情况讨论</p>
<p>首先把数据成员按类型分类<br>1。<strong>内置数据类型</strong>，复合类型（指针，引用）<br>2。<strong>用户定义类型</strong>（类类型）</p>
<p>对于类型1，在成员初始化列表和构造函数体内进行，在性能和结果上都是一样的<br>对于类型2，结果上相同，但是性能上存在很大的差别</p>
<p>因为类类型的数据成员对象在进入函数体是已经构造完成，也就是说在成员初始化列表处进行构造对象的工作，这是调用一个构造函数，在<strong>进入函数体之后，进行的是 对已经构造好的类对象的赋值，又调用个拷贝赋值操作符才能完成</strong>（如果并未提供，则使用编译器提供的默认按成员赋值行为）</p>
<p> <strong>重复的函数调用是浪费资源的，尤其是当构造函数和赋值操作符分配内存的时候。</strong>在一些大的类里面，你可能拥有<strong>一个构造函数和一个赋值操作符都要调用同一个负 责分配大量内存空间的Init函数。</strong>在这种情况下，你必须使用初始化列表，以避免不要的分配两次内存。</p>
<h2><span id="75-构造函数为什么不能为虚函数析构函数为什么要虚函数">75、构造函数为什么不能为虚函数?析构函数为什么要虚函数?</span></h2><p> <strong>C++中的虚函数的作用主要是实现了多态机制，即父类类别的指针（或者引用）指向其子类的实例，然后通过父类的指针（或者引用）调用实际子类的成员函数。多态机制可以简单地概括为“一个接口，多种方法”。</strong></p>
<p>　　虚函数是通过一张虚函数表（Virtual Table）来实现的，简称为V-Table。在这个表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得极为重要了，它就像一个地图一样，指明了实际所应该调用的函数。</p>
<ol>
<li>从存储空间角度,虚函数相应一个指向 vtable 虚函数表的指针,这大家都知道,但<br> 是这个指向 vtable 的指针事实上是存储在对象的内存空间的。当一个构造函数被调用时,它做的首要的事情之中的一个是初始化它的 VPTR。问题出来了,假设构造<br> 函数是虚的,就须要通过 vtable 来调用,但是对象还没有实例化**,也就是内存空间还**<br> **没有,怎么找 vtable 呢?**所以构造函数不能是虚函数。</li>
<li>从使用角度,虚函数的作用在于通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而<strong>构造函数是在创建对象时自己主动调用的,**不可能通过父类的指针或者引用去调用,因此也就规定构造函数不能是虚函数。因为构造函数本来就是为了明确初始化对象成员才产生的,然而 virtual<br>function 主要是为了再不完全了解细节的情况下也能正确处理对象。另外,**virtual函数是在不同类型的对象产生不同的动作,现在对象还没有产生,如何使用 virtual函数来完成你想完成的动作。</strong></li>
</ol>
<p>直接的讲,C++中基类采用 virtual 虚析构函数是为了防止内存泄漏。具体地说,如果派生类中申请了内存空间,并在其析构函数中对这些内存空间进行释放。<strong>假设基类中采用的是非虚析构函数,当删除基类指针指向的派生类对象时就不会触发动态绑定,因而只会调用基类的析构函数,**而不会调用派生类的析构函数。那么在这种情况下,**派生类中申请的空间就得不到释放从而产生内存泄漏。</strong>所以,为了防止这种情况的发生,C++中基类的析构函数应采用 virtual 虚析构函数。</p>
<h2><span id="76-析构函数的作用如何起作用">76、析构函数的作用,如何起作用?</span></h2><p>1)构造函数只是起初始化值的作用,但实例化一个对象的时候,可以通过实例去传递参数,从主函数传递到其他的函数里面,这样就使其他的函数里面有值了。规则,只要你一实例化对象,系统自动回调用一个构造函数,就是你不写,编译器也自动调用一次。</p>
<p>析构函数与构造函数的作用相反,用于撤销对象的一些特殊任务处理,可以是释放对象分配的内存空间;特点:析构函数与构造函数同名,但该函数前面加~ 。 析构函数没有参数,也没有返回值,而且不能重载,在一个类中只能有一个析构函数。当撤销对象时,编译器也会自动调用析构函数。 每一个类必须有一个析构函数,用户可以自定义析构函数,也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。</p>
<h2><span id="77-构造函数和析构函数可以调用虚函数吗为什么">77、构造函数和析构函数可以调用虚函数吗,为什么</span></h2><p>在 C++中,<strong>提倡不</strong>在构造函数和析构函数中调用虚函数;</p>
<p>构造函数和析构函数调用虚函数时都<strong>不使用动态联编,**如果在构造函数或析构函数中调用虚函数,则</strong>运行的是为构造函数或析构函数自身类型定义的版本;**</p>
<p>因为<strong>父类对象会在子类之前进行构造</strong>,此时子类部分的<strong>数据成员还未初始化</strong>,因此调用子类的虚函数时**不安全的,**故而 C++不会进行动态联编;</p>
<p>析构函数是用来销毁一个对象的,在销毁一个对象时**,先调用子类的析构函数,然后再调用基类的析构函数。<strong>所以在调用基类的析构函数时,**派生类对象的数据成员已经销毁,这个时候再调用子类的虚函数没有任何意义。</strong></p>
<h2><span id="78-构造函数的执行顺序析构函数的执行顺序">78、构造函数的执行顺序?析构函数的执行顺序?</span></h2><ol>
<li> 构造函数顺序<br>1 基类构造函数。如果有多个基类,则构造函数的调用顺序是<strong>某类在类派生表中出现的顺序</strong>,而不是它们在成员初始化表中的顺序。<br>2 <strong>成员类对象构造函数</strong>。如果有多个成员类对象则构造函数的调用顺序是对象**在类中被声明的顺序,**而不是它们出现在成员初始化表中的顺序。<br>3 派生类构造函数。<br>2）析构函数顺序<br>1 调用派生类的析构函数;<br>2 调用成员类对象的析构函数;</li>
</ol>
<p>3调用基类的析构函数。</p>
<h2><span id="79-构造函数析构函数可否抛出异常">79、构造函数析构函数可否抛出异常</span></h2><p>根基情况不可以，<strong>C++只会析构已经完成的对象,**对象只有在其构</strong>造函数执行完毕才算是完全构造妥当。**在构造函数中发生异常,控制权转出构造函数外。因此,在对象 b 的构造函数中发生异常,对象 b 的析构函数不会被调用。因此会造成内存泄漏。用 auto_ptr 对象来取代指针类成员,便对构造函数做了强化,免除了抛出异常时<br>发生资源泄漏的危机,不再需要在析构函数中手动释放资源;</p>
<p><strong>如果异常从析构函数抛出,而且没有在当地进行捕捉,那个析构函数便是执行不全的。</strong>如果析构函数执行不全,就是没有完成他应该执行的每一件事情。</p>
<h2><span id="80-类如何实现只能静态分配和只能动态分配">80、类如何实现只能静态分配和只能动态分配</span></h2><p>建立类的对象有两种方式:<br>1 静态建立,静态建立一个类对象,就是由编译器为对象在栈空间中分配内存;<br>2 动态建立,A *p = new A();动态建立一个类对象,就是使用 new 运算符为对象在堆空间中分配内存。这个过程分为两步,第一步执行 operator new()函数,在堆中搜索一块内存并进行分配;第二步调用类构造函数构造对象;</p>
<p>前者是把 <strong>new、delete 运算符重载为 private 属性</strong>。后者是把构造、析构函数设为 protected 属性。这样类对象不能够访问，但是派生类能够访问，能够正常的继承。<strong>同时创建另外两个create和destory函数类创建对象。</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A  
&#123;  
protected:  
    A()&#123;&#125;  
    ~A()&#123;&#125;  
public:  
    static A* create()  
    &#123;  
        return new A();  
    &#125;  
    void destory()  
    &#123;  
        delete this;  
    &#125;  
&#125;;  
class A  
&#123;  
private:  
    void* operator new(size_t t)&#123;&#125;     &#x2F;&#x2F; 注意函数的第一个参数和返回值都是固定的  
    void operator delete(void* ptr)&#123;&#125; &#x2F;&#x2F; 重载了new就需要重载delete  
public:  
    A()&#123;&#125;  
    ~A()&#123;&#125;  
&#125;;  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="81-如果想将某个类用作基类为什么该类必须定义而非声明">81、如果想将某个类用作基类,为什么该类必须定义而非声明?</span></h2><p>派生类中**包含并且可以使用它从基类继承而来的成员,**为了使用这些成员,派生类必须知道他们是什么。</p>
<h2><span id="82-什么是组合">82、什么是组合？</span></h2><p><strong>一个类里面的数据成员是另一个类的对象,**即内嵌其他类的对象作为自己的成员;创建组合类的对象:首先创建各个内嵌对象,难点在于构造函数的设计。</strong>创建对象时既要对基本类型的成员进行初始化,又要对内嵌对象进行初始化。**</p>
<p>创建组合类对象,构造函数的执行顺序:先调用内嵌对象的构造函数,然后<strong>按照内嵌对象成员在组合类中的定义顺序,**与</strong>组合类构造函数**的初始化列表顺序无关。然后执行组合类构造函数的函数体,析构函数调用顺序相反。</p>
<h2><span id="83-抽象基类为什么不能创建对象">83、抽象基类为什么不能创建对象？</span></h2><p>1)抽象类的定义:<br>称带有<strong>纯虚函数的类为抽象类。</strong></p>
<p><strong>纯虚函数可以让类先具有一个操作名称,而没有操作内容,让派生类在继承时再去具体地给出定义。</strong>凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象,只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数,否则,派生类也变成了抽象类,不<strong>能实例化对象。</strong></p>
<p>(2)抽象类的作用:<br>抽象类的主要作用是<strong>将有关的操作作为结果接口组织在一个继承层次结构中,**由它来为派生类提供一个公共的根,**派生类将具体实现在其基类中作为接口的操作</strong>。所以<br>派生类实际上**刻画了一组子类的操作接口的通用语义,**这些语义也传给子类,子类可以具体实现这些语义,也可以再将这些语义传给自己的子类。</p>
<p>(3)使用抽象类时注意:<br>抽象类只能作为基类来使用,其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数,而只是继承基类的纯虚函数,则这个派生类仍然还是一个抽象类，<strong>如果派生类中给出了基类纯虚函数的实现,则该派生类就不再是抽象类了,它是一个可以建立对象的具体的类。</strong></p>
<p>纯虚函数引入原因？</p>
<p>1、为了方便使用多态特性,我们常常需要在基类中定义虚拟函数。</p>
<p>2、在很多情况下,基类本身生成对象是不合情理的。例如,动物作为一个基类可以派生出老虎、孔 雀等子类,但动物本身生成对象明显不合常理。</p>
<p>为了解决上述问题,引入了纯虚函数的概念,将函数定义为纯虚函数(方法:<br>virtual ReturnType Function()= 0;)。若要使派生类为非抽象类,则编译器要求<strong>在派生类中,必须对纯虚函数予以重载以实现多态性。</strong>同时含有纯虚函数的类称为抽象类,它不能生成对象。这样就很好地解决了上述两个问题。</p>
<h2><span id="84-类什么时候会析构">84、类什么时候会析构?</span></h2><ol>
<li>对象生命周期结束,被销毁时;</li>
<li>delete 指向对象的指针时,或 delete 指向对象的基类类型指针,而其基类虚构函数是虚函数时;</li>
<li>对象 i 是对象 o 的成员,o 的析构函数被调用时,对象 i 的析构函数也被调用。</li>
</ol>
<h2><span id="85-为什么友元函数必须在类内部声明">85、为什么友元函数必须在类内部声明?</span></h2><p>因为<strong>编译器必须能够读取这个结构的声明以理解这个数据类型的大、行为等方面的所有规则。</strong>有一条规则在任何关系中都很重要,那就是<strong>谁可以访问我的私有部分。</strong></p>
<h2><span id="86-继承机制中对象之间如何转换指针和引用之间如何转换">86、继承机制中对象之间如何转换?指针和引用之间如何转换?</span></h2><p><strong>向上类型转换</strong><br><strong>将派生类指针或引用转换为基类的指针或引用</strong>被称为向上类型转换,向上类型转换会自动进行,而且向上类型转换是<strong>安全的。</strong><br><strong>向下类型转换</strong><br>将基类指针或引用转换为派生类指针或引用被称为向下类型转换,向下类型转换不会自动进行,因为一个基类对应几个派生类,所以向下类型转换时不知道对应哪个派 生 类 , 所 以 在 向 下 类 型 转 换 时 必 须 <strong>加 动 态 类 型 识 别 技 术 。</strong> RTTI 技 术 , 用dynamic_cast 进行向下类型转换。</p>
<h2><span id="87-组合和继承的优缺点">87、组合和继承的优缺点？</span></h2><p>一:继承<br>**继承是 Is a 的关系,**比如说 Student 继承 Person,则说明 Student is a Person。<br>继承的优点是子类可以重写父类的方法来方便地实现对父类的扩展。</p>
<p>继承的缺点有以下几点:</p>
<p>1:父类的内部细节对子类是可见的。</p>
<p>2:子类从父类继承的方法在编译时就确定下来了**,所以无法在运行期间改变从父类继承的方法的行为。**<br>3:如果对父类的方法做了修改的话(比如增加了一个参数),则子类的方法必须做出相应的修改。所以说子类与父类是一种<strong>高耦合,违背了面向对象思想。</strong></p>
<p>二:组合</p>
<p>组合也就是设计类的时候把要组<strong>合的类的对象加入到该类中作为自己的成员变量。</strong></p>
<p>组合的优点:<br>1:当前对象只能通过所包含的那个对象去调用其方法,所以所<strong>包含的对象的内部细节对当前对象时不可见的。</strong><br>2:当前对象与<strong>包含的对象是一个低耦合关系</strong>,如果修改包含对象的类中代码不需要修改当前对象类的代码。<br>3:当前对象可以在运行时动态的绑定所包含的对象。可以通过 set 方法给所包含对象赋值。</p>
<p>组合的<strong>缺点</strong>:1:容易产生过多的对象。2:为了能组合多个对象,必须仔细对接口进行定义。</p>
<h2><span id="88-函数指针">88、函数指针?</span></h2><p>什么是函数指针?指向函数类型的指针，函数类型是由其返回的数据类型和其参数列表共同决定的。一个具体的函数名就是一个函数指针，它指向函数的代码。一个函数地址是该函数的进入点，也就是调用函数的地址。函数调用根据函数名，也可以通过指向函数的指针来调用。我们希望在同一个函数中通过使用<strong>相同的形</strong><br><strong>参在不同的时间使用产生不同的效果。</strong></p>
<p>函数指针的声明方法</p>
<p><code>int（*pf）(const int &amp;,const int &amp;)</code> 上面的pf就是一个函数指针，返回类型为int，并带有两个const int&amp;参数的函数。注意*pf两边的括号是必需的。</p>
<h2><span id="89-指针和引用的区别">89、指针和引用的区别？</span></h2><p>1.指针有自己的一块空间，而引用只是一个别名；<br>2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；<br>3.指针可以被初始化为NULL，而引用必须被<strong>初始化</strong>且必须是一个已有对象 的引用；<br>4.作为参数传递时，<strong>指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</strong><br>5.可以有const指针，但是没有const引用；<br>6.<strong>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</strong><br>7.指针可以有多级指针（**p），而引用至于一级；<br>8.指针和引用使用++运算符的意义不一样；</p>
<h2><span id="90-内存对其原理为什么要内存对其">90、内存对其原理？为什么要内存对其？</span></h2><p>1 、 分配内存的顺序是按照声明的顺序。<br>2 、 每个变量<strong>相对于起始位置的偏移量</strong>必须是该变量类型大小的整数倍,不是整数倍空出内存,直到偏移量是整数倍为止。<br>3 、 最后整个结构体的大小必须是里面变量类型最<strong>大值的整数倍。</strong></p>
<p>为什么？</p>
<p>1、平台原因(移植原因)</p>
<ol>
<li>不是所有的硬件平台都能访问任意地址上的任意数据的;</li>
<li>某些硬件平台只能在**某些地址处取某些特定类型的数据,**否则抛出硬件异<br>2、性能原因:</li>
<li>数据结构(尤其是栈)应该尽可能地在自然边界上对齐。</li>
<li>原因在于,<strong>为了访问未对齐的内存,处理器需要作两次内存访问;而对齐的内存访问仅需要一次访问。</strong></li>
</ol>
<h2><span id="91-printf-实现原理">91、printf 实现原理?</span></h2><p>printf 的第一个被找到的参数就是那个字符指针,就是被双引号括起来的那一部分,**函数通过判断字符串里控制参数的个数来判断参数个数及数据类型,**通过这些就可算出数据需要的堆栈指针的偏移量了。</p>
<h2><span id="92-内部连接和外部连接">92、内部连接和外部连接？</span></h2><p><strong>编译单元</strong>：一个cpp文件经过预处理阶段，形成一个包含所有<strong>必要信息的单个源文件。</strong>这个编译单元会被编译成为一个与cpp文件名同名的目标文件(.o或是.obj)。连接程序把不同编译单元中产生的符号联系起来，构成一个可执行程序。</p>
<p>内部连接：</p>
<p>　　如果一个名称对于它的编译单元来说是透明的，并且在连接时<strong>不会与其它编译单元中的同样的名称相冲突，</strong>那么这个名称有内部连接</p>
<p>以下情况为内部连接:</p>
<p>　　a)所有的声明</p>
<p>　　b)名字空间(包括全局名字空间)中的<strong>静态自由函数、静态友元函数、静态变量的定义。</strong>如: static int x;</p>
<p>　　c)enum定义</p>
<p>　　d)inline函数定义(包括自由函数和非自由函数) 。内部连接的一个好处是这个名字可以放在一个头文件中而不用担心连接时发生冲突。</p>
<p>　　e)类的定义, 类中函数的定义也okk</p>
<p>　　f)名字空间中const常量定义</p>
<p>　　g)union的定义</p>
<p>外部连接:</p>
<p>　　在一个多文件程序中，如果<strong>一个名称在连接时可以和其它编译单元交互</strong>，那么这个名称就有外部连接。</p>
<p> 以下情况有外部连接: </p>
<p>　　a)<strong>类非inline函数总有外部连接。</strong>包括<strong>类成员函数和类静态成员函数</strong> </p>
<p>　　b)<strong>类静态成员变量总有外部连接。</strong> </p>
<p>　　c)名字空间(包括全局名字空间)中<strong>非静态自由函数、非静态友元函数及非静态变量</strong></p>
<p>​    因为头文件包含在多个源文件中，所以不应该含有变量或函数的定义。</p>
<p>​    <strong>对于头文件不应该含有定义这一规则，有三个例外</strong>。头文件可以定义类、值在编译时就已经知道的const对象和inline函数。这些实体可在多个源文件中定义，只要每个源文件中的定义是相同的。</p>
<p>​    在头文件中定义这些实体，是因为编译器需要它们的定义（不只是声明）来产生代码。</p>
<h2><span id="92-c中的名字空间">92、C++中的名字空间？</span></h2><p>名字空间（namespace）是由标准C++引入的，是一种新的作用域级别。原来C++标识符的作用域分为三级：代码块（{…}和函数体）、类域和全局作用域。<strong>如今，在类作用域和全局作用域之间，C++标准又添加了名字空间域这一个作用域级别。</strong>用来处理程序中常见的同名冲突。</p>
<p>访问一个具体的标识符的时候，可以使用如下形式：space_name::identifier。即用作用域指示符“::”将名字空间的名称和该空间下的标识符连接起来，这要，即使使用同名的标识符，<strong>由于它们处于不同的名字空间，也不会发生冲突。</strong></p>
<h3><span id="名字空间的作用">名字空间的作用？</span></h3><p>名字空间的作用主要是为了解决日益严重的名称冲突问题。随着可重用代码的增多，各种不同的代码体系中的标识符之间同名的情况就会显著增多。解决的办法就是将不同的代码库放到不同的名字空间中。</p>
<p>访问一个具体的标识符的时候，可以使用如下形式：space_name::identifier。即用<strong>作用域指示符</strong>“::”<strong>将名字空间的名称和该空间下的标识符连接起来</strong>，这要，即使使用同名的标识符，由于它们处于不同的名字空间，也不会发生冲突。有两种形式的命名空间——有名的和无名的。 </p>
<h3><span id="名字空间的注意要点">名字空间的注意要点？</span></h3><p>（1）一个名字空间可以在<strong>多个头文件或源文件中实现，成为分段定义</strong>。如果想在当前文件访问定义在另一个文件中的同名名字空间内的成员变量，需要在当前文件的名字空间内部进行申明。extern</p>
<p>（2）名字空间内部可以定义类型、函数、变量等内容，但<strong>名字空间不能定义在类和函数的内部</strong>。</p>
<p>（3）在一个名字空间中可以自由地访问另一个名字空间的内容，因为名字空间并没有保护级别的限制。</p>
<p>（4）虽然经常可以见到using namespace std;这样的用法，我们也可以用同样的方法将名字空间中的<strong>所有标识符一次性“引入”到当前的名字空间中来，但这并不是一个值得推荐的用法。</strong>因为这样做的相当于取消了名字空间的定义，使<strong>发生名称冲突的机会增多</strong>。所以，用using单独引入需要的内容，这样会更有针对性。例如，要使用标准输入对象，只需用using std::cin;就可以了。</p>
<p>（5）不能在名字空间的定义中声明另一个嵌套的子命名空间，<strong>只能在命名空间中定义子命名空间。</strong></p>
<p>（6）名字空间的成员，可以在命名空间的内部定义，也可以在名字空间的外部定义，但是要在名字空间进行声明。</p>
<p>（7）名字空间在进行分段定义时，不能<strong>定义同名的变量，</strong>否则连接出现重定义错误。因为名字空间不同于类，具有<strong>外部连接的特性</strong>。由于外部连接特性，请<strong>不要将名字空间定义在头文件</strong>，因为当被不同的源文件包含时，会出现重定义的错误。</p>
<p>（8）为了避免命名空间的名字与其他的命名空间同名，可以用较长的标识符作为命名空间的名字。但是书写较长的命名空间名时，有些冗余，因此，我们可以在特定的上下文环境中给命名空间起一个相对简单的别名。 </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">namespace MyNewlyCreatedSpace&#123;
    void show()&#123;
        std::cout&lt;&lt;&quot;a function within a namespace&quot;&lt;&lt;std::endl;
    &#125;
&#125;
 
int main(int argc,char* argv[])
&#123;
    namespace sp&#x3D;MyNewlyCreatedSpace;
    sp::show();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="匿名名字空间">匿名名字空间</span></h3><p>匿名名字空间提供了类似在全局函数前加 <strong>static 修饰带来的限制作用域的功能</strong>。它的这种特性可以被用在<strong>struct和class上</strong>， 而普通的static却不能。比如，<strong>在两个源文件中定义了相同的全局变量（或函数）</strong>，就会发生重定义的错误。如果将它们声明为全局静态变量（函数）就可以避免重定义错误。在C++中，<strong>除了可以使用static关键字避免全局变量（函数）的重定义错误，还可以通过匿名名字空间的方式实现。</strong></p>
<p><strong>与static的不同</strong>:</p>
<p>包含在匿名名字空间中的全局变量（函数）<strong>具有外部连接特性</strong>，而用<strong>static修饰的全局变量</strong>具有内部连接特性，<strong>不能用来实例化模板的非类型参数。</strong>而类模板的非类型参数要求是编译时常量表达式，或者是<strong>指针类型的参数要求指针指向的对象具有外部连接性。</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
 
template &lt;char*p&gt; class Example&#123;
public:
    void display()&#123;
        cout&lt;&lt;*p&lt;&lt;endl;
    &#125;
&#125;;
 
static  char c&#x3D;&#39;a&#39;;
int main(int argc,char* argv[])
&#123;
 
    Example&lt;&amp;c&gt; a; &#x2F;&#x2F;编译出错
    a.display();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h1><span id="操作系统">操作系统</span></h1><h2><span id="1-请你说一下源码到可执行文件的过程">1 请你说一下源码到可执行文件的过程</span></h2><p>1）预编译</p>
<p>主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下</p>
<p>1、删除所有的#define，展开所有的宏定义。</p>
<p>2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</p>
<p>3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。</p>
<p>4、删除所有的注释，“//”和“/**/”。</p>
<p>5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。</p>
<p>6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。</p>
<p>2）编译</p>
<p>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p>
<p>1、词法分析：将源代码程序输入到扫描机中，将其中的<strong>字符序列分割成一系列的记号。</strong></p>
<p>2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以<strong>表达式为节点的树。</strong> 在语法分析的同时，就把运算法优先级确定了下来，如果出现表达式不合法，各种括号不匹配,表达式中缺少操作，编译器报错。</p>
<p>3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对<strong>表达式是否有意义</strong>进行判断，其分析的语义是静态语义——在编译期能分清的语义，相对应的动态语义是在运行期才能确定的语义。例如，将一个int型赋值给int*型，语义分析程序就发现类型不匹配，编译器会报错。 </p>
<p>4、优化：源代码级别的一个优化过程。</p>
<p>5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。</p>
<p>6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</p>
<p>3）汇编</p>
<p><strong>将汇编代码转变成机器可以执行的指令(机器码文件)。</strong> 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。</p>
<p>4）链接</p>
<p>链接的过程：<strong>地址和空间的分配、符号决议(也叫“符号绑定”，倾向于动态链接)和重定位 。</strong>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p>
<p>1、静态链接：</p>
<p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，<strong>链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</strong></p>
<p>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</p>
<p>更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p>
<p>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p>
<p>2、动态链接：</p>
<p><strong>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件动态库就是在需要调用其中的函数时,根据函数映射表找到该函数然后调入堆栈执行。</strong></p>
<p>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；</p>
<p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p>
<p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p>
<h2><span id="2-常见io模型5种异步io应用场景有什么缺点">2 常见I/O模型？5种？异步IO应用场景？有什么缺点？</span></h2><p>几个概念同步，异步，阻塞，非阻塞</p>
<p>首先来解释同步和异步的概念，这两个概念与<strong>消息的通知机制</strong>有关。也就是同步与异步主要是从消息通知机制角度来说的。</p>
<p><strong>同步异步概念</strong></p>
<p><code>所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列</code>。要么成功都成功，失败都失败，两个任务的状态可以保持一致。</p>
<p><code>所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了</code>。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，<code>所以它是不可靠的任务序列</code>。</p>
<p>1）同步</p>
<p>就是在发出一个功能调用时，<strong>没有得到结果之前，该调用就不返回。</strong>同步 IO 指的是,必须等待 IO 操作完成后,控制权才返回给用户进程 。也就是必须一件一件事做 , 等前一件做完了才能做下一件事。就是我调用一个功能,该功能没有结束前,我死等结果。</p>
<p>2）异步</p>
<p>当一个<strong>异步过程调用发出后</strong>，调用者 不能立刻得到结果。实际处理这个调用的部件在完成后，通过<strong>状态、通知和调用</strong>来通知调用者。我调用一个功能，不知道该功能的结果，该功能有结果后通知我（回调通知）</p>
<p><strong>阻塞与非阻塞</strong></p>
<p>阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）<strong>等待消息通知时的状态</strong>角度来说的。</p>
<p>3）阻塞</p>
<p>阻塞调用是指<strong>调用结果返回之前，当前线程会被挂起</strong>（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在<strong>得到结果</strong>之前才会返回。对于同步调用来说，很多时候当<strong>前进程还是激活</strong>的，只是<strong>逻辑上</strong>当前函数<strong>没有返回</strong>而已。就是调用函数，函数在没有接受完数据或者没有得到结果之前我不会返回。</p>
<p>4）非阻塞</p>
<p>指在<strong>不能立刻得到结果</strong>之前，该函数<strong>不会阻塞当前线程</strong>，而是会立刻返回。</p>
<p><strong>5种常见IO模型</strong></p>
<p>1 阻塞IO</p>
<p>应用程序调用一个 IO 函数,导致<strong>应用程序阻塞,等待数据准备好</strong> 。 如果数据没有准备好,一直等待 … .数据准备好了,从内核拷贝到用户空间,IO 函数返回成功指示。</p>
<p>2 非阻塞IO</p>
<p>我们把一个 SOCKET 接口设置为非阻塞就是告诉内核,当所请求的 I/O 操作无法完成时,不要将进程睡眠,而是<strong>返回一个错误</strong>。这样我们的 I/O 操作函数将不断的测试<br>数据是否已经准备好,如果没有准备好,继续测试,直到数据准备好为止。在这个不断测试的过程中,会大量的占用 CPU 的时间。</p>
<p>3 IO复用</p>
<p>I/O 复用模型会用到 select、poll、epoll 函数,这几个函数也会使进程阻塞,但是和阻塞 I/O 所不同的的,这三个函数可以同时阻塞多个 I/O 操作。而且可以同时对多个读操作,多个写操作的 I/O 函数进行检测,直到有数据可读或可写时,才真正调用I/O 操作函数。</p>
<p>4 信号驱动IO</p>
<p>开启套解字的信号驱动式IO功能，通过sigaction系统调用安装一个信号处理函数。该系统调用<strong>让内核在描述符就绪时发送SIGIO信号通知我们</strong>。在<strong>信号处理函数</strong>中<strong>调用IO操作函数处理数据。</strong></p>
<p>5 异步IO模型</p>
<p><strong>当一个异步过程调用发出后,调用者不能立刻得到结果。实</strong>际处理这个调用的部件在完成后,通过<strong>状态、通知和回调</strong>来通知调用者的输入输出操作。与信号驱动IO的主要区别，信号驱动IO主要是通知我们何时开启一个IO操作，而<strong>异步IO模型是由内核通知我们IO操作何时完成。</strong></p>
<h2><span id="3-io-复用的原理零拷贝三个函数epoll-的-lt-和-et-模式的理解">3 IO 复用的原理?零拷贝?三个函数?epoll 的 LT 和 ET 模式的理解。</span></h2><p>select 、 poll 和 epoll 都是多路 IO 复用的机制 。 <strong>多路 IO 复用就通过一种机制,可以监视多个描述符, 一旦某个描述符就绪( 一般是读就绪或者写就绪),能够通知程序进行相应的读写操作 。</strong> 但 select 、 poll 和 epoll 本质上都是同步 IO ,因为它们都需要在读写事件就绪后自己负责进行读写,即是阻塞的,而异步 IO 则无须自己负 责进行读写 ,异步 I/O 的实现会负责把数据从内核拷贝到用户 空 间 。</p>
<p><strong>Select</strong><br>select 的缺点:<br>1 <strong>单个进程能够监视的文件描述符的数量存在最大限制</strong> ,通常是 1024。由于select 采用轮询的方式扫描文件描述符,文件描述符数量越多,性能越差;</p>
<p>2 <strong>内核/用户空间内存拷贝问题</strong>,select 需要大量句柄数据结构,产生巨大开销;</p>
<p>3 **Select 返回的是含有整个句柄的数组,**应用程序需要遍历整个数组才能发现哪些句柄发生事件;</p>
<p>4 select ，所监控的描述符集在返回之后会发生边哈，所以在下次进入select之前都需要重新初始化需要监控的描述符集fd_set中的每一个比特位比较费时。</p>
<p>5 Select 的触发方式是水平触发,应用程序如果没有完成对一个已经就绪的文件描述符进行 IO 操作,那么每次 select 调用还会将这些文件描述符通知进程。</p>
<p>( 2) select()的优点如下所述 。<br>1 ) select()的可移植性更好,在某些 UNIX 系统上不支持 poll () 。<br>2) select()对于超时值提供了更好的精度,而 poll() 是精度较差 。</p>
<p> <strong>Poll</strong><br>与 select 相比,poll 使用链表保存文件描述符,一你才<strong>没有了监视文件数量的限制,poll函数将监控的输入时间和输出时间分开，允许被监控文件数组被复用不需要重新初始化</strong><br>但其他三个缺点依然存在</p>
<p><strong>Epoll</strong></p>
<p>1 支持一进程打开大数目的 socket 描述符( FD ) 。</p>
<p>se l ect()均不能忍受的是一个进程所打开的 FD 是有一定限制的,由 FD_SETSIZE 的 默认值是 1024/2048 。 对于那些需要支持上万连接数目的 IM 服务器来说显然太少了 。 这时候可以选择修改这个宏然后重新编译内核 。 不过 epoll 则没有这个限制,它所支持 的 FD 上限是最大可以打开文件的数目,这个数字一般远大于 2048 。 举个例子,在 lGB 内存的 空 间中这个数字一般是 10 万左右,具体数目可以使用 cat/proc/sys/fs/file-max 查看, 一般来说这个数目和系统内存关系很大 。</p>
<p>2 IO 效率不随 FD 数目增加而线性下降 。</p>
<p>传统的 select/poll 另 一个致命弱点就是当你拥 有一个很大的 socket 集合,不过由于网络延迟,任一 时间只有部分的 socket 是 “活跃” 的,<strong>但是 se lect/poll 每次调用都会线性扫描全部的集合</strong>,导致效率呈现线性下降 。 但是 epoll 不存在这个问题 ,它 只会对<strong>“活跃”的 socket</strong>进行操作，这是因为在内核中实现 epoll 是根据每个fd上面的 callback 函数实现的 。 那么,<strong>只有“活跃”的 socket 才会主动去调用 callback 函数</strong>,其他 idle 状态 socket 则不会,在这点上, epoll 实现了 一个“伪” AIO ,因为这时候推动力由 Linux 内 核提供 。</p>
<p>3 使用 mmap 加速内核与用户 空 间的消息传递。</p>
<p>这点实际上涉及 epoll 的具体实现 。 无论是 select 、 poll 还是 epoll 都需要 内核把“消息<br>通知给用户空间,如何避免不必要的内存拷贝就显得尤为重要 。 在这点上, e<strong>poll 是通过内核</strong><br><strong>与用户空间 mmap 处于同一块内存实现的 。</strong></p>
<h2><span id="4-请你说一下进程与线程的概念">4 请你说一下<strong>进程与线程的概念</strong></span></h2><p>进程是操作系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</p>
<p>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</p>
<h2><span id="5-以及为什么要有进程线程其中有什么区别">5 以及为什么要有进程线程，其中有什么区别</span></h2><p><strong>进程</strong>是指在系统中正在运行的一个应用程序，程序一旦运行起来就是进程。进程是系统<strong>资源分配的最小单位</strong>，且每个进程拥有独立的地址空间，实现了操作系统的并发；<strong>线程</strong>是进程的子任务，<strong>是CPU最小执行和调度的基本单位</strong>，实现了进程内部的并发；</p>
<p>线程是进程的一个实体,<strong>是进程的一条执行路径</strong>;比进程更小的独立运行的基本单位,线程也被称为轻量级进程,一个程序至少有一个进程,一个进程至少有一个线程;</p>
<p>每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</p>
<p>为什么要有线程？</p>
<p>进程在同一时间只能干一件事</p>
<p>进程在执行的过程中如果阻塞<strong>，整个进程就会挂起，</strong>即使进程中有些工作不依赖于等待的资源，仍然不会执行。单进程各个函数之间不是并发执行，<strong>影响资源使用效率</strong>，利用多进程解决另外<strong>维护进程系统开销大</strong>：创建进程时，分配资源，建立PCB，进程撤销时，回收资源，撤销PCB;进程切换，保存当前进程的状态信息。<strong>从通信机制上来讲，线程间方便的通信机制。</strong>对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。<strong>改善程序结构。</strong>一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会<strong>利于理解和修改。</strong></p>
<p>区别：</p>
<p>1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。每个独立的进程有一个程序的入口、程序出口。但是<strong>线程不能独立执行</strong>,必须依存在应用程序中,由应用程序提供多个线程执行控制。</p>
<p>2、进程是资源分配的最小单位，线程是CPU调度的最小单位；</p>
<p>3、进程在执行过程中拥有独立的地址空间，而<strong>多个线程共享进程的资源。</strong>（同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</p>
<p>4、系统开销：由于在<strong>创建或撤消进程时</strong>，系统都要为之分配或回收资源，如内存空间、I／o设备，PCB程序控制块等。因此，<strong>操作系统所付出的开销将显著地大于在创建或撤消线程时的开销</strong>。类似地，在进行进程<strong>切换时</strong>，涉及到整个当前<strong>进程CPU环境</strong>的保存以及新被调度运行的进程的CPU环境的设置。而<strong>线程切换只须保存和设置少量寄存器的内容</strong>，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</p>
<p>5、进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉</p>
<p>6、通信：由于同一进程中的<strong>多个线程具有相同的地址空间，</strong>致使它们之间的同步和通信的实现，也变得比较容易。线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。</p>
<h2><span id="6-进程通信方式">6 进程通信方式</span></h2><p>1 、信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。软件中断通知事件处理</p>
<p>接收到信号</p>
<p>catch:指定信号处理函数被调用</p>
<p>ignore: 依靠操作系统的默认操作</p>
<p>Mask:闭塞信号因此不会传送</p>
<p>缺点，不能交换任何数据</p>
<p>2、管道</p>
<p><strong>管道 - 内核中一块缓存</strong>，buffer容量是有限的，同时管道是父进程帮忙创建的</p>
<p>shell</p>
<ul>
<li>创建管道</li>
<li>为ls创建一个进程，设置stdout为管道写端口</li>
<li>为more创建一个进程，设置stdin为管道读端口</li>
</ul>
<p>我们来看一条 Linux 的语句</p>
<pre class="line-numbers language-none"><code class="language-none">netstat -tulnp | grep 8080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>学过 Linux 命名的估计都懂这条语句的含义，其中”|“是<strong>管道</strong>的意思，它的作用就是把前一条命令的输出作为后一条命令的输入。在这里就是把 netstat -tulnp 的输出结果作为 grep 8080 这条命令的输入。如果两个进程要进行通信的话，就可以用这种<strong>管道</strong>来进行通信了，并且我们可以知道这条<strong>竖线</strong>是没有名字的，所以我们把这种通信方式称之为<strong>匿名管道</strong>。</p>
<p>并且这种通信方式是<strong>单向</strong>的，只能把第一个命令的输出作为第二个命令的输入，如果进程之间想要互相通信的话，那么需要创建两个管道。</p>
<p> 居然有匿名管道，那也意味着有<strong>命名</strong>管道，下面我们来创建一个命名管道。它以一种特殊设备文件形式存在于文件系统中。</p>
<pre class="line-numbers language-none"><code class="language-none">mkfifo  test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这条命令创建了一个名字为 test 的命名管道。</p>
<p>接下来我们用一个进程向这个管道里面写数据，然后有另外一个进程把里面的数据读出来。</p>
<pre class="line-numbers language-none"><code class="language-none">echo &quot;this is a pipe&quot; &gt; test   &#x2F;&#x2F; 写数据<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个时候管道的内容没有被读出的话，那么这个命令就会一直停在这里，只有当另外一个进程把 test 里面的内容读出来的时候这条命令才会结束。接下来我们用另外一个进程来读取</p>
<pre class="line-numbers language-none"><code class="language-none">cat &lt; test  &#x2F;&#x2F; 读数据<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们可以看到，test 里面的数据被读取出来了。上一条命令也执行结束了。</p>
<p>从上面的例子可以看出，管道的通知机制类似于<strong>缓存</strong>，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿，并且是管道是<strong>单向传输的。</strong></p>
<p>这种通信方式有什么缺点呢？显然，这种通信方式<strong>效率低下</strong>，你看，a 进程给 b 进程传输数据，然后就a进程阻塞住了，只能等待 b 进程取了数据之后 a 进程才能返回。</p>
<p><strong>所以管道不适合频繁通信的进程。</strong>当然，他也有它的优点，例如比较简单，<strong>能够保证我们的数据已经真的被其他进程拿走了。</strong>我们平时用 Linux 的时候，也算是经常用。</p>
<p>3、消息队列</p>
<p>那我们能不能把进程的数据放在某个内存之后就马上让进程返回呢？<strong>无需等待其他进程</strong>来取就返回呢？</p>
<p>答是可以的，我们可以用<strong>消息队列</strong>的通信模式来解决这个问题，例如 a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的<br>消息队列里取出来。同理，b 进程要个 a 进程发送消息也是一样。这种通信方式也类似于<strong>缓存</strong>吧。</p>
<p>特点：</p>
<p>1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p>
<p>2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p>
<p>3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p>
<p>这种通信方式有缺点吗？答是有的，如果 a 进程发送的数据占的内存比较大，并且两个进程之间的通信特别频繁的话，消息队列模型就不大适合了。因为 a 发送的数据很大的话，意味<strong>发送消息（拷贝）</strong>这个过程需要花很多时间来读内存。</p>
<p>4、共享内存</p>
<p><strong>共享内存</strong>这个通信方式就可以很好着解决<strong>拷贝</strong>所消耗的时间了。</p>
<p>这个可能有人会问了，每个进程不是有自己的独立内存吗？两个进程怎么就可以共享一块内存了？</p>
<p>我们都知道，系统加载一个进程的时候，分配给进程的内存并不是<strong>实际物理内存</strong>，而是<strong>虚拟内存空间</strong>。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了<strong>内存共享</strong>机制了。</p>
<p>1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取</p>
<p>2)因为多个进程可以同时操作，所以需要进行同步</p>
<p>3)<strong>信号量+共享内存</strong>通常结合在一起使用，信号量用来同步对共享内存的访问</p>
<p>5、Socket</p>
<p>上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？</p>
<p>答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。</p>
<h2><span id="7-什么是信号量内部怎么实现的">7、什么是信号量？内部怎么实现的？</span></h2><p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p>
<p>特点：</p>
<p>1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</p>
<p>2)信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。抽象数据类型，信号量</p>
<ul>
<li>一个整形（semaphore棋语），两个原子操作，进入临界区之前执行P操作，离开临界区会执行V操作。</li>
<li><code>P():sem减1,如果sem &lt; 0,等待,否则 继续</code></li>
<li><code>V():sem加1,如果sem &lt;=0，就代表有进程在等待，唤醒一个挂在该信号量上等待的P，FIFO原则</code></li>
<li>信号量是一个<strong>整数</strong>，<strong>被保护</strong>，只有P,V操作能改变值</li>
</ul>
<p>3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">class Semaphore<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> sem<span class="token punctuation">;</span>
    <span class="token comment">// 等待队列，sem小于零，线程被存入等待队列中</span>
    WaitQueue q<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
Semaphore<span class="token operator">::</span><span class="token function">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    sem<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>sem <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        Add this thread t to q
        <span class="token comment">//线程放入等待队列中</span>
        <span class="token function">block</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
Semophore<span class="token operator">::</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    sem<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>sem <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        Remove a thead t from q
        <span class="token comment">// 唤醒一个线程</span>
        <span class="token function">wakeup</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其系统调用为：</p>
<p>sem_wait（sem_t *sem）：以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。</p>
<p>sem_post（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。</p>
<h2><span id="8-线程通信的方式">8、线程通信的方式？</span></h2><p>临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</p>
<p>互斥量Synchronized/Lock：采用互斥对象机制，<strong>只有拥有互斥对象的线程才有访问公共资源的权限</strong>。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。。当进入临界区时，需要获得互斥锁并且加锁；那么其他线程先要访问临界区就要等待锁释放。当离开临界区时，需要对互斥锁解锁，<strong>以唤醒其他等待该互斥锁的线程。</strong></p>
<p>锁是一个抽象的数据结构</p>
<ul>
<li>一个二进制状态（解锁/绑定）</li>
<li><code>Lock::Acquire() - 锁被释放 之前一直等待，然后得到锁</code></li>
<li><code>Lock::Release() -释放锁，唤醒任何等待的进程</code></li>
<li>怎么实现？<ul>
<li>原子操作<ul>
<li>test -and set<ul>
<li>从内存中读取值</li>
<li>测试该值是否为1，不为1进入临界区</li>
<li>内存值设为1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>其主要的系统调用如下：</p>
<p>pthread_mutex_init:初始化互斥锁</p>
<p>pthread_mutex_destroy：销毁互斥锁</p>
<p>pthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁。</p>
<p>pthread_mutex_unlock:以一个原子操作的方式给一个互斥锁解锁。</p>
<p>信号量Semphare：为控制具有有限数量的用户资源而设计的，<strong>它允许多个线程在同一时刻去访问同一个资源</strong>，但一般需要限制同一时刻访问此资源的最大线程数目。</p>
<p>条件变量，顾名思义，<strong>一个或者多个线程等待某个布尔表达式为真，即等待别的进程唤醒他</strong>。信号量会与互斥量一起使用，<strong>条件本身是由互斥量</strong>保护的。线程在改变条件状态之前必须锁住互斥量。</p>
<p>其主要的系统调用如下：</p>
<p>pthread_cond_init:初始化条件变量</p>
<p>pthread_cond_destroy：销毁条件变量</p>
<p>pthread_cond_signal：<strong>唤醒一个等待目标条件变量的线程</strong>。哪个线程被唤醒取决于调度策略和优先级。</p>
<p>pthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在<strong>进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 条件变量实现</span>
<span class="token comment">//需要维持每个条件队列</span>
<span class="token comment">//线性等待的条件等待signal()</span>
class Condition<span class="token punctuation">&#123;</span>
    <span class="token comment">// 等待的线程数</span>
    <span class="token keyword">int</span> numWaiting <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    WaitQueue q<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
Condition<span class="token operator">::</span><span class="token function">Wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    numWaiting<span class="token operator">++</span><span class="token punctuation">;</span>
    Add this thread t to q<span class="token punctuation">;</span>
    <span class="token comment">// 一定要先释放锁</span>
    <span class="token function">release</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//需要互斥锁,阻塞在这里，等待信号量满足条件</span>
    <span class="token function">require</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
Condition<span class="token operator">::</span><span class="token function">Signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">// 和信号量不一样，不一定执行--操作</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>numWaiting <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        remove a tread from q<span class="token punctuation">;</span>
        <span class="token function">wakeup</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 需要互斥锁</span>
        numWaiting<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//从管程看生产者消费者问题</span>
class BoundBuffer<span class="token punctuation">&#123;</span>
    <span class="token comment">//保证互斥</span>
    Lock lock<span class="token punctuation">;</span>
    <span class="token comment">//buffer内容计数</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">//两个条件变量</span>
    Condition notFull<span class="token punctuation">,</span>notEmpty<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
BoundeBuffer<span class="token operator">::</span><span class="token function">Deposite</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">//线程进入管程，只有一个线程能进去</span>
    lock <span class="token operator">-></span> <span class="token function">Acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>count <span class="token operator">==</span> n<span class="token punctuation">)</span>
        <span class="token comment">// 当前已经满了，睡眠，在Wait中一定要释放互斥锁，</span>
        notFull<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Add c to Buffer<span class="token punctuation">;</span>
    count<span class="token operator">++</span><span class="token punctuation">;</span>
    notEmpty<span class="token punctuation">.</span><span class="token function">Signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    lock <span class="token operator">-></span> <span class="token function">Release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
BoundeBuffer<span class="token operator">::</span><span class="token function">Remove</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    lock <span class="token operator">-></span> <span class="token function">Acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        notEmpty<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    remove c frome buffer<span class="token punctuation">;</span>
    count<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token comment">// 有空闲了，唤醒notFull中线程</span>
    notFull<span class="token punctuation">.</span><span class="token function">Signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    lock <span class="token operator">-></span> <span class="token function">Release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




<h2><span id="9-虚拟内存为什么要有虚拟内存什么是虚拟地址空间">9、虚拟内存？为什么要有虚拟内存？什么是虚拟地址空间?</span></h2><p>虚拟内存,虚拟内存是一种内存管理技术,它会使程序自己认为自己拥有一块很大且连续的内存,然而,这个程序在内存中不是连续的,并且有些还会在磁盘上,在需要时进行数据交换;</p>
<p>为什么要有虚拟内存？</p>
<p>在早期的计算机中，是没有虚拟内存的概念的。我们运行一个程序，会把程序全部装入内存，然后运行。</p>
<p>当运行多个程序的时候，经常会出现如下问题：</p>
<ul>
<li>地址空间不隔离，没有权限保护</li>
</ul>
<p>由于程序都是直接访问物理内存，所以一个进程可以修改其他进程的内存数据，甚至修改内核地址空间里的数据。</p>
<ul>
<li>内存使用效率底</li>
</ul>
<p>当内存空间不足的时候，将其他程序暂时拷贝到硬盘，然后新程序装入内存运行。<strong>由于大量的数据会装入装出，内存效率会十分低下。</strong></p>
<ul>
<li>程序运行地址不稳定</li>
</ul>
<p>因为程序内存地址都随机分配的，所<strong>以程序运行的地址也是不确定的。内存管理复杂。</strong></p>
<p>虚拟地址的优点？</p>
<ul>
<li>避免用户直接访问物理内存，防止一些破坏性操作，保护操作系统</li>
<li>每个进程都分配了4GB的虚拟内存，用户程序可使用比实际物理内存<strong>更大的地址空间。</strong></li>
<li>当进程通信时，可采用<strong>虚存共享的方式实现</strong>。当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要<strong>把自己的虚拟内存映射过去就可以了</strong>，节省内存</li>
<li>简化了链接器，加载器这样的程序的内存管理。</li>
</ul>
<p>什么是虚拟地址空间？</p>
<p>虚拟地址空间是对于一个单一进程的概念,<strong>这个进程看到的将是地址从 0000 开始的整个内存空间。</strong>虚拟存储器是一个抽象概念,它为每一个进程提供了一个假象,好像每一个进程都在独占的使用主存。<strong>每个进程看到的存储器都是一致的,称为虚拟地址空间。</strong>从最低的地址看起:程序代码和数据,堆,共享库,栈,内核虚拟存储器。</p>
<p>虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的4G内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。 事实上，在每个进程创建加载时，<strong>内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。</strong>还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。<strong>可以认为虚拟空间都被映射到了磁盘空间中，（事实上也是按需要映射到磁盘空间上，通过mmap），并且由页表记录映射位置，</strong>当访问到某个地址的时候，通过页表中的有效位，可以得知此数据是否在内存中，如果不是，则通过缺页异常，将磁盘对应的数据拷贝到内存中，如果没有空闲内存，则选择牺牲页面，替换其他页面。</p>
<h2><span id="10-mmap原理">10、mmap原理</span></h2><p>mmap是用来建立从<strong>虚拟空间到磁盘空间的映射的</strong>，可以将一个虚拟空间地址映射到一个磁盘文件上，当不设置这个地址时，则由系统自动设置，函数返回对应的内存地址（虚拟地址）。使用mmap分配内存，在<strong>堆和栈之间找一对空闲的内存分配</strong>。这两种方式分配的是虚拟内存，没有分配物理内存。真正的分配要在第一次访问已经分配的虚拟地址空间的时候，发生缺页中断，由操作希用分配物理内存，建立虚拟内存和物理内存之间的映射关系。</p>
<h2><span id="11-进程控制块包含信息和组织方式">11、进程控制块包含信息和组织方式？</span></h2><p><strong>进程控制块(PCB)是系统为了管理进程设置的一个专门的数据结构。系统用它来记录进程的外部特征，描述进程的运动变化过程。同时，系统可以利用PCB来控制和管理进程，所以说，PCB（进程控制块）是系统感知进程存在的唯一标志。</strong></p>
<p><strong>PCB含有以下三大类信息</strong>：</p>
<p><strong>进程标识信息</strong>：本进程标识，父进程表示，用户标识</p>
<p>处理机状态信息保存区：</p>
<p>保存进程的运行<strong>现场信息</strong>。用户可见的寄存器，控制和状态寄存器，栈指针（过程调用，系统调用，中断处理和返回需要用到）</p>
<p>进程<strong>控制信息</strong>：</p>
<p><strong>调度和状态信息</strong>：如进程状态、等待事件和等待原因、进程优先级、<strong>进程通信信息</strong>：如消息队列指针、信号量等互斥和同步机制，这些信息存放在接收方的进程控制块中。<strong>存储管理信息</strong>：进程在辅存储器内的地址，包含指向本进程映像存储空间的数据结构。<strong>进程所用资源</strong>：包括进程所需全部资源、已经分得的资源,如主存资源、I/0设备、打开文件表等。<strong>有关数据结构连接信息</strong>：父子进程连接起来，进程可以连接到一个进程队列中，或连接到相关的其他进程PCB。</p>
<ul>
<li>PCB组织方式</li>
</ul>
<p>一般是链表:更好的完成动态插入删除。一个状态的进程对应PCB中的一个链表。如就绪链表，阻塞链表。</p>
<h2><span id="12-请你说一说操作系统中的程序的内存结构">12、请你说一说操作系统中的程序的内存结构</span></h2><p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/%E7%A8%8B%E5%BA%8F%E7%A9%BA%E9%97%B4.png" alt=" "></p>
<p>可以看到一个可执行程序在存储（没有调入内存）时分为代码段、数据区和未初始化数据区三部分。</p>
<p>BSS段（未初始化数据区）：通常用来存放程序中<strong>未初始化的全局变量和静态变量</strong>的一块内存区域。BSS段属于静态分配，程序结束后静态变量资源由系统自动释放。</p>
<p>数据段：存放程序中已初始化的全局变量的一块内存区域。数据段也属于静态内存分配</p>
<p>代码段：存放程序<strong>执行代码</strong>的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些<strong>只读的常数变量</strong></p>
<p>text段和data段在编译时已经分配了空间，而<strong>BSS段并不占用可执行文件的大小</strong>，它是由链接器来获取内存的。</p>
<p>bss段（未进行初始化的数据）的内容<strong>并不存放在磁盘上的程序文件</strong>中。其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有正文段和初始化数据段。BSS段的大小从可执行文件中得到，<strong>然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。</strong>包含数据段和BSS段的整个区段此时通常称为数据区。</p>
<p>可执行程序在运行时又多出两个区域：栈区和堆区。</p>
<p>栈区：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</p>
<p>堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用<strong>链式存储</strong>结构。<strong>频繁的malloc/free造成内存空间的不连续，产生碎片。</strong>当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。</p>
<h2><span id="13-进程创建和进程切换步骤">13、进程创建和进程切换步骤？</span></h2><p>●进程的创建来源于以下四个事件：</p>
<p>1.提交一个批处理作业。</p>
<p>2.在终端上交互式的登录。</p>
<p>3.操作系统<strong>创建一个服务进程</strong>。</p>
<p>4.存在的进程<strong>孵化(spawn)新的进程</strong>。</p>
<p>●进程的创建过程如下描述：</p>
<p>1.在主进程表中增加一项,并从PCB池中<strong>取一个空白PCB，或者创建PCB控制块。</strong>对于我们一般写的程序，主进程是最初始的父进程。</p>
<p>2.<strong>为新进程的进程映像中的所有成分分配地址空间</strong>。对于进程孵化操作还需要传递环境变量,构造<strong>共享地址空间。</strong></p>
<p>3.<strong>为新进程分配资源</strong>,除内存空间外,还有其它各种资源。</p>
<p>4.查找辅助存储器,找到进程<strong>正文段并装入到正文区</strong>。</p>
<p>5.初始化进程控制块,**为新进程分配一个唯一的进程标识符,**初始化PSW。</p>
<p>6.把进程加入某一就<strong>绪进程队列</strong>,或直接将进程投入运行。</p>
<p>7.通知操作系统的某些模块,如记账程序、性能监控程序。</p>
<p>●进程切换的步骤</p>
<p>1.<strong>保存</strong>被中断进程的处理器<strong>现场信息</strong>。</p>
<p>2.<strong>修改</strong>被中断进程的<strong>进程控制块</strong>的有关信息,<strong>如进程状态等。</strong></p>
<p>3.把被中断进程的进程控制块<strong>加入有关队列</strong>。</p>
<p>4.<strong>选择下一个</strong>占有处理器运行的<strong>进程</strong>。</p>
<p>5.<strong>修改</strong>被选中进程的<strong>进程控制块</strong>的有关信息。</p>
<p>6.根据被选中进程设置操作系统用到的地址转换和存储保护信息。</p>
<p>7.根据被选中进程的信息来恢复处理器现场。</p>
<h2><span id="14-进程加载终止调用的函数fork和vfork的区别">14、进程加载终止调用的函数？fork和vfork的区别？</span></h2><p>fork()创建一个<strong>继承的子进程</strong></p>
<p>当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把<strong>父进程的地址空间中的内容逐页的复制到子进程的地址空间中。</strong>但从内核角度来说，逐页的复制方式是十分耗时的。</p>
<ul>
<li>父进程返回子进程id，子进程返回0，不成功id&lt;0</li>
<li>复制父进程所有的变量和内存</li>
<li>复制父进程所有CPU寄存器</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建子进程</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    
    <span class="token comment">//做什么都行（关闭网络连接。。）    </span>
    <span class="token comment">//调用exec()加载新程序取代当前运行进程，地址空间，代码数据咱也换掉了    </span>
<span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"program"</span><span class="token punctuation">,</span>argc<span class="token punctuation">,</span>arvc0<span class="token punctuation">,</span>argv1<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>
<span class="token comment">//等待子进程结束child_status = wait(pid);</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在fork后立刻执行exec所造成的地址空间的浪费。vfork()轻量级fork,创建进程时不再<strong>创建同样的内存映像</strong></p>
<p>子进程必须要立刻执行一次对exec的系统调用，或者调用_exit( )退出 ，vfork( )会挂起父进程直到子进程终止或者运行了一个新的可执行文件的映像。通过这样的方式，vfork( )避免了地址空间的按页复制。</p>
<p><strong>COPY on Write</strong> （写的时候在进行复制），在实际地址空间复制的时候并没有真实的复制，而只是复制父进程地址空间所需要的元数据（页表），指向同一块地址空间，当父进程或者子进程对某一个地址单元写操作会触发一个异常，使得触发异常的页复制成两份。只有写的时候才会复制成两份。</p>
<p>fork和vfork的区别：</p>
<p>fork( )的父子进程的执行次序不确定；<strong>vfork( )保证子进程先运行</strong>，在调用exec或exit之前与父进程数据是共享的，在它<strong>调用exec或exit之后父进程才可能被调度</strong>运行。</p>
<h2><span id="15-请问如何修改文件最大句柄数">15、请问如何修改文件最大句柄数？</span></h2><p>linux默认最大文件句柄数是1024个，在linux服务器文件并发量比较大的情况下，系统会报”too many open files”的错误。故在linux服务器高并发调优时，往往需要预先调优Linux参数，修改Linux最大文件句柄数。</p>
<p>有两种方法：</p>
<ol>
<li><p>ulimit -n &lt;可以同时打开的文件数&gt;，将当前进程的最大句柄数修改为指定的参数（注：该方法只针对当前进程有效，重新打开一个shell或者重新开启一个进程，参数还是之前的值）</p>
</li>
<li><p>对所有进程都有效的方法，修改Linux系统参数</p>
</li>
</ol>
<p>vi /etc/security/limits.conf 添加</p>
<p>​    soft　　nofile　　65536</p>
<p>　hard　　nofile　　65536</p>
<p>将最大句柄数改为65536</p>
<p>修改以后保存，注销当前用户，重新登录，修改后的参数就生效了</p>
<h2><span id="16-并发和并行">16、并发和并行</span></h2><p>并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。</p>
<p>并行（parallelism）：指严格<strong>物理意义上统一时刻的同时运行</strong>，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。</p>
<h2><span id="17-常见的几种内存管理机制">17、 常见的几种内存管理机制？</span></h2><ol>
<li><p><strong>块式管理</strong> ：远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，<strong>分配的这块内存很大一部分几乎被浪费</strong>了。这些在每个块中未被利用的空间，我们称之为碎片。</p>
</li>
<li><p><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表<strong>将虚拟地址空间和物理地址</strong>对应起来。</p>
</li>
<li><p><strong>段式管理</strong> ：页式管理虽然提高了内存利用率，但是页式管理其中的页实际并<strong>无任何实际意义</strong>。段式管理把主存分为一段段的。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。段式管理通过<strong>段表对应逻辑地址和物理地址</strong>。</p>
<p>每个段由三个参数定义：段基地址、段限长和段属性。</p>
</li>
<li><p><strong>段页式管理机制</strong> ：段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部的都是离散的。</p>
</li>
</ol>
<h2><span id="18-请你说一说操作系统中的段式管理页式管理寻址">18、请你说一说操作系统中的段式管理，页式管理寻址</span></h2><p>Linux把<strong>虚拟内存空间</strong>分成若干个存储区域，Linux把这样的分区叫做<strong>页</strong>。为了换入，换出的方便，物理内存也得按照大小分成若干个块。由于物理内存中的块空间是容纳虚拟页的容器，所以<strong>物理内存</strong>中的页叫做页框。一般来说一个页为4k大小。<strong>页与页框是linux实现虚拟内存技术的基础。</strong>页式管理实现了虚拟地址到物理地址之间的映射。我们将地址结构分为两个部分页号和页偏移量。</p>
<p>给出逻辑地址如何计算出物理地址？</p>
<ol>
<li>处理器要访问虚拟地址，并把它传送给 MMU</li>
<li>MMU 生成根据虚拟地址生成 VPN(页码)，然后请求高速缓存/主存，获取 PTE 的数据。</li>
<li>高速缓存/主存向 MMU 返回 PTE 的数据，在被调进程的PCB中取出页表始址和页表大小，装入页表寄存器。</li>
<li>页号与页表寄存器的页表长度比较，若页号大于等于页表长度，发生地址越界中断，停止调用，否则继续</li>
<li>由页表起始地址和块号找出页表中的物理页号PPN。用物理页的基址加上页偏移 PPO（假设页大小为 4KB，那么页偏移就是虚拟地址的低 12 位，物理页的页偏移和虚拟页的页偏移相同），获取对应的物理地址。</li>
<li>主存/高速缓存将数据返回给 CPU。</li>
</ol>
<p>段式存储的步骤？</p>
<p>　　段的长度由相应的逻辑信息组的长度决定，因而各<strong>段长度不等</strong>，引入分段存储管理方式的目的主要是为了满足用户（程序员）在编程和使用上多方面的要求。</p>
<p>　　要注重理解，完整的逻辑意义信息，就是说将程序分页时，页的大小是固定的，只根据页面大小大小死生生的将程序切割开；<strong>而分段时比较灵活，只有一段程序有了完整的意义才将这一段切割开。</strong></p>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8.png"></p>
<p>地址结构分为两部分：段号、位移量（段内地址）</p>
<p>逻辑地址 = 段号&amp;段内地址</p>
<p>物理地址= 基址+段内地址</p>
<p>段表中内容，段号，该段长，基址</p>
<ol>
<li><pre><code>  在被调进程的PCB中取出段表始址和段表长度，装入控制寄存器
</code></pre>
</li>
<li><pre><code>  段号与控制寄存器的段表长度比较，若页号大于等于段表长度，发生地址越界中断，停止调用，否则继续
</code></pre>
</li>
<li><p>   由段号结合段表始址求出基址</p>
</li>
</ol>
<p>4    检查段内位移量是否超出该段的段长，若超过，产生越界中断。</p>
<ol start="4">
<li><pre><code>  基址**+**段内地址，即得物理地址
</code></pre>
</li>
</ol>
<p>段页式存储</p>
<p>用户程序<strong>先分段</strong>，每个段内部<strong>再分页（内部原理同基本的分页、分段相同）</strong>逻辑地址分三部分：段号、段内页号、页内地址</p>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/%E6%AE%B5%E9%A1%B5%E5%BC%8F.png"></p>
<p>为实现段页式存储管理，系统应为每个进程设置一个段表，包括每段的<strong>段号</strong>，该段的<strong>页表始址</strong>和<strong>页表长度</strong>。每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块号。</p>
<p>（1）程序执行时，从PCB中取出段表始址和段表长度，装入段表寄存器。<br>（2）由地址变换机构将逻辑地址自动分成段号、页号和页内地址。<br>（3）将段号与段表长度进行比较，若段号大于或等于段表长度，则表示本次访问的地址已超越进程的地址空间，产生越界中断。<br>（4）将段表始址与段号和段表项长度的乘积相加，便得到该段表项在段表中的位置。<br>（5）取出段描述子得到该段的页表始址和页表长度。<br>（6）将页号与页表长度进行比较，若页号大于或等于页表长度，则表示本次访问的地址已超越进程的地址空间，产生越界中断。<br>（7）将页表始址与页号和页表项长度的乘积相加，便得到该页表项在页表中的位置。<br>（8）取出页描述子得到该页的物理块号。<br>（9）对该页的存取控制进行检查。<br>（10）将物理块号送入物理地址寄存器中，再将有效地址寄存器中的页内地址直接送入物理地址寄存器的块内地址字段中，拼接得到实际的物理地址。</p>
<p>优点：(1) 段的逻辑独立性使其易于编译、管理、修改和保护，也便于多道程序共享。<br>(2) 段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间。<br>(3) 方便编程，分段共享，分段保护，动态链接，动态增长。</p>
<hr>
<h2><span id="19-分页机制和分段机制的共同点和区别">19、分页机制和分段机制的共同点和区别</span></h2><ol>
<li><p><strong>共同点</strong> ：</p>
</li>
<li><ul>
<li>分页机制和分段机制都是为了提高内存利用率，较少内存碎片。</li>
<li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li>
</ul>
</li>
<li><p><strong>区别</strong> ：</p>
</li>
<li><ul>
<li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li>
<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li>
</ul>
</li>
</ol>
<h2><span id="20-快表tlb和多级页表">20、快表TLB和多级页表</span></h2><p>在分页内存管理中，很重要的两点是：</p>
<ol>
<li>虚拟地址到物理地址的转换要快。</li>
<li>解决虚拟地址空间大，页表也会很大的问题。</li>
</ol>
<p>为了解决虚拟地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换。我们可以把块表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时CPU要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>
<p>使用快表之后的地址转换流程是这样的：</p>
<ol>
<li>根据虚拟地址中的页号查快表；</li>
<li>如果该页号在快表中，直接从快表中读取相应的物理地址；</li>
<li>如果该页号不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li>
<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>
</ol>
<h3><span id="多级页表">多级页表</span></h3><p>引入多级页表的主要目的是为了<strong>避免把全部页表一直放在内存中占用过多空间</strong>，特别是那些根本就不需要的页表就不需要保留在内存中。</p>
<p>在学习计算机组成原理时，书中谈到，”使用多级页表可以压缩页表占用的内存”，在了解了多级页表的原理后，恐怕对这句话还是理解不了：把页表换成多级页表了就能节约内存了？不是还是得映射所有的虚拟地址空间么？</p>
<p>比如做个简单的数学计算，假如虚拟地址空间为32位（即4GB）、每个页面映射4KB以及每条页表项占4B，则进程需要1M个页表项（<code>4GB / 4KB = 1M</code>），即页表（每个进程都有一个页表）占用4MB（<code>1M * 4B = 4MB</code>）的内存空间。而假如我们使用二级页表，还是上述条件，但一级页表映射4MB、二级页表映射4KB，则需要1K个一级页表项（<code>4GB / 4MB = 1K</code>）、每个一级页表项对应1K个二级页表项（<code>4MB / 4KB = 1K</code>），这样页表占用4.004MB（<code>1K * 4B + 1K * 1K * 4B = 4.004MB</code>）的内存空间。多级页表的内存空间占用反而变大了？</p>
<p>其实我们应该换个角度来看问题，还记得计算机组成原理里面无处不在的局部性原理么？</p>
<h4><span id="如何节约内存">如何节约内存</span></h4><p>我们分两方面来谈这个问题：第一，二级页表可以不存在；第二，二级页表可以不在主存。</p>
<h4><span id="二级页表可以不存在">二级页表可以不存在</span></h4><p>我们反过来想，每个进程都有4GB的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到4GB，何必去映射不可能用到的空间呢？</p>
<p>也就是说，一级页表覆盖了整个4GB虚拟地址空间，但如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。做个简单的计算，假设只有20%的一级页表项被用到了，那么页表占用的内存空间就只有0.804MB（<code>1K * 4B + 0.2 * 1K * 1K * 4B = 0.804MB</code>），对比单级页表的4M是不是一个巨大的节约？</p>
<p>那么为什么不分级的页表就做不到这样节约内存呢？我们从页表的性质来看，保存在主存中的页表承担的职责是将虚拟地址翻译成物理地址；<strong>假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。</strong>所以页表一定要<strong>覆盖全部虚拟地址空间</strong>，不分级的页表就需要有1M个页表项来映射，而二级页表则最少只需要1K个页表项（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。</p>
<h4><span id="二级页表可以不在主存">二级页表可以不在主存</span></h4><p>其实这就像是把页表当成了页面。回顾一下请求分页存储管理，当需要用到某个页面时，将此页面从磁盘调入到内存；当内存中页面满了时，将内存中的页面调出到磁盘，这是利用到了程序运行的局部性原理。我们可以很自然发现，虚拟内存地址存在着局部性，<strong>那么负责映射虚拟内存地址的页表项当然也存在着局部性了</strong>！这样我们再来看二级页表，根据局部性原理，<strong>1024个第二级页表中，只会有很少的一部分在某一时刻正在使用</strong>，我们岂不是可以把二级页表都放在磁盘中，在需要时才调入到内存？我们考虑极端情况，只有一级页表在内存中，二级页表仅有一个在内存中，其余全在磁盘中（虽然这样效率非常低），则此时页表占用了8KB（<code>1K * 4B + 1 * 1K * 4B = 8KB</code>），对比上一步的0.804MB，占用空间又缩小了好多倍！</p>
<h3><span id="总结">总结</span></h3><p>我们把二级页表再推广到多级页表，就会发现页表占用的内存空间更少了，这一切都要归功于对<strong>局部性原理的充分应用。</strong></p>
<p>回头想想，这么大幅度地解决内存空间，我们失去了什么呢？计算机的很多问题无外乎就是时间换空间和空间换时间了，而多级页表就是典型的<strong>时间换空间</strong>的例子了，动态创建二级页表、调入和调出二级页表都是需要花费额外时间的，远没有不分级的页表来的直接；而我们也仅仅是利用局部性原理让这个额外时间开销降得比较低了而已。</p>
<h2><span id="21-局部性原理">21、局部性原理</span></h2><p>局部性原理是虚拟内存技术的基础，正是因为程序运行具有<strong>局部性原理，才可以只装入部分程序到内存就开始运行。</strong></p>
<p>早在1968年的时候，就有人指出我们的程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。</p>
<p>局部性原理表现在以下两个方面：</p>
<ol>
<li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>
<li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ol>
<p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，<strong>并将预取机制</strong>集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p>
<h2><span id="22-虚拟存储器">22、虚拟存储器</span></h2><p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——<strong>虚拟存储器</strong>。</p>
<p>实际上，我觉得虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。</p>
<h2><span id="23-虚拟内存的技术实现">23、虚拟内存的技术实现</span></h2><p><strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</strong> 虚拟内存的实现有以下三种方式：</p>
<ol>
<li><strong>请求分页存储管理</strong> ：建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。</li>
<li><strong>请求分段存储管理</strong> ：</li>
<li><strong>请求段页式存储管理</strong> ：</li>
</ol>
<p>不管是上面那种实现方式，我们一般都需要：</p>
<ol>
<li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li>
<li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li>
<li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换。</li>
</ol>
<h2><span id="24-缺页步骤">24、缺页步骤？</span></h2><p>缺页是指当 CPU 请求一个虚拟地址时，虚拟地址所对应的页在物理内存中不存在。此时 MMU 会产生缺页错误，然后由内核的缺页处理程序从磁盘中调入对应的页到主存中。在处理完成后，CPU 会重新执行导致错误的指令，从而读取到对应的内存数据。</p>
<p>下面是缺页时的地址翻译的过程（第 1 步到第 3 步与页命中时相同）：</p>
<ol>
<li>处理器生成一个虚拟地址，并把它传送给 MMU</li>
<li>MMU 生成根据虚拟地址生成 VPN，然后请求高速缓存/主存，获取 PTE 的数据。</li>
<li>高速缓存/主存向 MMU 返回 PTE 的数据</li>
<li>由于判断出 PTE 的有效位是 0，所以 CPU 将出发一次异常，将控制权转移给内核中的缺页异常处理程序。</li>
<li>缺页异常处理程序确定出物理内存中的牺牲页，如果这个页面被修改过了（D 标志位为 1），那么将牺牲页换出到磁盘。</li>
<li>缺页处理程序从磁盘中调入新的页面到主存中，并且更新 PTE</li>
<li>缺页处理程序将控制权返回给原来的进程，再次执行导致缺页的指令。再次执行后，就会产生页命中时的情况了。</li>
</ol>
<h2><span id="25-页面置换算法">25、页面置换算法？</span></h2><p>上文提到缺页，但是当内存满了的时候，就需要从内存中按照一定的置换算法决定内存把哪个页面放弃，存入新的页。</p>
<h3><span id="最佳置换算法opt">最佳置换算法OPT</span></h3><p>算法思想：每次选择<strong>淘汰的页面</strong>将是<strong>以后永不使用</strong>，或者<strong>在最长时间内不再被访问的页面</strong>，这样可以保证最低的缺页率。 最佳置换算法可以保证最低的缺页率，但是实际上，只有进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面的访问序列。因此，<strong>最佳置换算法是无法实现的</strong>。</p>
<h3><span id="先入现出置换算法fifo">先入现出置换算法FIFO</span></h3><p>总是选择在主存中停留时间最长（即最老）的一页置换，即先进入内存的页，先退出内存。</p>
<p>当为进程分配的物理块数增大时，缺页次数不减反增的异常现象称为<strong>贝莱迪（Belay）异常</strong>。<br><strong>只有FIFO算法会产生Belay异常。</strong>另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应。因为先进入的页面也有可能最经常被访问。因此，<strong>算法性能差。</strong></p>
<h3><span id="最长时间未用置换算法lru">最长时间未用置换算法LRU</span></h3><p>算法思想：<strong>每次淘汰的页面是最近最久未使用的页面。</strong><br>实现方法：赋予每个页面对应的页表项中，用<strong>访问字段记录该页面自上次被访问以来所经历的时间t。</strong>当需要淘汰一个页面时，选择现有页面中t最大的页面，即最近最久未使用。</p>
<p>LRU 置换算法虽然是一种比较好的算法，但要求系统有较多的支持硬件。为了了解一个进程在内存中的各个页面各有多少时间未被进程访问，以及如何快速地知道哪一页是最近最久未使用的页面，须有两类硬件之一的支持：寄存器或栈。</p>
<p><strong>寄存器</strong></p>
<p>为了记录某进程在内存中各页的使用情况，须为每个在内存中的页面配置一个移位寄存器，可表示为</p>
<p>R = Rn-1 Rn-2 Rn-3 … R2 R1 R0</p>
<p>当进程访问某物理块时，要将相应寄存器的 R n -1 位置成 1。此时，定时信号将每隔一定时间(例如 100 ms)将寄存器右移一位。 如果我们把 n 位寄存器的数看做是一个整数， 那么，具有最小数值的寄存器所对应的页面，就是最近最久未使用的页面。</p>
<p><strong>栈</strong></p>
<p>可利用一个特殊的栈来保存当前使用的各个页面的页面号。每当进程访问某页面时，便将该页面的页面号从栈中移出，将它压入栈顶。因此，栈顶始终是最新被访问页面的编号，而栈底则是最近最久未使用页面的页面号。</p>
<h3><span id="时钟置换算法">时钟置换算法</span></h3><p>最佳置换算法那性能最好，但无法实现。先进先出置换算法实现简单，但是算法性能差。最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。<strong>时钟置换算法</strong>是一种<strong>性能和开销均平衡</strong>的算法。又称<strong>CLOCK算法</strong>，或<strong>最近未用算法</strong>（<strong>NRU</strong>，Not Recently Used）</p>
<p><strong>简单CLOCK算法</strong>算法思想：为每个页面设置一个<strong>访问位</strong>，再将内存中的页面都通过<strong>链接指针链接成一个循环队列</strong>。当某个页被访问时，其访问位置1.当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，暂不换出，将访问位改为0，继续检查下一个页面，若第一轮扫描中所有的页面都是1，则将这些页面的访问位一次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过<strong>两轮扫描</strong>）。</p>
<p><strong>改进时钟置换算法</strong></p>
<p>简单的时钟置换算法仅考虑到了一个页面最近是否被访问过。事实上，如果淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。<strong>只有淘汰的页面被修改过时，才需要写回外存。</strong><br>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还需要考虑页面有没有被修改过。<br>改进型时钟置换算法的<strong>算法思想</strong>：<strong>在其他在条件相同时，应该优先淘汰没有被修改过的页面，</strong>从而来避免I/O操作。 为了方便讨论，用（访问位，修改位）的形式表示各页面的状态。</p>
<p>如（1,1）表示一个页面近期被访问过，且被修改过。<br><strong>算法规则</strong>：将所有可能被置换的页面排成一个循环队列</p>
<blockquote>
<p>第一轮：从当前位置开始扫描第一个（0,0）的页用于替换，本轮扫描不修改任何标志位。<br>第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0,1）的页用于替换。本轮将所有扫描的过的页访问位设为0。<br>第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0,0）的页用于替换。本轮扫描不修改任何标志位。<br>第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0,1）的页用于替换。</p>
</blockquote>
<p>由于第二轮已将所有的页的访问位都设为0，因此第三轮、第四轮扫描一定会选中一个页，因此<strong>改进型CLOCK置换算法最多会进行四轮扫描。</strong></p>
<p>(1) 第一优先级淘汰的是<strong>最近没有访问且没有修改</strong>的页面。<br>(2) 第二优先级淘汰的是<strong>最近没有访问但修改</strong>的页面。<br>(3) 第三优先级淘汰的是<strong>最近访问但没有修改</strong>的页面。<br>(4) 第四优先级淘汰的是<strong>最近访问且修改</strong>的页面。</p>
<h2><span id="26-调度算法">26、调度算法？</span></h2><h3><span id="调度评价指标">调度评价指标</span></h3><ul>
<li><p>CPU使用率</p>
<ul>
<li>CPU处于繁忙状态的时间百分比</li>
</ul>
</li>
<li><p>吞吐量（操作系统的计算带宽）</p>
<ul>
<li>在单位时间内的完成进程数量</li>
</ul>
</li>
<li><p>周转时间</p>
<ul>
<li>一个进程从初始化到结束，包括所有等待时间所花费的时间</li>
</ul>
</li>
<li><p>等待时间</p>
<ul>
<li>进程在就绪队列中的总时间</li>
</ul>
</li>
<li><p>响应时间（操作系统的计算延迟）</p>
<ul>
<li>从一个请求被提交到产生第一次响应所花费的时间。（鼠标，键盘响应。。）</li>
</ul>
</li>
<li><p>FCFS（先来先服务Fisrt Come,First Served）</p>
</li>
</ul>
<p>所谓 FCFS 就是「<strong>先来先服务</strong>（First Come First Serve）」，每个进程按进入内存的时间先后排成一队。每当 CPU 上的进程运行完毕或者阻塞，我就会选择队伍最前面的进程，带着他前往 CPU 执行。</p>
<p><strong>缺点：</strong>我收到了一个短进程的抱怨：”上次我前面排了一个长进程，等了足足 200 秒他才运行完。我只用 1 秒就运行结束了，就因为等他，我多花了这么长时间，太不值得了。” <strong>平均等待时间也会增长</strong></p>
<p>我仔细一想， FCFS 算法确实有这个缺陷——短进程的响应时间太长了，<strong>用户交互体验会变差</strong>。</p>
<ul>
<li>SPN(短进程优先shortest Remaining time)</li>
</ul>
<p>为了改进上述缺点，减少平均响应时间。每次选择预计处理时间最短的进程。因此，在排队的时候，我会把<strong>短进程</strong>从队列里提到前面。</p>
<p>但是<strong>缺点</strong>又出现了：但长进程们不干了：那些短进程天天插队，导致他们经常得不到 CPU 资源，造成了「<strong>饥饿</strong>」现象。这可是个大问题。FCFS 虽然响应时间长，但最后所有进程一定有使用 CPU 资源的机会。但 SPN 算法就不一样了，如果短进程源源不断加入队列，长进程们将永远得不到执行的机会——太可怕了。</p>
<p>那么前两种方法都不行，怎样又<strong>能照顾短进程，又能照顾长进程呢。</strong></p>
<ul>
<li>HRRN(<strong>最高相应比优先</strong> Highest Response Ratio Next)</li>
</ul>
<p>综合考虑<strong>等待时间和执行时间</strong>，响应比 = （等待时间+执行时间）/ 执行时间。响应比高的算法会先执行。我们称之为「<strong>高响应比优先</strong>」。关注了进程等待了多长时间，防止了无限期推迟。</p>
<p>问题：执行时间很难准确知道。工作量增加，每次调度计算相应比。</p>
<h3><span id="并发时代来临">并发时代来临</span></h3><p>随着计算机的普及，个人用户大量增长，<strong>并发</strong>，即一次运行多个程序的需求出现了。这可难倒我了——处理器只有一个，怎么运行多个程序？</p>
<p>每个进程<strong>短时间交替</strong>使用我的资源，但在人类看来，这些进程就<strong>像在「同时」运行</strong>。”</p>
<ul>
<li>RR (轮寻 Round Robin)<ul>
<li>使用<strong>时间切片和抢占来轮流执行任务</strong></li>
</ul>
</li>
</ul>
<p>在这个算法里，每个进程将轮流使用 CPU 资源，只不过在他们开始运行时，我会为他们打开<strong>定时器</strong>，如果定时器到时间（或者执行阻塞操作），进程将被迫「下机」，切换至下一个进程。至于下一个进程的选择嘛，直接用 FCFS 就好了。</p>
<p>直观来看，时间片越短，固定时间里可运行的进程就越多，可 CPU 说过，切换进程是要消耗他不少指令周期的，时间片过短会导致大量 CPU 资源浪费在<strong>切换上下文</strong>上。时间片过长，短交互指令响应会变慢。所以具体怎么取，还得看交互时间大小（感觉像没说一样，但至少给了个标准嘛）。</p>
<p>这一阶段，我的工作量大大提升——以前十几秒都不用切换一次程序，现在倒好，一秒钟就得切换数十次。</p>
<p><strong>问题：</strong>IO密集型进程认为这算法不公平，时间片轮转没有照顾到我们这类进程啊！我们经常在 CPU 没呆到一半时间片，就遇到了阻塞操作，被你赶下去。而且我们在<strong>阻塞队列</strong>，往往要停留很长时间。等阻塞操作结束，我们还得在<strong>就绪队列</strong>排好长时间队。那些处理器密集型进程，使用了大部分的处理器时间，导致我们性能降低，响应时间跟不上</p>
<ul>
<li>MFQ（多级反馈队列 Mutilevel FeedBack Queue）<ul>
<li>优先级队列中的轮循</li>
</ul>
</li>
</ul>
<p>例如有n级的优先级——优先级调度在所有级别当中，RR使用在每个优先级中。</p>
<p>时间量子大小随着优先级增加而增加，<strong>等待时间越长优先级越高。</strong></p>
<p>如果任务在当前的时间量子中没有完成，则降级，<strong>用的时间片越多级别越降低。</strong></p>
<p>优点：CPU密集任务的优先级下降很快。</p>
<p> I/O笔记型任务临流在高优先级。</p>
<ul>
<li>Fair share scheduling (公平调度原则)</li>
</ul>
<p>服务器怎么调度进程？有一个用户会使用多个进程，一个用户使用一个进程。在用户级别能够实现公平调度。</p>
<h2><span id="27-什么是系统调用呢能不能详细介绍一下">27、<strong>什么是系统调用呢？</strong>能不能详细介绍一下。</span></h2><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>
<ol>
<li>用户态(user mode) : 用户态运行的进程或可以直接读取用户程序的数据。</li>
<li>系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ol>
<p>说了用户态和系统态之后，那么什么是系统调用呢？</p>
<p>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p>
<p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<h2><span id="28-lru具体实现">28、LRU具体实现？</span></h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class LRUCache &#123;
public:
    LRUCache(int capacity):capLRU(capacity)&#123;
    &#125;
    
    int get(int key) &#123;
        auto itr &#x3D; keyItrMap.find(key);
        if(itr &#x3D;&#x3D; keyItrMap.end())
            return -1;
        &#x2F;&#x2F; 找到链表里对应的value值
        int value &#x3D; itr -&gt; second -&gt; second;
        &#x2F;&#x2F; 找到了就删除原有位置，插相应元素到队头
        keyValueList.erase(itr -&gt; second);
        keyValueList.push_front(make_pair(key,value));
        keyItrMap[key] &#x3D; keyValueList.begin();
        return value;
    &#125;
    
    void put(int key, int value) &#123;
        auto itr &#x3D; keyItrMap.find(key);
        &#x2F;&#x2F; 找到重复元素修改就可以
        if(itr !&#x3D; keyItrMap.end())&#123;
            keyValueList.erase(itr -&gt; second);

        &#125;
            keyValueList.push_front(make_pair(key,value));
            keyItrMap[key] &#x3D; keyValueList.begin();        
        if(capLRU &lt; keyValueList.size())&#123;
            &#x2F;&#x2F; 删除处于队位的元素
            keyItrMap.erase(keyValueList.back().first);
            keyValueList.pop_back();
        &#125;
           
    &#125;
         
private:
    &#x2F;&#x2F; 存入key,和指向list的迭代器
    unordered_map&lt;int,list&lt;pair&lt;int,int&gt;&gt;::iterator&gt; keyItrMap;
    &#x2F;&#x2F; 存入key和value
    list&lt;pair&lt;int,int&gt;&gt; keyValueList;
    int capLRU;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 自己实现链表
struct myListNode
&#123;
    int key;
    int value;
    myListNode* pre;
    myListNode* next;
    myListNode(int tmpKey,int tmpValue):key(tmpKey),value(tmpValue),
        pre(nullptr),next(nullptr)&#123;&#125;;
&#125;;
class LRUCache&#123;
public:
    LRUCache(int tmpCap)&#123;
        capacity &#x3D; tmpCap;
        head &#x3D; new myListNode(-1,-1);
        tail &#x3D; new myListNode(-1,-1);
        head -&gt; next &#x3D; tail;
        tail -&gt; pre &#x3D; head;
    &#125;
    int get(int key)&#123;
        auto itr &#x3D; keyAndAdress.find(key);
        if(itr &#x3D;&#x3D; keyAndAdress.end())
            return -1;
        myListNode* deleNode &#x3D; itr -&gt; second;
        int value &#x3D; deleNode -&gt; value;
        removeNode(deleNode);
        myListNode* pNode &#x3D; new myListNode(key,value);
        InsertNode(pNode);
        keyAndAdress[key] &#x3D; pNode;
        return value;
    &#125;
    void put(int key,int value)&#123;
        auto itr &#x3D; keyAndAdress.find(key);
        if(itr !&#x3D; keyAndAdress.end())&#123;
            removeNode(itr -&gt; second);   
            size--;    
        &#125;
        myListNode* pNode &#x3D; new myListNode(key,value);
        size++;
        InsertNode(pNode);
        keyAndAdress[key] &#x3D; pNode;
        if(size &gt; capacity)&#123;
            int lastKey &#x3D; tail -&gt; pre -&gt; key;
            keyAndAdress.erase(lastKey);
            &#x2F;&#x2F;删除节点释放内存
            removeNode(tail -&gt; pre);
            size--;
        &#125;

    &#125;
    &#x2F;&#x2F;删除指定节点
    void removeNode(myListNode* pNode)&#123;
        pNode -&gt; pre -&gt; next &#x3D; pNode -&gt; next;
        pNode -&gt; next -&gt; pre &#x3D; pNode -&gt;pre;
        delete pNode;
        pNode &#x3D; nullptr;
    &#125;
    &#x2F;&#x2F; 插入元素插入到链表的前边就可以了
    void InsertNode(myListNode* pNode)&#123;
        pNode -&gt; next &#x3D; head -&gt; next;
        head -&gt; next -&gt; pre &#x3D; pNode;
        head -&gt; next &#x3D; pNode;
        pNode -&gt; pre &#x3D; head;
    &#125;
    ~LRUCache()&#123;
        myListNode* pNode &#x3D; head;
        while(pNode !&#x3D; nullptr)&#123;
            myListNode* nextNode &#x3D; pNode -&gt; next;
            delete pNode;
            pNode &#x3D; nullptr;
            pNode &#x3D; nextNode;
        &#125;
    &#125;
private:
    unordered_map&lt;int,myListNode*&gt; keyAndAdress;
    myListNode* head;
    myListNode* tail;
    int capacity &#x3D; 0;
    int size &#x3D; 0;

&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2><span id="29-请问单核机器上写多线程程序是否需要考虑加锁为什么">29、请问单核机器上写多线程程序，是否需要考虑加锁，为什么？</span></h2><p>在单核机器上写多线程程序，仍然需要线程锁。因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，<strong>通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。</strong>如果这两个线程共享某些数据，不使用线程锁的前提下，可能会<strong>导致共享数据修改引起冲突</strong>。</p>
<h2><span id="30-请你说一说死锁发生的条件以及如何解决死锁">30、请你说一说死锁发生的条件以及如何解决死锁</span></h2><ul>
<li>互斥：某个资源在一个时间段内只能由一个进程占有，不能被两个或两个以上的进程占有。</li>
<li>持有并等待：进程保持至少一个资源正在等待获取其他进程持有的额外资源。</li>
<li>无抢占：一个资源<strong>只能进程自愿释放</strong>，进程已经完成了他的任务。</li>
<li>循环等待：<strong>资源分配图里有回环</strong>，存在进程集合{P0,P1,..PN},P0正在等待P1所占用的资源，P1等待P2占用的资源，PN-1等待PN占用的资源，PN等待P0占用的资源。</li>
</ul>
<p>死锁预防是保证不进入死锁状态的一种策略。打破死锁四个必要条件的一个就可以了。</p>
<p>打破前三种必要条件都不太好。</p>
<ul>
<li>打破互斥条件。即允许进程同时访问某些资源。但是,<strong>有的资源是不允许被同时访问的</strong>,像打印机等等,这是由资源本身的属性所决定的。所以,这种办法并无实用价值。</li>
<li>打破持有并等待 - <strong>要拿资源就把需要的资源全部拿到</strong>，资源占有时间长，<strong>别的进程得不到资源</strong>，可能发生饥饿，资源利用率低。不好</li>
<li>打破无抢占 - 把别的进程kill掉，把资源抢过来这种预防死锁的方法实现起来困难,会降低系统性能。</li>
<li>打破循环等待。对所有<strong>资源类型进行排序</strong>，并要求<strong>每个进程按照资源的顺序进行申请</strong>。</li>
</ul>
<p>死锁避免</p>
<ul>
<li>要求每个资源<strong>声明</strong>他可能<strong>需要</strong>的每个类型资源的<strong>最大数目</strong>。</li>
<li>资源的分配状态是通过<strong>限定提供与分配</strong>的资源数量，和进程的最大需求。</li>
<li><strong>动态检查资源的分配状态，以确保永远不会有一个环形等待状态。（假如我分配给你了，其他进程不会出现死锁，就分配给你）</strong></li>
</ul>
<h2><span id="31-银行家算法">31、银行家算法？</span></h2><p>银行家算法的基本思想是<strong>分配资源之前,判断系统是否是安全的;若是,才分配。</strong>它是最具有代表性的避免死锁的算法。</p>
<p>n = 进程数量，m= 资源类型数量</p>
<ul>
<li>Max(<strong>总需求量</strong>)：n*m矩阵，如<code>Max[i][j] = k</code>表示进程Pi最多请求k个资源类型Rj的实例。</li>
<li>Avaliable**(剩余空闲量**)：长度为m的向量。如果Avaliable[j] = k，有k个类型Rj的资源实例可用。</li>
<li>Allocation(<strong>已分配量</strong>)：n*m 矩阵。<code>Allocation[i][j] = k,则Pi当前分配了k个Rj的实例。</code></li>
<li>Need（<strong>未来需求量</strong>)：n*m矩阵，<code>Need[i][j] = k</code>，则Pi可能需要至少k个Rj来完成任务。</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">思路
Need<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span> Max<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
设进程 cusneed 提出请求 REQUEST <span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>则银行家算法按如下规则进行判断。
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>如果 REQUEST <span class="token punctuation">[</span>cusneed<span class="token punctuation">]</span> <span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span> NEED<span class="token punctuation">[</span>cusneed<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>则转<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>否则<span class="token punctuation">,</span>出
错。因为进程已经超过了最大要求。
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>如果 REQUEST <span class="token punctuation">[</span>cusneed<span class="token punctuation">]</span> <span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span> AVAILABLE<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>则转<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>否则<span class="token punctuation">,</span>等待。
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>系统试探分配资源<span class="token punctuation">,</span>修改相关数据<span class="token operator">:</span>
AVAILABLE<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-=</span>REQUEST<span class="token punctuation">[</span>cusneed<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
ALLOCATION<span class="token punctuation">[</span>cusneed<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span>REQUEST<span class="token punctuation">[</span>cusneed<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
NEED<span class="token punctuation">[</span>cusneed<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-=</span>REQUEST<span class="token punctuation">[</span>cusneed<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>系统执行安全性检查<span class="token punctuation">,</span>如安全<span class="token punctuation">,</span>则分配成立<span class="token punctuation">;</span>否则试探险性分配作废<span class="token punctuation">,</span>系统恢复原状<span class="token punctuation">,</span>进程等待。


总流程
<span class="token number">1</span> Work 和Finsh 分别是长度为m和n的向量
初始化：
Work <span class="token operator">=</span> Avaliable<span class="token punctuation">;</span>  <span class="token comment">//当前资源的剩余空闲量</span>
Finish<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> false <span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>n  <span class="token comment">//线程i没有结束,n线程个数，m资源类型量</span>
<span class="token number">2</span><span class="token punctuation">,</span>找到这样的i：<span class="token comment">//接下来找出Need比Work小的进程，我需要的资源当前还有</span>
（a）Finish<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>
（b）Need <span class="token operator">&lt;=</span> Work（否则不安全，不给他分配）
没有找到这样的i<span class="token punctuation">,</span>转到<span class="token number">4</span>。
<span class="token number">3.</span> Work <span class="token operator">=</span> Work <span class="token operator">+</span> Allcation   <span class="token comment">//使用完了回收资源</span>
    Finish<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>
    转<span class="token number">2.</span>
<span class="token number">4.</span> <span class="token keyword">if</span> Finsh<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> true <span class="token keyword">for</span> all i
表明系统处于安全状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="32-linux的锁机制">32、Linux的锁机制</span></h2><p>互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒</p>
<p>读写锁：rwlock，分为读锁和写锁。处于读操作时，可<strong>以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。</strong>其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；<strong>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。</strong>适用于读取数据的频率远远大于写数据的频率的场合。</p>
<p>自旋锁：spinlock，<strong>在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。</strong>这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。</p>
<h1><span id="计算机网络提纲">计算机网络提纲</span></h1><p>1，计算机网络主要指的就是TCP/IP协议栈，是互联网的基石<br>2，容易忘是因为TCP/IP技术栈有一大部分都隐藏于操作系统的内核态，较少被接触。<br>3，重点脉络：<br>（1，反复记忆。2，多问为什么）<br>一、TCP/IP协议体系的认知<br>（1）分层。一部分处于用户态，一部分处于内核态。数据链路层，网络层，传输层封装于操作系统内核态。应用层存在于操作系统的用户空间，包括DNS，FTP，HTTPs，HTTP，工作中接触较多的是应用层的部分。但其它层的原理必须理解，面试考察。<br>（2）层与层之间下层对上层是透  明的，传输在每一层是对等的。<br>二、数据链路层。<br>（1）以太网帧的格式。（2）MTU（最大传输单元）的概念。（3）ARP协议和RARP协议（地址协议和逆地址协议，网卡MAC地址和IP地址互查机制）（网络层和链路层的中间层）ARP报文格式，查询原理，ARP缓存机制，RARP原理差不多，不用细究<br>三、网络层<br>（1）掌握IP首部格式：如16位分片标识、DF不分片标志、MF更多分片标志、13位片偏移、8位生存时间TTL、16位的首部检验和等等。<br>（2）<strong>掌握如何IP分片</strong>：如总长大于MTU值，画分片情况；<strong>如何避免IP分片（在应用层或传输层做限制）；确定分片顺序；确定分片是否全部到达。</strong><br>（3）掌握IP选路。<strong>会看路由表。Route print</strong> 。路由表每个字段的含义<br>（4）掌握<strong>ICMP</strong>（因特网控制报文协议）：（理解为网络层和传输层的中间协议）报文格式；2种查询报文+5种差错报文。（次要）</p>
<p>四、传输层<br>（1）掌握UDP协议：无连接，不可靠的特点；首部各个字段（次要）<br>（2）<strong>掌握TCP协议（面试集中考察）</strong>：面向连接，可靠；首部各字段（序号，确认号，首部长度，窗口大小，校验和等特别的，完成可靠功能的部分）；TCP连接控制机制（三次握手，四次挥手，同时打开，同时关闭，半关闭）；TCP流量控制机制（滑动窗口、慢启动、拥塞避免、快速重传、快速恢复的算法原理）；TCP超时重传机制（四个定时器）；一些问题（<strong>为什么三次握手四次挥手？为什么TCP和UDP都存在伪包头？</strong>）<br>五、应用层<br>（1）掌握DNS（域名解析）协议：名字空间；DNS指针查询（反向查找或逆向解析）基本原理、DNS缓存<br>（2）FTP协议（活化石）（了解    ）：控制连接和数据连接（为什么需要这两种连接）；两种工作模式（PASV+PORT）；各种FTP指令和响应码；FTP断点续传，匿名FTP<br>（3）HTTP协议：报文格式（请求报文、响应报文、请求头各种字段、响应头各种字段）；HTTP状态码。<br>（4）HTTPS协议：详细握手过程；各种算法（摘要算法、数字签名、数字证书的原理与过程）</p>
<h2><span id="1-dns的概念用途dns查询的实现算法">1 DNS的概念，用途，DNS查询的实现算法</span></h2><p>概念：</p>
<ul>
<li><p>DNS(domian Name system)域名系统，是一个由分层的DNS服务器实现的分布式的数据库，提供了主机名和IP地址之间的相互转换的服务。</p>
</li>
<li><p>域名解析就是我们平常输入的比如说<a href="http://www.baidu.com转化为ip地址,能够是用户方便的访问互联网,而不用去记住能够被机器直接读取的ip地址/">www.baidu.com转化为ip地址，能够是用户方便的访问互联网，而不用去记住能够被机器直接读取的ip地址</a></p>
</li>
<li><p>DNS协议大部分情况下使用UDP传输，使用端口号53。要求域名解析器和域名服务器都必须自己处理超时和重传来保证可靠性。在两种情况下会使用TCP进行传输：</p>
<ul>
<li>返回的响应超过512字节，（UDP最大只支持521字节的数据）。</li>
<li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）</li>
</ul>
</li>
</ul>
<p>主机域名解析顺序</p>
<ul>
<li><p>浏览器缓存</p>
</li>
<li><p>本机hosts文件</p>
</li>
<li><p>路由器缓存</p>
</li>
<li><p>找DNS服务器（本地域名服务器，权威域名服务器，顶级域名服务器，根域名服务器）</p>
<ul>
<li>迭代查询</li>
</ul>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/%E8%BF%AD%E4%BB%A3.png"></p>
<ul>
<li>递归查询</li>
</ul>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/%E9%80%92%E5%BD%92.png"></p>
</li>
</ul>
<p>DNS缓存</p>
<p>为了改善时延性能并减少因特网上到处传输DNS报文的数量，当莫个DNS服务器接收到一个DNS回答，他能将此回答中的信息缓存在本地存储器上。</p>
<h2><span id="2-http协议">2 http协议</span></h2><p>超文本传输协议：一个专门在计算机世界里专门在两个点之间传输文字，图片，视频等超文本数据的约定和规范。首部行里存有各种字段</p>
<p>http有两种报文请求报文和相应报文</p>
<p><img src="./%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png"></p>
<p>例子</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//请求行，正在请求的对象 http版本号</span>
GET <span class="token operator">/</span>some<span class="token operator">/</span>dir<span class="token operator">/</span>page<span class="token punctuation">.</span>html HTTP<span class="token operator">/</span><span class="token number">1.1</span>
<span class="token comment">//指定服务器的域名，可以将请求发往同一台服务器上的不同网站</span>
Host<span class="token operator">:</span> www<span class="token punctuation">.</span>someschool<span class="token punctuation">.</span>edu
<span class="token comment">//一个可复用的TCP连接就建立了，直到客户端或者服务器主动断开连接。</span>
connection<span class="token operator">:</span>keep<span class="token operator">-</span>Alive
<span class="token comment">// 服务器在发完被请求的对象之后关闭连接</span>
connection<span class="token operator">:</span>close
<span class="token comment">// 浏览器的类型和版本</span>
User<span class="token operator">-</span>agent<span class="token operator">:</span>Mozilla<span class="token operator">/</span><span class="token number">1.0</span>
<span class="token comment">// 声明自己能够接收的请求</span>
Accept<span class="token operator">:</span><span class="token operator">*</span><span class="token operator">/</span> <span class="token operator">*</span>    <span class="token comment">//都能收</span>
<span class="token comment">// 语言类型</span>
Accept<span class="token operator">-</span>Lauguage<span class="token operator">:</span>en<span class="token operator">-</span>us
<span class="token comment">//我可以接收什么哪些压缩方式</span>
Accept<span class="token operator">-</span>Encoding<span class="token operator">:</span>gzip<span class="token punctuation">,</span>deflate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="./%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/http%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png"></p>
<p>例子</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Http<span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">200</span> Ok
<span class="token comment">//发送完报文关闭tcp连接</span>
Connection<span class="token operator">:</span>close
<span class="token comment">// 服务器产生该响应并且发送响应报文的时间</span>
data<span class="token operator">:</span>Tue<span class="token punctuation">,</span><span class="token number">09.</span>Aug<span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">//服务器类型</span>
Server<span class="token operator">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">//最后对象修改的日期</span>
Last<span class="token operator">-</span>Modified<span class="token operator">:</span>
<span class="token comment">//被发送对象的字节数</span>
Content<span class="token operator">-</span>Length<span class="token operator">:</span><span class="token number">6180</span>
Content<span class="token operator">-</span>Type<span class="token operator">:</span>test<span class="token operator">/</span>html
<span class="token comment">//我采用什么压缩方式</span>
Contest<span class="token operator">-</span>Encoding<span class="token operator">:</span>gzip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="常见的状态码">常见的状态码</span></h3><p>200 OK:请求成功，信息在返回响应的报文之中</p>
<p>301 Moved Permanently: 请求的对象被永久转移了，新的URL在定义相应报文段的location字段中，浏览器自动重定向新的URL</p>
<p>400 Bad request:一个通用差错编码，指示请求不能被服务器理解。</p>
<p>404 Not Found:请求的文档不再服务器上</p>
<p>505 HTTP Version Not Supported:服务器不支持请报文使用的HTTP协议版本。</p>
<h3><span id="get和post的区别">GET和Post的区别</span></h3><p>Get方法的含义是请求服务器获取资源，这个资源可以是静态的文本，页面，图片视频等。</p>
<p>而Post方法则是相反的操作，<strong>他向URL指定的资源中中提交数据，</strong>比如说一个人的博客可以留言，我写完留言点击提交，我的留言就会执行一次post请求。</p>
<p><strong>Get方法是安全并且幂等的，</strong>也就是说get是一个只读操作，无论执行多少次，服务器上的数据都是安全的，并且每次的结果都是相同的。</p>
<p><strong>Post方法不是安全的并且不是幂等的</strong>，Post因为是新增或者提交数据，会修改服务器上的资源，所以不是安全的，并多次<strong>提交数据会执行多次操作创建多个资源</strong>，所以不是幂等的。</p>
<p><strong>Get 能够被缓存,而 post 不可以;</strong><br>Get 参数保留在浏览器历史中,而 post 参数不会保留在浏览器历史中;<br>当发生数据时,<strong>get 方法向 URL 添加数据,URL 的数据长度是受限的,而 post没有数据长度限制;</strong><br><strong>Get 只允许 ASCII 编码,而 post 没有限制;</strong><br><strong>Get 安全性没有 post 安全性好;</strong><br><strong>Get 数据在 URL 中对所有人是可见的,而在 post 中数据不会显示在 URL 中。</strong><br><strong>Get 产生一个 TCP 数据包,post 产生两个 TCP 数据包</strong>;对于 get 方式的请求,<br>浏览器会把 header 和 data 一并发送出去;对于 post,浏览器先发送 header再发送 data;</p>
<h3><span id="参考回答">参考回答：</span></h3><p>1、概括</p>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</p>
<p>2、区别：</p>
<p>1、get参数通过url传递，post放在request body中。</p>
<p>2、get请求在url中传递的参数是有长度限制的，而post没有。</p>
<p>3、get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。</p>
<p>4、get请求只能进行url编码，而post支持多种编码方式。</p>
<p>5、get请求会浏览器主动cache，而post支持多种编码方式。</p>
<p>6、get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。</p>
<p>7、GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p>
<p>8、GET产生一个TCP数据包；POST产生两个TCP数据包。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>GET</td>
<td><strong>发送请求来获得服务器上的资源</strong>，请求体中不会包含请求数据，请求数据放在协议头中。另外get支持快取、缓存、可保留书签等。幂等</td>
</tr>
<tr>
<td>2</td>
<td>POST</td>
<td>和get一样很常见，<strong>向服务器提交资源让服务器处理，比如提交表单、上传文件等，可能导致建立新的资源或者对原有资源的修改。</strong>提交的资源放在请求体中。不支持快取。非幂等,<strong>POST的数据存放位置由服务器自己决定</strong></td>
</tr>
<tr>
<td>3</td>
<td>HEAD</td>
<td>本质和get一样，<strong>但是响应中没有呈现数据，而是http的头信息</strong>，主要用来<strong>检查资源或超链接的有效性或是否可以可达、检查网页是否被串改或更新，获取头信息等</strong>，特别适用在有限的速度和带宽下。</td>
</tr>
<tr>
<td>4</td>
<td>PUT</td>
<td>和post类似，<strong>html表单不支持</strong>，<strong>发送资源与服务器，并存储在服务器指定位置，</strong>要求客户端事先知道该位置；比如post是在一个集合上（/province），而put是具体某一个资源上（/province/123）。所以put是安全的，无论请求多少次，都是在123上更改，而post可能请求几次创建了几次资源。幂等</td>
</tr>
<tr>
<td>5</td>
<td>DELETE</td>
<td><strong>请求服务器删除某资源。和put都具有破坏性，</strong>可能被防火墙拦截。如果是https协议，则无需担心。幂等</td>
</tr>
<tr>
<td>6</td>
<td>CONNECT</td>
<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。就<strong>是把服务器作为跳板，去访问其他网页然后把数据返回回来</strong>，连接成功后，就可以正常的get、post了。</td>
</tr>
<tr>
<td>7</td>
<td>OPTIONS</td>
<td><strong>获取http服务器支持的http请求方法，允许客户端查看服务器的性能</strong>，比如ajax跨域时的预检等。</td>
</tr>
<tr>
<td>8</td>
<td>TRACE</td>
<td><strong>回显服务器收到的请求，主要用于测试或诊断。</strong>一般禁用，防止被恶意攻击或盗取信息。</td>
</tr>
</tbody></table>
<h3><span id="cookies和session的区别">Cookies和session的区别</span></h3><ul>
<li>登录网站，今输入用户名密码登录了，第二天再打开很多情况下就直接打开了。这个时候用到的一个机制就是cookie。</li>
<li>session一个场景是购物车，添加了商品之后客户端处可以知道添加了哪些商品，而服务器端如何判别呢，所以也需要存储一些信息就用到了session。</li>
</ul>
<p>cookies:一个web站点通常希望能够识别用户，将内容和用户身份连接起来。当客户端发送http请求的时候，服务器就会在返回的报文中含有set-cookies字段，并且这个字段保存在客户端的硬盘上，这样客户端再次发送请求的时候就会加上自己的cookeis，从而服务器就可以识别用户。可以用来在莫个站点持久的保存数据。但是也会造成隐私泄漏问题，结合cookies和用户的账户信息，购物信息等等，Web站点可以知道很多关于用户的信息。cookie存在于客户端，所以也可以伪造</p>
<p>session:<strong>Session是存在服务器的一种用来存放用户数据的类HashTable结构</strong>。当浏览器第一次发起请求的时候，服务器就会自动生成session id 和 hashTable，当第二次发起请求的时候，将前一次服务器响应的session id放在请求中一并发给服务器 ，这时服务器进行和原来的session Id进行对比，就可以找到这个用户的hashTable</p>
<p>cookie数据保存在客户端，session保存在服务器端。</p>
<p>\1. 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，<strong>就需要用某种机制来识具体的用户</strong>，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，<strong>由于HTTP协议无状态，所以并不知道是哪个用户操作的，</strong>所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在<strong>服务端保存Session的方法很多，内存、数据库、文件都有。</strong>集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。<br>\2. 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。<br>\3. Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。<br>所以，总结一下：<br><strong>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，</strong>这个数据可以保存在集群、数据库、文件中；<br><strong>Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息</strong>，也是实现Session的一种方式。</p>
<h2><span id="3-一次完整的http-请求所经历的步骤">3 一次完整的http 请求所经历的步骤</span></h2><p>1 浏览器键入URL,通过DNS服务器请求解析该URL中域名对应的IP地址</p>
<p>2 解析出Ip地址之后，根据该IP地址和默认端口80,和服务器建立TCP连接;</p>
<p>3 浏览器发出读取文件（URL中域名后边的部分）的HTTP请求，该请求报文作为TCP三次握手的底数哪个报文的数据发送给服务器;</p>
<p>4 HTTP服务器从TCP套解字读取HTTP GET 报文，生成一个HTTP响应报文，并把相应的html文本放入到相应报文主体中，发送给浏览器</p>
<p>6 浏览器将接收HTTP响应报文，抽取WEB页面内容，之后进行渲染显示</p>
<p>7 释放TCP链接</p>
<h2><span id="4-http-和https的区别">4 http 和https的区别</span></h2><p>1 http是超文本传输协议，信息传输是明文，存在安全风险。Https则解决了HTTP不安全的缺陷，在TCP和http网络层之间加入了SSL/TLS安全协议，使得报文能够加密传输。</p>
<p>2 http连接的建立相对见简单，TCP三次握手之后便可以进行http传输。而https协议在三次握手之后还要进行</p>
<p>SSl/Tls的握手过程，才能加入加密报文传输</p>
<p>3 HTTP端口号是80,HTTPS端口号是443</p>
<p>4 HTTPS协议需要向CA(证书权威机构申请证书)，确保服务器的身份是可信的。</p>
<p>Https解决了HTTP哪些问题？</p>
<p>窃听风险，比如通信链路上可以 获取通信内容，用户号容易没。</p>
<p>篡改风险，比如强制加入垃圾广告</p>
<p>冒充风险，比如冒充淘宝网站，用户钱容易没</p>
<p>HTTPs可以很好的解决上述问题：</p>
<p>信息加密：交互信息无法被窃取。采用<strong>混合加密</strong>的方式，对称加密，非对称加密。</p>
<p>校验机制:无法篡改通信内容，篡改了就不能正常显示。使用<strong>摘要算法</strong>实现完整性，他能够为数据生成独一无二的指纹，指纹用于校验数据的完整性，解决了篡改的风险。</p>
<p>身份证书：证明淘宝网真是淘宝网，将服务器的公钥放到<strong>数字证书</strong>中去。</p>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.png"></p>
<h3><span id="ssltls协议的基本流程">SSL/TLS协议的基本流程</span></h3><ul>
<li>客户端向服务器所要并验证服务器公钥</li>
<li>双方协商产生会话秘钥</li>
<li>双反次熬夜嗯会话秘钥进行加密通信</li>
</ul>
<p>前两步就是涉及握手阶段的四次通信</p>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/ssl.webp"></p>
<p>步骤：</p>
<p>1 ClientHello:客户端发送给服务器一个随机数，还有支持的TLS协议版本，还有我能使用的加密算法。</p>
<p>2 serverHello: </p>
<ul>
<li>确认TLs版本，版本的相同我们才能继续加密通信。</li>
<li>我服务器也产生一个随机数，用于产生会话秘钥。确认咱们的加密算法</li>
<li>然后我将我的公钥和我的CA数据签名发给客户端。</li>
</ul>
<p>3 客户端回应，</p>
<ul>
<li>首先通过客户端浏览器的CA公钥，对服务器发来的数字签名进行验证取出服务端的公钥。</li>
<li>然后再次向服务端发送一个随机数，这时候这个随机数就被公钥加密，</li>
<li>因为客户端和服务器利用之前两步产生的三个随机数利用加密算法产生秘钥。随后的加密都将使用秘钥加密。</li>
<li>客户端握手结束通知，表示客户端握手结束，同时对以前的内容做一个摘要，供给服务器校验</li>
</ul>
<p>4 服务器最后响应</p>
<ul>
<li>服务器通过三个随机数通过加密算法，得到会话秘钥，向客户端发送最后的信息，加密算法改变通知，之后都用秘钥加密。</li>
<li>握手结束，所有内容摘要供给客户端检验。</li>
</ul>
<h2><span id="5-http的演进和改变">5 http的演进和改变</span></h2><p>http1.1 相比http1.0提高了什么性能</p>
<ul>
<li>使用TCP长连接的方式改善了http1.0断连造成的性能开销</li>
<li><strong>支持管道网络传输</strong>，即在同一个TCP连接里，客户端可以同时发送多个请求，只要一个请求发出去了，不必等待它的相应回来，就可以发送第二个请求出去，可以减少整体的响应时间。</li>
</ul>
<p>但是HTTP/1.1还是有性能瓶颈：</p>
<ul>
<li><strong>请求/响应头部没有进行压缩</strong>就进行发送，首部信息越多延迟越大，只能压缩Body部分;</li>
<li>发送冗长的<strong>首部</strong>。每次相互<strong>发送相同的内容量</strong>浪费较多;</li>
<li>服务器按照请求<strong>顺序相应</strong>的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头堵塞。</strong></li>
<li>没有<strong>请求优先级控制</strong></li>
<li>请求只能从客户端开始，<strong>服务端只能被动响应</strong>。</li>
</ul>
<p>Http2相比http1进行性能改进</p>
<ul>
<li><p>HTTP2会<strong>压缩头</strong>部信息，同时发送多个请求，他们的头是相似的，协议会帮你消除重复的部分。</p>
</li>
<li><p><strong>全面采用二进制格式</strong>，不再采用HTTP1.1纯文本的格式。</p>
</li>
<li><p>多路复用，Http2可以在一个连接中并发多个请求或者回应，<strong>而不用按照顺序意义对应</strong>。移除了HTTP1.1中的串行请求，不再有头部阻塞的问题，降低了延迟，大幅度提高了连接的利用率。</p>
</li>
<li><p><strong>服务器推送</strong>，一定程度改善了请求应答模式，服务器不再是被动相应，可以主动向客户端发送消息。</p>
</li>
</ul>
<p>HTTP3做了什么呢？</p>
<p>http2中的问题在于，多个http请求复用一个TCP连接，下层的TCP协议不知道有多少个HTTP请求的。一旦发生丢包现象，就会出发TCP重传机制，在这样的一个TCP连接机制中<strong>所有的HTTP请求都必须等待这个丢了的包重新传回来。</strong></p>
<p>这是基于TCP传输层的问题，所以HTTP把HTTP下层的TCP改成了UDP!大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p>
<h2><span id="传输层">传输层</span></h2><p>TCP和UDP是传输层两个最基本的协议，最基本的职责是将两个在端系统间IP的交付服务扩展为在端系统的两个进程之间的交付服务。</p>
<h2><span id="6-tcp和udp的区别">6 TCP和UDP的区别</span></h2><p><strong>可靠性</strong></p>
<p>TCP是可靠交付：无差错，不丢失，不重复。</p>
<p>UDP是尽最大努力交付，不保证可靠交付。</p>
<p><strong>拥塞控制，流量控制</strong></p>
<p>TCP有拥塞控制和流量控制保证数据传输的安全性，UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。</p>
<p><strong>报文长度</strong></p>
<p>TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。</p>
<p>UDP面向报文，不合并，拆分，保留上面串下来的报文边界。</p>
<p><strong>首部开销</strong></p>
<p>TCP首部开销大，占20个字节，UDP占8个字节（源端口，目的端口，数据长度，校验和）</p>
<p><strong>适用场景</strong></p>
<p>若通信数据完整性比实时性重要，比如传送邮件，反之则用UDP，如视频传输，实时通信等。</p>
<h2><span id="7-udp的校验和是怎么计算的">7 UDP的校验和是怎么计算的</span></h2><p>注意：校验和是可选的。（TCP是必选的）。UDP的校验和是药剂算首部和数据部分。首部还包括伪首部。</p>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/UDP%E6%A0%A1%E9%AA%8C%E5%92%8C.png"></p>
<p>多了十二字节的伪首部，注意UDP长度被计算了两次，如果校验和有错，则UDP数据报被悄悄丢弃，不产生任何差错报文。</p>
<p>校验方式：发送方对报文段所有16比特的和进行反码运算，加和其间任何其间出现溢出都会回卷。接收方将所有的比特加在一起，如果没有差错，最后的和是全为1的。</p>
<h2><span id="8-tcp最大传输单元">8 TCP最大传输单元</span></h2><p>TCP最大可以从缓存中取出来并放入报文段中的数量受限于最大报文段长度（MSS maxium segment size）最初确定的由本地发送主机的最大链路帧长度（最大传输单元 maximum Transmission union）MTU一般为1500字节，MSS典型值为1460字节，TCP/IP首部长度一般占40字节。</p>
<h2><span id="9-tcp报文段结构">9 TCP报文段结构</span></h2><p>TCP首部一般占20字节</p>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/TCP%E6%8A%A5%E6%96%87.png"></p>
<p>包括</p>
<ul>
<li>源端口号，目的端口号</li>
<li>32比特序号字段，32比特确认号字段，实现<strong>可靠数据传输服务。</strong><ul>
<li>序号：序号建立在传送字节流上，序号就是该报文段首个字节编号。</li>
<li>确认号：主机A填写的确认号是主机A希望从主机B收到的确认号。</li>
</ul>
</li>
<li>16比特接收窗口字段，<strong>用于流量控制</strong>。指示接收方愿意接受的字节数量</li>
<li>4比特<strong>首部长度</strong>字段，<strong>选择字段</strong>，协商最大报文长度MSS，或者在告诉网络环境下做窗口调节因子使用。</li>
<li>接收窗口字段，发送字节还剩下多少空间</li>
<li>6比特<strong>标志字段</strong>，ACK用于指示确认字段中的值是有效的，即该报文包括一个对已被成功接收报文段的确认。RST,SYN和FIN分别用于连接建立和拆除。PSH被设置代表接收方应立即将数据报传输给上层。URG用来指示报文段中存在着被发送端上层实体设置为紧急的任务。紧急数据由最后的紧急数据指针字段指出。</li>
</ul>
<h2><span id="10-流量控制服务和拥塞控制的区别">10 流量控制服务和拥塞控制的区别</span></h2><p>TCP接收正确、按序到达的字节后，直接放入接收缓存。相关进程会从当前缓存读取数据，但是<strong>不一定是立即读取</strong>。接收方应用或许在忙其他方面的业务，如果发送方读取数据缓慢，就会很容易的使该连接接受缓存溢出。</p>
<ul>
<li><p><strong>流量控制服务</strong>：消除发送方使接收方缓存溢出的可能性。流量控制因此是一个速度匹配的服务，即发送方的发送速率和接受方应用程序的读取速率相匹配。</p>
<ul>
<li><p>让发送方维护一个称为<strong>接受窗口</strong>（rwnd Recieve window）的变量来提供流量控制。接受窗口用于给发送方一个提示——该接收方窗口还有多少可用的空间。<strong>发送方控制发送出去的字节数小于接受窗口的大小。</strong></p>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3.png"></p>
</li>
<li><p>小问题：发送方维护的rwnd为0。接收方清空缓存，但是并不向发送方发送带有新值的rwnd段。解决当主机B的接收窗口为0的时候，主机A继续发送只有一个字节的数据报段，这样B就可以返回非零的rwnd的值。</p>
</li>
</ul>
</li>
</ul>
<p><strong>拥塞控制</strong>：TCP发送方有可能因为IP网络的拥塞而被抑制：这种形式的发送方控制叫做拥塞控制。</p>
<h2><span id="11-简述一下tcp的三次握手四次挥手">11 简述一下TCP的三次握手四次挥手</span></h2><p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/%E6%8F%A1%E6%89%8B.png"></p>
<ul>
<li>握手  （确认号是我想要接受的序号）</li>
</ul>
<p>1：客户算将报文段首部SYN标志位设置为1,随机生成序号seq = x，发送给服务器,客户端进入Client_sent状态。</p>
<p>2:服务器接收到包含SYN=1的数据包知道了客户端要建立请求连接，客户端将标志位SYN和ACK都置为1,将<strong>确认号</strong>置为x+1,随机生成一个序号seq=y,将数据包发回客户端确认连接请求，服务器进入SYN_recieved状态。</p>
<p>3 客户端收到数据包检查接受的确认号是否为x+1，ACK是否为1 ，如果正确将确认号设置为y+1发送给服务器，服务器检查确认号是否为y+1，ack是否为1，如果是则建立连接成功，客户端和服务器进入established状态，可以互相发送数据了。</p>
<ul>
<li>挥手</li>
</ul>
<p>TCP是全双工连接的，每一方都需要单独关闭，原则是发送FIN来终止任务，首先一方执行主动关闭，另一方执行被动关闭。</p>
<p>1 数据传输结束，客户端应用进行发出连接解释报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接受数据。</p>
<p>2 服务器接收FIN后，发送一个ACK给客户端，确认号为收到序号加1,服务器进入COLSE_WAIT状态，客户端进入FIN_WAIT2状态。</p>
<p>3 当客户端没有数据据要发送时，服务器向客户端发送一个FIN报文，此时服务器进入LAST_ACK状态。</p>
<p>4 客户端接收到服务器的报文FIN之后，给服务器发送一个ACK报文，确认序号是收到序号+1.此时客户端进入TIME_WAIT状态，等待一段时间（报文最大生存时间）关闭连接。</p>
<h3><span id="为什么是3次握手">为什么是3次握手</span></h3><ul>
<li>为了实现可靠数据传输， <strong>TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。</strong> 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤<br><strong>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</strong></li>
</ul>
<ul>
<li><p><strong>防止本来因该失效的连接请求报文有突然回到服务器端造成服务器的浪费。</strong>例如，客户端发送一个SYN，由于网络堵塞，服务器并没有收到这个数据包。然后客户端有重新传了这个SYN数据报并且正确建立TCP连接了，传送完数据，关闭了TCP连接。这是之前发送的SYN数据包来到服务器，服务器发出应答报文段。如果没采用三次握手连接，此时服务器发送应答报文段表示已经建立起了连接，一直等着发送数据。因为客户端没有发起新的请求，会丢弃服务器的SYN。此时服务器会一直等待客户端发送数据而造成 资源的浪费。</p>
</li>
<li><p>SYN洪泛攻击</p>
</li>
</ul>
<h3><span id="为什么是4次挥手">为什么是4次挥手</span></h3><p>为了能够保证数据完成传输，当关闭连接时，当收到FIN报文通知的时候，它仅仅表示对方没有数据发送给你了;但是你的数据未必全部发送给了对方，所以你可以不立刻关闭SOCKET，你还可以继续传输数据给对方。你发送FIN给对方表示你同意可以关闭连接了，所以这里的FIN和ACK都是分开发送的。</p>
<h2><span id="12-请你说说传递到ip层怎么知道报文该给哪个应用程序它怎么区分udp报文还是tcp报文">12 请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文</span></h2><p>根据端口区分；</p>
<p>看ip头中的协议标识字段，17是udp，6是tcp</p>
<h2><span id="13-tcp拥塞机制">13 TCP拥塞机制</span></h2><p>主要是下面四种机制</p>
<ul>
<li>慢开始<ul>
<li>慢开始指的是TCP开始发送设置拥塞窗口cwnd=1。不要一开始就发送大量数据，先探测一下网络的拥塞程度，经过一个轮次的传输，拥塞窗口cwnd加倍。当cwnd超过慢开始门限，则使用拥塞避免算法，防止cwnd增长过大。</li>
</ul>
</li>
<li>拥塞避免<ul>
<li>每经过一个RTT时间按，cwnd就增长1。</li>
<li>在慢开始和拥塞避免的过程中一旦发现网络拥塞，就把慢开始门限设置为当前cwnd的一半，重新设置cwnd为1</li>
</ul>
</li>
<li>快重传<ul>
<li>接收方每次接收到一个失序的报文段之后就应该立即发出重复确认，发送方只要连续次收到三个重复确认就立即重传。</li>
</ul>
</li>
<li>快速回复<ul>
<li>当发送方接受到三个连续的重复确认时，就是型乘法减小算法，把慢开始门限设置当前cwnd的一半一，将cwnd设置为慢开始门限大小，执行拥塞避免算法。</li>
</ul>
</li>
</ul>
<h2><span id="14-udp-中一个包的大小最大能多大">14 UDP 中一个包的大小最大能多大</span></h2><ol>
<li>以太网(Ethernet)数据帧的长度必须在 46-1500 字节之间,这是由以太网的物理特性<br>决定的.这个 1500 字节被称为链路层的 MTU(最大传输单元).但这并不是指链路层的长度<br>被限制在 1500 字节,其实这这个 MTU 指的是链路层的数据区.</li>
<li>并不包括链路层的首部和尾部的 18 个字节.所以,事实上,这个 1500 字节就是网络层<br>IP 数据报的长度限制.因为 IP 数据报的首部为 20 字节,所以 IP 数据报的数据区长度最大为<br>1480 字节.</li>
<li>而这个 1480 字节就是用来放 TCP 传来的 TCP 报文段或 UDP 传来的 UDP 数据报的.<br>又因为 UDP 数据报的首部 8 字节,所以 UDP 数据报的数据区最大长度为 1472 字节.这个1472 字节就是我们可以使用的字节数。</li>
</ol>
<h2><span id="15-tcp粘包">15 TCP粘包</span></h2><p>发送端为了将多个发往接收端的包,更有效的发到对方,使用了优化方法<br>(Nagle 算法),将多次间隔较小、数据量小的数据,合并成一个大的数据块,<br>然后进行封包。这样,接收端,就难于分辨出来了,必须提供科学的拆包机制。</p>
<p><strong>TCP 粘包</strong> 是指发送方发送的若干包数据到接收方接收时粘成一包,从接收缓冲区看,后一包数据的头紧接着前一包数据的尾;</p>
<p><strong>发送方原因</strong><br>我们知道,TCP 默认会使用 Nagle 算法。而 Nagle 算法主要做两件事:1)只<br>有上一个分组得到确认,才会发送下一个分组;2)收集多个小分组,在一个确<br>认到来时一起发送。所以,正是 Nagle 算法造成了发送方有可能造成粘包现象。</p>
<p><strong>接收方原因</strong></p>
<p>TCP 接收到分组时,并不会立刻送至应用层处理,或者说,应用层并不一定会立即处理;实际上,T<strong>CP 将收到的分组保存至接收缓存里,然后应用程序主动从缓</strong><br><strong>存里读收到的分组。</strong>这样一来,如果 TCP 接收分组的速度大于应用程序读分组的速度,多个包就会被存至缓存,应用程序读时,就会读到多个首尾相接粘到一起的包。</p>
<ol start="4">
<li>解决方法<br>1 发送方<br>对于发送方造成的粘包现象,我们可以通过关闭 Nagle 算法来解决,使用TCP_NODELAY 选项来关闭 Nagle 算法。<br>2<br>接收方</li>
</ol>
<p>遗憾的是 TCP 并没有处理接收方粘包现象的机制,我们只能在应用层进行<br>处理。<br>3<br>应用层处理<br>应用层的处理简单易行!并且不仅可以解决接收方造成的粘包问题,还能解决发送方造成的粘包问题。</p>
<p>比如我们进行一个规定，发送每条数据的时候加上独有的<strong>开始符和截至符号</strong>。这种方法简单可行，就是要保证每条数据内不包含截至符号和开始符号。另一种，<strong>就是将将数据的长度一并发送</strong>，例如规定数据的前四个是数据的长度，应用层可以根据数据来判断每个分组的起始位置和结束位置。</p>
<h2><span id="151-udp会粘包吗">15.1 UDP会粘包吗</span></h2><p>UDP不会发生粘包。接收是面向消息传输的，接收方一次智能接受一个消息，所以不存在粘包问题。</p>
<p>举个例子：有三个数据包，大小为2k,4k,6k，如果我才用UDP发送的话，不管接收方的缓存有多大，我们至少进行三次以上的发送才能将数据包发送完，那么TCP协议发送的话，只需要发送方的接受缓存有12k大小，就可以一次性把这三个数据包一次性的发送完毕。</p>
<h2><span id="16-tcp有几大定时器">16 TCP有几大定时器</span></h2><ul>
<li>重传计时器<ul>
<li>在一个TCP连接中，TCP没发送一个报文段，就对此报文段设置一个超时重传计时器。若该计时器截至期到了还没有收到应答报文，则重传此报文段，并将计时器复位。</li>
</ul>
</li>
<li>持续计时器<ul>
<li>为了应对，零窗口大小通知rwnd = 0;假定服务器发送报文段，我的接收窗口为0.那么客户端就停止发送数据，直到客户端接收到一个服务器发送过来接收窗口部不为零的报文段。若这个报文段传输过程中丢了。双方定时器都会永远等着对方发送数据。为了打破这种死锁，TCP为每一个连接使用一个持续计时器，当发送方将诶收到一个<strong>窗口大小为0</strong>的确认时，就启动持续计时器。当持续定时器到时间了，发送方就发送一个特殊的报文段，叫探测报文段。这个报文段只有一个字节的数据，特有一个序号，但是他的序号不需要被确认。探测报文段提醒对端若是发生丢失，必须重传。</li>
</ul>
</li>
<li>保活计时器<ul>
<li>防止两个TCP连接之间出现长时间的空闲。假定客户打开了到服务器的连接，传送一些数据，然后就保持静默了，。在这个情况下，这个连接就永远处于打开状态。</li>
</ul>
</li>
<li>时间等待计时器<ul>
<li>在终止其间使用的。当TCP关闭一个连接时候，他不认为这个连接就真正的关闭了。在时间等待其间中，连接还处于一种中间过度状态。客户端对服务器的FIN报文段，发送ACK后进行确认后进入TIME_WAIT状态。假定ACK丢失，TIME_WAIT状态使得客户端重传最都的确认报文。经过等待后，连接正式关闭，客户端 所有资源被释放。</li>
</ul>
</li>
</ul>
<h2><span id="网络层">网络层</span></h2><h2><span id="17-如何理解不可靠和无连接">17 如何理解不可靠和无连接</span></h2><p>不可靠：指的是不能保证数据报成功的到达目的地。</p>
<p>发生错误的时候，丢弃该数据报包，发送ICMP消息给信源端。可靠性由上层提供。</p>
<p>无连接：IP不维护后续数据报的的状态信息。</p>
<p>IP数据可以不安顺序发送和接收。A发送连续的数据报。达到B不一定是连续的，来回的路由选择也可能不一样。路线不一样，达到的先后顺序也不一样。</p>
<h2><span id="18-ip报文的格式和各个字段的含义">18 IP报文的格式和各个字段的含义</span></h2><p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/IPv4.png"></p>
<ul>
<li><p>版本号：IPV4就是4,ipv6就是6.（4）</p>
</li>
<li><p>首部长度：IPV4可以包含一些可变参数选项，说一需要一个参数指示数据部分从哪里开始，一般IP4数据报具有20个字节的首部。（4）</p>
</li>
<li><p>服务类型：不常用(8)</p>
</li>
<li><p>数据报长度：这个IP数据报的总长度，最多可以传送65535字节的IP数据包。一般不超过1500字节。（16）</p>
</li>
<li><p>标识（16） 、标志（3）、片偏移（13）：这三个字段与所谓IP分片有关。</p>
</li>
<li><p>生存时间TTL:经过一个路由器减1。字段为0时，数据报被丢弃，并且发送ICMP报文通知源主机。（8）</p>
</li>
<li><p>协议：区分上层协议（8）</p>
</li>
<li><p>首部校验和：将首部字段和的反码存入该字段(16)</p>
</li>
<li><p>源和目的IP地址(64)</p>
</li>
<li><p>选项：平常用不到</p>
</li>
</ul>
<h2><span id="19-介绍一下ip分片">19 介绍一下IP分片</span></h2><p>IP之所以分片是因为。不是所有链路层都能承载相同长度的网络分组。例如，以太网帧能承载不超过1500字节的数据。而某些广域网链路智能承载不超过576字节的数据。一个链路能承载的最大数据量叫做最大传输单元（Maxmium Transmission Unit）。每种链路可能采用不同的链路层协议，每种协议可能有不同的MTU。</p>
<p>假如在传输的过程中，收到的IP数据报字节数比我要转发出去的那条链路的MTU还要大，这个时候就需要将IP进行分解，逐个传输。</p>
<p>标识：数据报被拆分称片后具有相同的标识。</p>
<p>标志：最后一个片的标志为0,前边的为1。</p>
<p>偏移：偏移指示该片应该放到初始IP分组的哪个位置。8字节为单位</p>
<h2><span id="20-子网掩码有什么用">20 子网掩码有什么用？</span></h2><p>子网掩码是一种用来指明一个IP地址所标示的主机处于哪个子网当中，子网掩码不能单独存在，它还必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络部分和主机部分。使得路由更方便，先到达子网，在确定是哪个主机。</p>
<h2><span id="21-子网掩码的类型">21 子网掩码的类型</span></h2><p>因特网地址分配策略为<strong>无类别区间路由选择</strong>（CIDR）。寻址将子网哪个寻址的概念一般化了。对于组网寻址。32比特的IP地址划分成两部分，并且也具有点分十进制格式a.b.c.d/x。x最高比特构成IP地址中的网络部分，在外部路由仅仅需要考虑前x个比特。</p>
<p>具有8,16,24比特子网地址的子网哪个称为A，B,C类地址，能容纳2^24个地址。B类可容纳65534台主机。C类可容纳254台主机。</p>
<h2><span id="22-ip首部校验和是怎么计算的">22 IP首部校验和是怎么计算的</span></h2><p>与ICMP，IGMP，TCP,UDP的首部校验和有什么区别与共同点。</p>
<p>(1) 先把校验和字段置 0。<br>(2) 对首部中每个 16 位比特进行二进制反码求和。<br>(3) 结果存在检验和字段中。<br>(4) 收到一份 IP 数据包后,同样对首部中每个 16bit 二进制反码求和。<br>(5) 最后结果全为 1,表示正确,否则表示错误。<br>(6) 如果是错误的,IP 就丢弃该数据报,但是不生成差错报文,由上层去处理。<br>共同点:用到的算法都是一样的。<br>区别**:IP 计算的时候没有将数据包括在内。**<br>ICMP,IGMP,TCP,UDP 同时覆盖首部和数据检验码。</p>
<h2><span id="23-rip路由协议因特网自治系统内部路由选择">23 RIP路由协议（因特网自治系统内部路由选择）</span></h2><p>弗洛伊德算法</p>
<p>1 网络中的每一个路由器都要维护他自己到其他每一个目标网络的间距离记录</p>
<p>2 距离又称跳数，规定从一个路由器直接连接的网络跳数为1,而且每经过一个路由器，则距离加一。</p>
<p>3 RIP认为好的路由就是通过的路由器最少;</p>
<p>4 RIP默认一条路径上最多有15个路由器，因此规定最大跳数是16;</p>
<p>5 RIP默认每30秒广播一次RIP更新信息。</p>
<p>每个路由器包括三个内容：目的网络、距离、下一跳路由器。</p>
<p>1、对地址为 X 的路由器发过来的路由表 ,先修改此路由表中的所有项目:把 ” 下一<br>跳 ” 字段中的地址改为 X ,并把所有 ” 距离 ” 字段都加 1。<br>2、对修改后的路由表中的每一个项目,进行以下步骤:<br>2.1、将 X 的路由表(修改过的),与 S 的路由表的目的网络进行对比。<br>若在 X 中出现,在 S 中没出现,则将 X 路由表中的这一条项目添加到 S 的路由表<br>中。<br>2.2、对于目的网络在 S 和 X 路由表中都有的项目进行下面步骤<br>2.2.1、在 S 的路由表中,若下一跳地址是 x<br>则直接用 X 路由表中这条项目替换 S 路由表中的项目。<br>2.2.2、在 S 的路由表中,若下一跳地址不是 x<br>若 X 路由表项目中的距离 d 小于 S 路由表中的距离,则进行更新。<br>3、若 3 分钟还没有收到相邻路由器的更新表,则把此相邻路由器记为不可到达路由器,即把距离设置为 16。</p>
<h2><span id="24-自治系统间的路由选择bgp">24 自治系统间的路由选择BGP</span></h2><h2><span id="25-icmp报文的分类">25 ICMP报文的分类</span></h2><p>ICMP的层次和作用</p>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/ICMP.png"></p>
<p>UDP端口不可达到例子中返回的ICMP报文</p>
<p>ICMP一般被认为是IP的一部分。从体系结构上位于IP之上，ICMP报文是承载在IP分组中的。主要传递差错报文和其他要注意的信息。</p>
<p>ICMP报文的分类</p>
<p>ICMP分为两类ICMP查询报文，另一类是ICMP差错报文</p>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/ICMP%E5%88%86%E7%B1%BB.png"></p>
<p>终点不可达什么情况下发出</p>
<p>路由器给主机寻路时，没有找到相应路径，向源IP发回ICMP主机不可达</p>
<p>什么情况下不会产生ICMP差错报文？</p>
<p>目的地址是广播地址或者多播地址的IP数据报</p>
<p>链路广播的数据报</p>
<p>不是IP分片的第一片</p>
<p>源地址不是单个主机的数据报</p>
<p>ICMP 重定向差错报文是怎么来的,在何种场合出现?</p>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/%E9%87%8D%E5%AE%9A%E5%90%91ICMP.png"></p>
<p>1 主机发送IP数据报给R1,因为主机默认路由指向的下一跳是R1。</p>
<p>2 R1收到数据报检查他的路由表。发现下一跳是R2。当它把数据报发送给R2的时候，发现发送接口与接收该数据报的端口是一样的，因此发送一个ICMP重定向报文给主机。</p>
<p>3 主机接收到ICMP重定向报文，接下来将数据报直接发送给R2，不再发送给R1</p>
<p>重定向报文只能是路由器生成，给主机使用。</p>
<h2><span id="26-为什么要有mac地址">26 为什么要有MAC地址</span></h2><p>事实上并不是所有的主机或者路由器具有链路层地址，而是他们的适配器（网络接口）具有链路层地址。。因此就会有多个网络接口的主机或者路由器将具有多个链路层地址，也就像他具有与之相关联的IP地址一样。</p>
<p><strong>局域网设计是为任意的网络层协议而设计的，而不只是用于IP和因特网。如果适配器指派的是IP地址而不是MAC地址，则适配器不能方便的支持其他的网络层协议。其次网络层地址必须存储在RAM中，在每次适配器移动的时候要从新配置。用MAC地址和IP地址两个地址，用于分别表示物理地址和逻辑地址是有好处的。这样分层可以使网络层与链路层的协议更灵活地替换，网络层不一定非要用『IP』协议，链路层也不一定非用『以太网』协议。</strong></p>
<h2><span id="27-arp协议">27 ARP协议</span></h2><p><strong>ARP为IP地址得到对应的硬件地址提供动态映射</strong></p>
<p>ARP只能为同一个子网上的主机和路由器解析IP地址。</p>
<p>ARP(地址解析协议)，当主机要发送一个IP包的时候，会先查自己的ARP高速缓存表，如果查询的IP-MAC的值不存在，主机向网络广播一个ARP请求，这个包里有等待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那就回应一个ARP应答包，源主机拿到ARP应答包后会更新自己的ARP缓存表。源主机根据ARP缓存表准备好数据链路层的数据报发送工作。</p>
<p>点对点链路使用ARP吗？</p>
<p>不使用</p>
<p>ARP高效运行的关键是什么？</p>
<p>关键是每个主机都有一个ARP的告诉缓存。</p>
<p>ARP的各个字段及含义？</p>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/ARP.png"></p>
<p>帧类型:ARP:0x0806 (2)<br>ARP 首部:<br>硬件类型:硬件地址的类型,1 表示以太网地址。(2)<br>协议类型:协议地址的类型,0x0800 表示 IP 地址。(2)<br>硬件地址长度:字节为单位 6 (1)<br>协议地址长度:字节为单位 4 (1)<br>操作类型:2 个字节。 ARP 请求 1,ARP 回复 2,RARP 请求 3,RARP 应答 4。(2)<br>发送者硬件地址:6 个字节(6)<br>发送者 IP 地址:4 个字节(4)<br>目标硬件地址:6 个字节(6)<br>目标 IP 地址:4 个字节(4)<br>CRC 校验:4 个字节 (4)</p>
<p>总结:<br>arp 总共 28 个字节。<br>记忆方法: 以太网先目地后源,ARP 先发送端后目地端。先硬件后协议</p>
<p>ARP协议有什么缺点？</p>
<p>1 缓存：主机的地址映射是基于高速缓存的，动态更新的。地址刷新是有时间限制的。以通过次更新之前修改计算机上的地址缓存，造成拒绝服务攻击或者ARP欺骗。</p>
<p>2 广播：可以伪装成ARP应答</p>
<p>3ARP应答没有认证，都是合法的。可以在不接受到请求的时候发出应答包。</p>
<p>ARP代理的概念？</p>
<p>若ARP请求是一个网络主机发送到另一个网络上的主机。那么连接这两个网络的路由器就可以回答该请求，这个过程叫做ARP代理。ARP代理路由器响应ARP请求的MAC地址为路由器的MAC地址而非ARP请求主机的MAC地址。</p>
<p>28 数据链路层MTU的最大值和最小值分别为多少？</p>
<p>1 数据链路层的最小MTU为64字节。最大为1500字节</p>
<p>　要保证以太网的重传，<strong>必须保证A收到碰撞信号的时候，数据包没有传完</strong>，要实现这一要求，A和B之间的距离很关键，也就是说信号在A和B之间传输的来回时间必须控制在一定范围之内。IEEE定义了这个标准，一个碰撞域内，<strong>最远的两台机器之间的round-trip time 要小于512bit time</strong>.(来回时间小于512位时，所谓位时就是传输一个比特需要的时间）。</p>
<p>对于 IEEE802.3,两个站点的最远距离不超过 2500m,<br>由 4 个中继器连接而成,其冲突窗口为 51.2us(2 倍电缆传播延迟加上 4 个中继器的双向延<br>迟).对于 10Mbps 的 IEEE802.3 来说,这个时间等于发送 64 字节,即 512 位的时间,64 字<br>节就是由此而来的。如果一个站点已经传输了 512bit,就认为它已经占用了这个信道。</p>
<h2><span id="28知道各个层使用的是哪个数据交换设备">28:知道各个层使用的是哪个数据交换设备。</span></h2><p>(交换机、路由器、网关)</p>
<p>网关：应用层，传输层（网关在传输层以上实现网络互联，是最复杂的网络互联设备，仅仅用于两个高层协议不同的网络互联。）</p>
<p>路由器:网络层（路由选择，存储转发）</p>
<p>交换机：数据链路层、网络层（识别数据包的MAC地址信息，根据MAC地址进行转发，并将这些地址与相应的端口记录在一个表中）</p>
<p>网桥：数据链路层，两个LAN连接起来，根据MAC转发</p>
<p>集线器：物理层设备（主要用来连接计算机等网络终端）</p>
<p>中继器：物理层，在比特级对网络信号进行再生和重定时，使得他们能够在网络上传输更长的距离。</p>
<h2><span id="29-web页面请求过程">29 Web页面请求过程</span></h2><p>1 DHCP配置主机信息</p>
<ul>
<li>假设最开始主机没有IP地址以及其他信息，那么就需要先使用DHCP来获取。</li>
<li>主机生成一个DHCP请求报文，并把这个报文放入具有目的端口67和源端口68的UDP报文段中。</li>
<li>该报文段被放置在一个具有广播IP目的地址（255.255.255.255）和源IP地址（0.0.0.0）的IP数据报中。</li>
<li>该数据报则被放置在MAC帧中，该帧具有目的地址FF:FF:FF:FF:FF:FF中，将广播到与交换机连接的所有设备。</li>
<li>连接在交换机的DHCP服务器收到广播帧之后，不断向上分解得到IP数据报，UDP报文段，DHCP请求报文，之后生成DHCP ACK报文，该报文含有以下信息：<strong>IP地址，DNS服务器的IP地址、默认网关路由器的IP地址和子网掩码。</strong>该报文被放入在UDP报文段中，UDP报文段被放入IP数据报中，最后放入MAC帧。</li>
<li>该帧的目的治之是请求主机的MAC地址，因为交换解有自主学习能力，之前主机发送了广播帧之后就记录了MAC地址到其转发接口的交换表项，因此现在交换机就可以直到哪个接口发送该帧。</li>
<li>主机接受到该帧之后，不断分解得到DHCP报文。之后配置他的IP地址，子网掩码和DNS服务器的IP地址，并在其IP转发表中安装默认网关。</li>
</ul>
<p>2 ARP解析MAC地址</p>
<ul>
<li>主机通过fulani生成一个TCP套解字，套解字向HTTP服务器发送HTTP请求。为了生成该套解字，主机需要直到网站的域名对应的IP地址。</li>
<li>主机生成一个DNS查询报文，该报文具有53号端口，因为DNS服务器的端口号是53。</li>
<li>该IP数据报被放入一个以太网帧中，该帧发送网关到网关路由器。</li>
<li><strong>DHCP过程只知道网关路由器的IP地址，为了获取网关路由器的MAC地址，需要使用ARP协议。</strong></li>
<li>主机生成一个包含目的地址的网关路由器ARP查询报文，将该ARP查询报文放入一个具有广播目的地址（FF：FF：FF：FF：FF:FF）的以太网帧中，向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器 。</li>
<li>网关路由器接收到该帧之后，不断向上分解得到ARP回答报文，发现其中IP地址与接口的iP  地址相匹配，因此就发送一个ARP回答报文，包含了他的MAC地址，发回给主机。</li>
</ul>
<p>3 DNS解析域名</p>
<ul>
<li>知道了网关路由器的MAC地址之后，就可以继续DNS解析过程了。</li>
<li>网关路由器接收到包含DNS查询报文的以太网帧之后，抽取IP数据报，并根据转发表决定IP数据报应该转发的路由器。</li>
<li>因为路由器具有内部网关协议和外部网关协议这两种路由选择协议，因此路由表中已经配置了网关路由器到达DNS路由表项。</li>
<li>找到DNS记录后，发送DNS回答报文，将该回答报文放入UDP报文段中，然后放入IP数据报中，通过路由器反向转发回网关路由器，经过以太网交换机到达主机。</li>
</ul>
<p>4 http请求页面</p>
<ul>
<li>有了HTTP服务器的IP地址之后，主机就能生成TCP套接字，该套接字将用与向WEB服务器发送HTTP GET报文。</li>
<li>生成TCP套接字之前与HTTP服务器进行三次握手来建立连接。生成一个具有目的端口号80的TCP SYN报文段，并向HTTP服务器发送该报文。</li>
<li>HTTP服务器接收到该报文在之后，生成TCP SYN ACK报文段，发送给主机。</li>
<li>连接建立后，浏览器生成HTTPGET报文，并交付为HTTP服务器。</li>
<li>HTTP服务器从TCP套解字读取HTTP GET报文，生成一个HTTP响应报文，将WEB页面内容放入报文主体中，发送给主机。</li>
<li>浏览器接受到HTTP相应报文之后，抽取WEB页面内容，之后进行渲染，显示WEB页面。</li>
</ul>
<h2><span id="30-常用端口号">30  常用端口号</span></h2><p>FTP 21;TELNET 23;SMTP 25;DNS 53;HTTP 80;HTTPS 443</p>
<h2><span id="31-请你来说一下socket编程中服务器端和客户端主要用到哪些函数">31 请你来说一下socket编程中服务器端和客户端主要用到哪些函数</span></h2><p>1）基于TCP的socket：</p>
<p>1、服务器端程序：</p>
<p>1创建一个socket，用函数socket()</p>
<p>2绑定IP地址、端口等信息到socket上，用函数bind()</p>
<p>3开始监听，设定最大连接数用函数listen()</p>
<p>4接收客户端上来的连接，用函数accept()</p>
<p>5收发数据，用函数send()和recv()，或者read()和write()</p>
<p>6关闭网络连接</p>
<p>2、客户端程序：</p>
<p>1创建一个socket，用函数socket()</p>
<p>2设置要连接的对方的IP地址和端口等属性</p>
<p>3连接服务器，用函数connect()</p>
<p>4收发数据，用函数send()和recv()，或read()和write()</p>
<p>5关闭网络连接</p>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/TCPsocket.png"></p>
<p>2）基于UDP的socket：</p>
<p>1、服务器端流程</p>
<p>1建立套接字文件描述符，使用函数socket()，生成套接字文件描述符。</p>
<p>2设置服务器地址和侦听端口，初始化要绑定的网络地址结构。</p>
<p>3绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。</p>
<p>4接收客户端的数据，使用recvfrom()函数接收客户端的网络数据。</p>
<p>5向客户端发送数据，使用sendto()函数向服务器主机发送数据。</p>
<p>6关闭套接字，使用close()函数释放资源。UDP协议的客户端流程</p>
<p>2、客户端流程</p>
<p>1建立套接字文件描述符，socket()。</p>
<p>2设置服务器地址和端口，struct sockaddr。</p>
<p>3向服务器发送数据，sendto()。</p>
<p>4接收服务器的数据，recvfrom()。</p>
<p>5关闭套接字，close()。</p>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/socketUDP.png"></p>
<h2><span id="32-请你说说selectepoll的区别原理性能限制都说一说">32 请你说说select，epoll的区别，原理，性能，限制都说一说</span></h2><p><strong>IO多路复用出现的场景，是设计一个高性能的网络服务器，能够供多个客户端同时连接并处理客户端传上来的请求。</strong>首先想到的是可以利用<strong>多线程，但是多线程存在很大弊端，需要上下文切换，尤其是线程多的时候，线程切换耗费时间。</strong>考虑单线程的处理方式。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>Fdx <span class="token function">in</span> <span class="token punctuation">(</span>DdA<span class="token operator">-</span>FDE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>Fdx 有数据<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            读取Fdx<span class="token punctuation">;</span>处理
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>IO多路复用就是我们说的select，poll，epoll。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO<strong>。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</strong></p>
<p>当用户进程调用了select，那么整个进程会被block，而同时，<strong>kernel会“监视”所有select负责的socket</strong>，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，<strong>将数据从kernel拷贝到用户进程。</strong></p>
<p>所以，<strong>I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</strong></p>
<p>I/O多路复用和阻塞I/O其实并没有太大的不同，事实上，还更差一些。<strong>因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。</strong>但是，用select的优势在于它可以<strong>同时处理</strong>多个connection。</p>
<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于<strong>能处理更多的连接。</strong></p>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<h3><span id="1-select">1 select</span></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span>

sockfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>addr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
addr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
addr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> INADDR_ANY<span class="token punctuation">;</span>
<span class="token function">bind</span><span class="token punctuation">(</span>socketfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>addr<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//可以接受5个客户端的连接</span>
<span class="token function">listen</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>client<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    addrlen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// fds就是一个数，代表文件的编号，并不是按照顺序的</span>
    fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client<span class="token punctuation">,</span><span class="token operator">&amp;</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//求出文件描述符最大的元素</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span>
        max <span class="token operator">=</span> fd<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">FD_ZERO</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token comment">// rset数据结构为bitmap，默认1024位，在需要监听的位上置1</span>
        <span class="token function">FD_SET</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"round again"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 最大文件描述符号加1,读文件描述符，写文件描述符，异常文件描述符，阻塞时间</span>
    <span class="token function">select</span><span class="token punctuation">(</span>max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>rset<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token function">memset</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>MAXBUF<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//读fd</span>
            <span class="token function">read</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>buffer<span class="token punctuation">,</span>MAXBUF<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//处理</span>
            <span class="token function">puts</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/select.png"></p>
<p>select：是最初解决IO阻塞问题的方法。将文件描述符收集起来，用结构体fd_set来<strong>告诉内核监听多个文件描述符</strong>，该结构体被称为描述符集。由bitmap，默认1024位来维持哪些描述符被置位了。对结构体的操作封装在三个宏定义中。通过轮寻来查找是否有描述符要被处理。</p>
<p>当有数据来的时候select返回：1将相应的fd置位2将select返回</p>
<p>存在的问题：</p>
<ol>
<li><p>内置数组的形式使得select的最大文件数受限与FD_SIZE；</p>
</li>
<li><p><strong>每次调用select前都要重新初始化描述符集</strong>，将fd从用户态拷贝到内核态，每次调用select后，都需要将fd从内核态拷贝到用户态；</p>
</li>
<li><p>轮寻排查当文件描述符个数很多时O(n)，效率很低；</p>
</li>
<li><p>从用户态到内核态切换有开销</p>
</li>
</ol>
<h3><span id="2-poll">2 poll</span></h3><p>工作原理和select相似，将用户态的文件描述符拷贝到内核态，让内核态监听fd上的数据。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
<span class="token keyword">struct</span> <span class="token class-name">pollfd</span><span class="token punctuation">&#123;</span>
    <span class="token comment">//文件描述符</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
    <span class="token comment">//在意的事件</span>
    <span class="token keyword">short</span> events<span class="token punctuation">;</span>
    <span class="token comment">//一开始为0,</span>
    <span class="token keyword">short</span> revents<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>client<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    addrlen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// fds就是一个数，代表文件的编号，并不是按照顺序的</span>
    pollfds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client<span class="token punctuation">,</span><span class="token operator">&amp;</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//模式为输入</span>
    pollfds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> POLLIN<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"round again"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//pollfd的数组，将revent置位为1，数据来了</span>
    <span class="token function">poll</span><span class="token punctuation">(</span>pollfds<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>pollfds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLIN<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            pollfds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>revents<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token function">memset</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>MAXBUF<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">read</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>buffer<span class="token punctuation">,</span>MAXBUF<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">puts</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>通过一个可变长度的数组解决了select文件描述符受限的问题。</strong>数组中元素是结构体，该结构体保存描述符的信息。每增加一个文件描述符就向数组中加入一个结构体。</p>
<p><strong>poll解决了select重复初始化的问题。</strong>每次只要将结构体中的一位revent置位即可。</p>
<h3><span id="3-epoll">3 epoll</span></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> events<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> epfd <span class="token operator">=</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> epoll_event ev<span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>client<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    addrlen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>
    addrlen <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ev<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client<span class="token punctuation">,</span><span class="token operator">&amp;</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ev<span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN<span class="token punctuation">;</span>
    <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span>EPOLL_CTL_ADD<span class="token punctuation">,</span>ev<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token punctuation">.</span><span class="token operator">&amp;</span>ev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"round again"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    nfds <span class="token operator">=</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span>events<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>nfds<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token function">memset</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>MAXBUF<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">read</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>buffer<span class="token punctuation">,</span>MAXBUF<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">puts</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/epoll.png"></p>
<p><strong>节省了数据结构从用户态到内核态的开销</strong></p>
<p>有数据：1“置为”（重排），有数据的fd重排到epfd的最前   2返回相应有数据fd的个数</p>
<p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式</p>
<ol>
<li>LT模式</li>
</ol>
<p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket**.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。**</p>
<ol start="2">
<li>ET模式</li>
</ol>
<p>ET(edge-triggered)是高速工作方式，只支持no-block socket。<strong>在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，</strong>直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>
<p><strong>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高</strong>。epoll工作在ET模式的时候，必须使用<strong>非阻塞套接口</strong>，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<p>3、LT模式与ET模式的区别如下：<br>LT模式：当epoll_wait<strong>检测到描述符事件发生</strong>并将此事件通知应用程序，<strong>应用程序可以不立即处理该事件</strong>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<strong>应用程序必须立即处理该事件</strong>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<h2><span id="33-请你回答一下epoll怎么实现的">33  请你回答一下epoll怎么实现的</span></h2><p>Linux epoll机制是通过<strong>红黑树和双向链表实现</strong>的。 首先通过epoll_create()系统调用在内核中创建一个eventpoll类型的句柄，其中包括红黑树根节点和双向链表头节点。然后通过epoll_ctl()系统调用，向epoll对象的红黑树结构中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。最后通过epoll_wait()系统调用判断双向链表是否为空，如果为空则阻塞。<strong>当文件描述符状态改变，fd上的回调函数被调用，该函数将fd加入到双向链表中</strong>，此时epoll_wait函数被唤醒，返回就绪好的事件。</p>
<p>int epoll_create(int size);</p>
<p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</p>
<p>int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);</p>
<p>首先创建一个epoll对象，然后使用epoll_ctl对这个对象进行操作，把需要监控的描述添加进去，这些描述如将会以epoll_event结构体的形式组成一颗红黑树，接着阻塞在epoll_wait，进入大循环，当某个fd上有事件发生时，内核将会把其对应的结构体放入到一个链表中，返回有事件发生的链表。</p>
<h2><span id="34-tcp-syn洪泛攻击的防御">34 TCP SYN洪泛攻击的防御</span></h2><p>SYN洪泛攻击的基础是依靠TCP建立连接时三次握手的设计。第三个数据包验证连接发起人在第一次请求中使用的源IP地址上具有接受数据包的能力，即其返回是可达的。</p>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/%E6%B4%AA%E6%B3%9B%E6%94%BB%E5%87%BB1.png"></p>
<p>TCB(<strong>TCP 传输控制块)是一种包含一个连接所有信息的传输协议数据结构</strong>(实际上在许多操作系统中它是用于处理进站(inbound)连接请求的一个队列,该队列保存那些处于半开放(half-open)状态的TCP连接项目，和已建立完整连接但仍未由应用程序通过accept()调用提取的项目)。一个单一的TCB所占内存大小取决于连接中所用的TCP选项和其他一些功能的实现。<strong>通常一个TCB至少280字节</strong>，在某些操作系统中已经超过了1300字节。TCP的SYN-RECEIVED状态用于指出这个连接仅仅是半开连接，请求是否合法仍被质疑。这里值得注意的一个重要方面就是<strong>TCB分配空间的大小取决于接收的SYN包</strong>——在连接被完全建立或者说连接发起人的返回可达性被证实之前。</p>
<p>这就导致了一个明显潜在的DoS(拒绝服务)攻击，到达的SYN包将被分配过多的TCB而导致主机的内核内存被耗尽。为了避免这种内存耗尽，操作系统通常<strong>给监听接口关联了一个”backlog”队列参数，它同时维护连接的TCB上限数量和SYN-RECEIVED状态。</strong>尽管这种方案使主机的可用内存免遭攻击，但是backlog队列本身就带来了一个(小的)受攻击源。<strong>当backlog中没有空间时，就不可能再响应新的连接请求</strong>，除非TCB能被回收或者从SYN-RECIEVE状态中移除。</p>
<p>试图发送足够多的SYN包而耗尽backlog是TCP SYN洪泛的目的。攻击者在SYN包中加入源IP地址，这样就不会导致主机将已分配的TCB从SYN-RECEVIED状态队列中移除(因为主机将响应SYN-ACK)。<strong>因为TCP是可靠的，目的主机在断开半开连接并在SYN-RECIEVED队列中移除TCB之前将等待相当长的时间。</strong>在此期间，服务器将不能响应其他应用程序合法的新TCP连接请求。</p>
<h3><span id="攻击类型">攻击类型</span></h3><p>1 直接攻击</p>
<p><strong>如果攻击者用他们自己的没有经过伪装的IP地址快速地发送SYN数据包，这就是所谓的直接攻击。</strong>这种攻击非常容易实现，因为它并不涉及攻击者操作系统用户层以下的欺骗或修改数据包。例如，他可以简单地发送很多的TCP连接请求来实现这种攻击。然而，这种攻击要想奏效攻击者还必须阻止他的系统响应SYN-ACK包，因为任何ACK、RST或ICMP(Internet Control Message Protocol)包都将让服务器跳过SYN-RECEIVED状态(进入下一个状态)而移除TCB(因为连接已经建立成功或被回收了)。<strong>攻击者可以通过设置防火墙规则来实现，让防火墙阻止一切要到达服务器的数据包(SYN除外)，或者让防火墙阻止一切进来的包来使SYN-ACK包在到达本地TCP处理程序之前就被丢弃了。</strong></p>
<p>一旦被检测到，这种攻击非常容易抵御，用一个简单的防火墙规则<strong>阻止带有攻击者IP地址的数据包</strong>就可以了。这种方法在如今的防火墙软件中通常都是自动执行的。</p>
<p>2 欺骗式攻击</p>
<p>SYN洪泛攻击的另一种方式是IP地址欺骗。它比直接攻击方式更复杂一点，<strong>攻击者还必须能够用有效的IP和TCP报文头去替换和重新生成原始IP报文</strong>。如今，有很多代码库能够帮助攻击者替换和重新生成原始IP报文。</p>
<p>对于欺骗式攻击，首先需要考虑的就是选择地址。要使攻击成功，位<strong>于伪装IP地址上的主机必须不能响应任何发送给它们的SYN-ACK包</strong>。攻击者可以用的一个非常简单的方法，就是仅需伪装一个源IP地址，而这个IP地址将不能响应SYN-ACK包，或许因为这个IP地址上根本就没有主机，或许因为对主机的地址或网络属性进行了某些配置。另一种选择是伪装许多源地址，攻击者会假想其中的一些伪装地址上的主机将不会响应SYN-ACK包。要实现这种方法就需要循环使用服务器希望连接的源IP地址列表上的地址，或者对一个子网内主机做相同的修改。</p>
<p>如果一个源地址被重复地伪装，这个地址将很快被检测出来并被过滤掉。在大多数情况下运用许多不同源地址伪装将使防御变得更加困难。在这种情况下最好的防御方法就<strong>是尽可能地阻塞源地址相近的欺骗数据包</strong>。</p>
<p>假设攻击者是在一个“互联”的网络中(例如一个自治系统(Autonomous System))，<strong>由其ISP限制攻击者所在网络流量的输入输出过滤将能够制止这种欺骗攻击</strong>——如果这种方法能被机构部署到正确位置的话。这种流量输入输出过滤的防御方式将限制一些合法的通信，比如移动IP三角路由运作模式，因此不可能被普遍部署。IP安全协议(IPsec)同样也提供了一种抵御欺骗包的优秀方式，但是这协议因为部署限制还不能被使用。由于对于服务器方通常不可能要求链接发起人的ISP去实施地址过滤或者要求其使用IP安全协议，因此抵御这种用多地址伪装的欺骗攻击还需要更加复杂的解决方案，将在后文讨论到。</p>
<p>3 分布式攻击</p>
<p>对于单个运用欺骗式攻击的攻击者真正的限制因素是如果这些伪装数据包能够以某种方式被回溯到其真正的地址，攻击者将被简单地击败。尽管回溯过程需要一些时间和ISP之间的配合，但它并不是不可能的。但<strong>是攻击者运用在网络中主机数量上的优势而发动的分布式SYN洪泛攻击将更加难以被阻止。</strong>如图所示，这些主机群可以用直接攻击，也可以更进一步让每台主机都运用欺骗攻击。</p>
<p>如今，分布式攻击才是真正可行的，因为罪犯拥有数以千计的主机供他来进行拒绝服务(DoS)攻击。由于这些大量的主机能够不断地增加或减少，而且能够改变他们的IP地址和其连接，因此要阻止这类攻击目前还是一个挑战。</p>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/SYN%E6%94%BB%E5%87%BB2.png"></p>
<h3><span id="对策">对策</span></h3><ul>
<li>增加TCP backlog队列</li>
</ul>
<p>由于其基本攻击原理是依赖于终端主机连接套接字的backlog溢出，因此一个显然的基于终端主机的解决方案是增加backlog队列大小，而且这种方法已经广泛的运用于大多数服务器了。增加backlog队列通常是通过修改应用的listen()函数调用和一个操作系统内核参数SOMAXCONN——它用于设置一个应用程序能够接收的backlog上限值。这种方法本身并不能被完全认为是抵御SYN洪泛的有效方法，即使在一些能够有效支持超大backlog队列分配的操作系统中，因为攻击者能够任意生成比其操作系统支持的backlog还大得多的数据报。</p>
<ul>
<li>减少SYN-RECEIVED的时间</li>
</ul>
<p>管理员减少SYN-RECEIVED状态时间多少和攻击者的发包率之间仅仅是一个线性关系而已。基于上述原因，此方案并不建议采用。</p>
<ul>
<li><strong>设置SYN cookie</strong> </li>
</ul>
<p>对比SYN缓存的方法，SYN Cookies技术做到了接收到一个SYN时完全不需要分配空间。<strong>因为构成连接状态的最基本数据都被编码压缩进SYN-ACK的序列号比特位里了。对于一个合法连接，服务器将收到一个带有序列号(其实序列号已经加1)的ACK报文段，然后基本的TCB数据将被重新生成，一个完整的TCB通过解压确认数据将被安全的实例化。</strong>这种解压即使在重度攻击下仍然能够成功，因为在主机端根本没有任何存储负载，只有计算编码数据到ACK序列号中的负载。其不足之处就是，<strong>不是所有的TCB数据都能添加到32位的序列号段中</strong>，所以一些高性能要求的TCP选项将不能被编码。其另一个问题是这样的SYN-ACK报文段将不能被转发(因为转发需要完整的状态数据)。</p>
<p>Andre Oppermann最近的一些研究是运用TCP时间戳选项结合序列号字段编码更多的状态信息，保存那些高性能选项的应用，比如TCP窗口大小,TCP选择性确认选项(TCP <em>Selective Acknowledgment Options</em> )以及TCP MD5摘要对SYN cookies的支持。这使SYN Cookies向前迈进了一步，他消除了之前SYN cooikes实现不能支持这些功能的缺陷。</p>
<p>TCP SYN cookies 的规范格式并不涉及互操作性问题，因为它们仅在本地被处理，对于生成和验证的规范和过程在不同实现中会稍有不同。</p>
<p>6.4.1 SYN cookies的生成</p>
<p>为了在使用SYN cookies时计算出SYN-ACK序列号(就是SYN cookies)，<strong>主机首先要结合一些本机的密码比特，一个包括IP地址和TCP端口号的数据结构，SYN初始序列号，和一些标识密码比特的索引数据。在所有上述字节之上生成一个MD5摘要，然后一些比特位从hash值里被截断以便将其放入到SYN-ACK序列号中。</strong>由于序列号的大小大约是全部hash值的四分之一，因此这种截断是必要的，但是通常验证的时候至少要用3字节大小的hash比特位，这意味着在不知道密码比特位的情况下仍然有将近2^24种可能性去猜测验证cookies。为了将hash值发送出去，cookies的一些比特位将使SYN包含的MSS(最大报文段长度)的上限值变小，并影响在hash值中标识本机密码位的索引位。</p>
<p>6.4.2 SYN cookies的验证</p>
<p>为了验证SYN cookies，首先要将收到的ACK报文段中的确认号减1以便重新生成SYN cookies。对于这些已被截断过<strong>的hash位验证值的计算是基于双方IP地址，端口号，序列号减1和与cookie中索引号对应的密码池中的值。</strong>如果被计算出来的这些值与cookie中的值相同，此时TCB才初始化并开始建立连接。被编码的MSS上界被用来设置一个不超过最初值的合理大小的MSS值。MSS通常由3个比特位来实现，这三个比特位对应8个由一般链路的MTU(最大传输单元)和以太网头部计算出的MSS值。</p>
<ul>
<li><p><strong>设置SYN可疑队列</strong><br>根据攻击程序伪造IP地址的方法。将SYN Flood攻击大致分成以下几种情况： （1）攻击者使用单一的虚假IP地址进行攻击。在这种情况下。攻击者向被攻击主机发送的所有攻击包的<strong>源IP地址都是同一个虚假的IP地址。</strong> （2）攻击者使用<strong>一组虚假的IP地址进行攻击</strong>。这种情况比上一种攻击情况有了改进，进行攻击时。攻击者先生成一组IP地址，再将这些IP地址依此添加到成的每个攻击包的源TP地址中。 （3）攻击者<strong>使用一个网段范围的地址</strong>进行攻击。这是攻击者使用较普遍，也是攻击成功率较高的一种攻击情况。进行攻击时，攻击者精心选择一个地址分配比较稀疏的网段，通常会选择一个B类网段。 针对以上几种情况，可采用对接收的数据按一定规则加以分类，将数据分为攻击数据、可疑数据和正常数据三种类型，然后分别排队处理。<br>首先，对<strong>同一IP地址</strong>在短时间内发送大量重复连接请求时，可将其作为攻击数据直接丢弃，其次，对于<strong>一组IP地址</strong>在短时间内发送大量重复连接请求时，将其放入可疑数据队列，当<strong>某个IP地址发出的连接请求数大于某一阈值时．即作为攻击数据进行丢弃处理：</strong>若收到某个IP地址发送的应答，则将其转入正常数据队列。最后，对于<strong>使用一个网段范围</strong>的地址进行攻击的，<strong>即服务器在短时间内收到某个网络地址内不同主机发出大量的连接请求，此时仍将其放入可疑数据队列</strong>，对于此网段中正常上网的主机当收到服务器重复的SYN+ACK数据包时。就向服务器发送一个RST数据包，从而结束半连接状态；对于此网段中没有开机或上网的主机。即虚假源IP地址。为防止堆栈溢出崩溃，<strong>可不按通常的运行方式为其分配相应的数据结构和存储状态信息</strong>，只向源IP发送确认信息，将TCP连接保持一种无状态的握手方式巾，直到超时后将其丢弃或者收到源IP的连接确认，再将其转入正常数据队列，并分配相应的数据结构和存储状态信息。当服务器负载较重时，首先丢弃可疑数据队列中的数据，然后冉随机地丢弃正常数据队列中的数据，确保服务器的正常运行。</p>
</li>
<li><p><strong>使用防火墙</strong><br><strong>防火墙位于客户端和服务器之间</strong>．因此利用防火墙来阻止DoS攻击能有效地保护内部的服务器。针对SYN Flood，防火墙通常有三种防护方式：SYN网关、被动式SYN网关和SYN中继。<br>（1）SYN网关： 防火墙收到客户端的SYN包时，直接转发给服务器：防火墙收到服务器的SYN/ACK包后，一方面将SYN/ACK包转发给客户端，另一方面以<strong>客户端的名义给服务器回送一个ACK包</strong>．完成TCP的三次握手，让服务器端由半连接状态进入连接状态。当客户端真正的ACK包到达时。有数据则转发给服务器，否则丢弃该包。由于<strong>服务器能承受连接状态要比半连接状态高得多</strong>。所以这种方法能有效地减轻对服务器的攻击。<br>（2）被动式SYN网关： <strong>设置防火墙的SYN请求超时参数，让它远小于服务器的超时期限．</strong>防火墙负责转发客户端发往服务器的SYN包，服务器发往客户端的SYN/ACK包、以及客尸，端发往服务器的ACK包。这样，如果<strong>客户端在防火墙计时器到期时还没发送ACK包，防火墙则往服务器发送RST包</strong>，以使服务器从队列中删去该半连接。由于防火墙的超时参数远小于服务器的超时期限，出此这样能有效防止SYN Flood攻击．<br>（3）SYN中继： SYN中继防火墙在收到客户端的SYN包后．并不向服务器转发而是记录该状态信息后主动给客户端回送SYN/ACK包，如果收 到客户端的ACK包。表明是正常访问，由防火墙向服务器发送SYN包并完成三次握手。这样由防火墙作为代理来实现客户端和服务器端的连接。可以完全过滤不可用连接发往服务器。</p>
</li>
<li><p><strong>混合方式</strong></p>
</li>
</ul>
<p>混合方式将上述的两种或更多防御方法联合起来使用。例如，<strong>一些终端机操作系统同时实现了一个超大backlog队列和SYN cookies，但是仅仅当backlog的大小超过一定阈值时SYN cookies才被使用，这样就能在不涉及SYN cookies缺点的情况下正常使用，也允许在遭受攻击时转移到SYN-cookies防御。</strong></p>
<h2><span id="35-time_wait-状态">35 time_wait 状态</span></h2><p>tcp断开连接之前要经历time_wait状态。时间为最长报文段生命期（maximum segment lifetime,MSL）的两倍，有时称为2MSL。</p>
<p>大概在1分钟到4分钟之内。MSL是任何IP数据报能在因特网中存活的最长时间。这个时间是有限制的，因为一个数据报中含有一个称为跳限的字段8位，理论上TTL最大值可以设置为255,假设具有最大跳限的分组在网络中存在的时间不可能超过MSL秒。</p>
<p>分组在网络中迷途通常是路由异常的结果。某个路由器崩溃或者，某两个路由器之间的某个链路断开，路由协议可能需要数秒到数分钟时间才能稳定并找出另一条通路。在这段时间内可能发生路由循环。迷途其间，TCP超时重传该分组，而重传分组，重传分组通过候选路径达到目的地，不久后早先迷失的分组也到达目的地，这就皎迷途重复分组或漫游重复分组。TCP必须正确处理这些重复的分组。</p>
<p>Time_WAIT状态的两个存在理由</p>
<p>1 可靠地实现TCP全双工连接的终止</p>
<p>2 允许老的重复分节在网络中消逝</p>
<p>1 主动关闭那端是需要TIME_WAIT，客户端最终的ACK丢失了，服务器将重新发送他的最终的哪个FIN，因此可序必须维护状态信息，以允许重新发送最终那个ACK。要是客户端不维护状态信息，他将响应一个RST，该分节将被服务器解释成一个错误。如果TCP打算执行所有必要的工作以彻底终止某个连接上方向的数据流，那么他必须正确处理连接终止序列的4个分节中任何一个分节丢失的情况。</p>
<p>2 假设服务器和客户端在某个端口建立连接，我们关闭这个连接，过一段时间两个端口之间建立另一个连接。后一个连接称为前一个连接的化身，因为他们的IP和端口号都相同。<strong>TCP必须防止来自某个连接的老的重复分组在该连接已经终止之后重复出现。</strong>，从而被wurenwi属于统一连接的某个新的化身。time_wait状态的持续时间是MSL的两倍，就足以让某个方向上的分组最多存活MSL秒被丢弃，另一个方向也最多MSL秒。</p>
<h2><span id="36-为何reset报文不需要ack确认">36 为何Reset报文不需要ACK确认?</span></h2><p>因为发送Reset报文的一端，在发送完这个报文之后，和该TCP Session有关的内存结构体瞬间全部释放，无论对方收到或没有收到，关系并不大。</p>
<ul>
<li>如果对方收到Reset报文，也会释放该TCP Session 的相关内存结构体。</li>
<li>如果对方没有收到Reset 报文，可能会继续发送让接收方弹射出Reset报文的报文，到最后对方一样会收到Reset 报文，并最终释放内存。</li>
<li>37</li>
</ul>
<h2><span id="37ip地址局域网到外网的转换">37,ip地址局域网到外网的转换</span></h2><p>假如电脑A想要访问百度，百度的IP我们假设为：172.168.30.3：<br>我们都知道，电脑A的IP是虚构的，实际上可能并不存在这样一个IP，如果用电脑A的IP去访问百度，那肯定行不通。</p>
<p>　　由于百度和电脑A不在一个局域网内，所以A要访问百度，那么必须得经过网关。而网关的这个IP地址，是真实存在的，是可以访问百度的。</p>
<p>　　为了让 A 可以访问百度，可以采取这样的方法：让网关去帮助 A 访问，然后百度把结果传递给网关，而网关再把结果传递给 A。</p>
<p>　　不过电脑A、B、C都可能拜托网关去帮忙访问百度，而百度返回的结果 的目的IP都是网关的IP=192.168.1.1。那么网关该如何进行区分这结果是A的、B的还是C的呢?</p>
<p>　　我们去访问百度的时候，是需要指定一个端口，我们可以把 A的IP + 端口 映射成 网关的IP+端口，就可以唯一确定身份了。</p>
<p>　　例如A用端口60去访问百度，网关把 A的IP+端口60 映射成 网关的IP+端口80 。</p>
<p>百度把结果返回给网关的80端口之后，网关再通过映射表，就可以把结果返回给 A的60端口 了。</p>
<p>　　如果B也是用60端口去访问百度的话，也是一样，可以把它映射到90端口。</p>
<p>　　这种方法地址的映射转换，也称之为网络地址转换，英文为 Network Address Translation，简称NAT。</p>
<p>　　像A、B、C这样的IP地址就称之为内网IP;而像网关，百度这样的IP称之为外网IP(即互联网公网IP)。</p>
<p>　　为了解决IP地址短缺，技术专家们发明了内网技术，而内网技术的理论支撑就是NAT技术。</p>
<h1><span id="数据结构">数据结构</span></h1><h2><span id="1-说一下平衡二叉树和红黑avl树的定义特点二者区别">1 说一下平衡二叉树和红黑AVL树的定义特点，二者区别</span></h2><ul>
<li><p>平衡二叉树又称AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。</p>
</li>
<li><p>红黑树：一种二叉查找树，在每一个节点内增加一个存储位表示节点颜色。通过对根到叶子节点染色的限制，红黑数确保没有一条路径会比其他路径长出两倍。因此红黑树是一弱平衡的二叉树。对于要求严格的AVL树来说，它在插入和删除时旋转次数少，所以对于插入删除操作较多的情况下。通常使用红黑树。插入最多旋转两次，删除最多三次旋转.</p>
<ul>
<li>性质：每个节点非红即黑</li>
<li>根节点是黑色的</li>
<li>如果一个节点是红色的它的子节点必须是黑色的</li>
<li>每个叶子节点是黑色的（并定义NULL为黑色的）</li>
<li>对于任何节点而言，从一个节点到NULL指针的每一条路径上都包括相同数目的黑节点</li>
</ul>
</li>
</ul>
<p><strong>红黑树旋转：</strong></p>
<p>有左旋和右旋两种旋转，通过改变树中某些结点的颜色以及指针结构来保持对红黑树进行插入和删除操作后的红黑性质。</p>
<p>左旋：</p>
<p>对某个结点x做左旋操作时，假设其右孩子为y而不是T.nil：以x到y的链为“支轴”进行。使y成为该子树新的根结点，x成为y的左孩子，y的左孩子成为x的右孩子。</p>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/%E5%B7%A6%E6%97%8B.png"></p>
<p>右旋：对某个结点x做右旋操作时，假设其左孩子为y而不是T.nil：以x到y的链为“支轴”进行。使y成为该子树新的根结点，x成为y的右孩子，y的右孩子成为x的左孩子。</p>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/%E5%8F%B3%E6%97%8B.png"></p>
<h2><span id="2-介绍一下b树">2 介绍一下B树</span></h2><p>B+树是一种多路搜索树，主要为磁盘存储设备设计的平衡查找树。当数据结构必须放在磁盘上的时候大O模型不再适用，几乎在所有情况下，控制运行时间的都是访问磁盘的次数。想要把磁盘访问次数变小，将树的高度降低即可减少对磁盘的访问次数，一个M阶B+树具有以下特性</p>
<ul>
<li>数据存储在树叶上</li>
<li>非叶节点内存储至多M-1个关键字指示搜索方向；关键字i表示<strong>子树i+1</strong>（一整颗树）中的最小关键字</li>
<li>树的根节点，儿子数在2-M。</li>
<li>除了根外，非叶节点的儿子数在M/2-M之间。</li>
<li>所有叶子节点都在相同的深度上</li>
<li>访问次数近似为$\log_{m/2}N$</li>
</ul>
<p>为什么根节点可以最少两个儿子？</p>
<p>插入节点时，如果叶子节点或者非叶子节点满了，就会发生拆分，如果父节点儿子数量达到限制，就会沿着树向上拆分，如果拆到根节点了，就会产生两个根节点，这是不可以接受的，这个时候就会新建一个节点，将两个树根作为这个根的两个儿子。</p>
<p>删除节点时，不够向邻居借用。</p>
<p>B+树优点，都要查询叶子节点，查询性能稳定，所有叶子节点形成有序列表，便于范围查询。</p>
<h2><span id="21为什么用b树而不用二叉查找树啊为什么不用哈希表">2.1为什么用B树而不用二叉查找树啊？为什么不用哈希表?</span></h2><p>哈希表虽然能够进行O(1)查找到目标数据，不过如果我们要进行<strong>模糊查找</strong>的话，只能遍历所有的数据，并且如果出现极端情况，哈希冲突的元素过多，也会导致线性查找效率。</p>
<p>为什么不用二叉树呢？</p>
<p>如果是查找效率，即比较次数的话，二差树确实是最快的，但是我们的文件系统是放在磁盘上的，可能我们执行几亿条指令的时间只能进行几次的磁盘加载。所以我们不仅要考虑<strong>查找效率</strong>，还要考虑<strong>磁盘的寻址加载次数</strong>,这就是我们要考虑使用B树的原因。</p>
<p>我们知道，在把磁盘里的数据加载到内存中的时候，是以<strong>页</strong>为单位来加载的，而我们也知道，<strong>节点与节点之间的数据是不连续的</strong>，所以不同的节点，很有可能分布在不同的<strong>磁盘页</strong>中。</p>
<p>而对于 B 树，由于 B 树的每一个节点，可以存放多个元素，所以磁盘寻址加载的次数会比较少。</p>
<h2><span id="22-b树和b树的区别">2.2 B树和B+树的区别</span></h2><p>B+树是对B树进行了改造，他的数据都存放在叶子节点上，同时叶子节点之间还加了指针形成链表。</p>
<p>如果要选择数据库上的多条数据，不是一条一条选择，如果要多条访问，<strong>B树</strong>就需要做局部的中序遍历，可能要<strong>跨层访问</strong>。<strong>而B+树由于所有的数据都在叶子节点上，不用跨层，同时又具有链表结构，只需要找到首尾，通过链表就可以把所有的数据取出来了。</strong></p>
<h2><span id="3-请你说一说map和unordered_map的底层实现">3 请你说一说map和unordered_map的底层实现</span></h2><p>map底层是基于红黑树实现的，因此map内部元素排列是有序的。而unordered_map底层则是基于哈希表实现的，因此其元素的排列顺序是杂乱无序的。</p>
<p>对于map，其底层是基于红黑树实现的，优点如下：</p>
<p>1)有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作</p>
<p>2)map的查找、删除、增加等一系列操作时间复杂度稳定，都为logn</p>
<p>缺点如下：</p>
<p>1）查找、删除、增加等操作平均时间复杂度较慢，与n相关</p>
<p>对于unordered_map来说，其底层是一个哈希表，优点如下：</p>
<p><strong>查找、删除、添加的速度快，时间复杂度为常数级O(c)</strong></p>
<p>缺点如下：</p>
<p>因为unordered_map内部基于哈希表，以（key,value）对的形式存储，因此空间占用率高</p>
<p>Unordered_map的查找、删除、添加的时间复杂度不稳定，平均为O(c)，取决于哈希函数。极端情况下可能为O(n)</p>
<h2><span id="4-topk问题">4 TOPK问题</span></h2><p>1、直接全部排序（只适用于内存够的情况）</p>
<p>当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数据全部排序，然后取排序后的数据中的前K个。</p>
<p>这种方法对数据量比较敏感，当数据量较大的情况下，内存不能完全容纳全部数据，这种方法便不适应了。即使内存能够满足要求，该方法将全部数据都排序了，而题目只要求找出top K个数据，所以该方法并不十分高效，不建议使用。</p>
<p>2、快速排序的变形 （只使用于内存够的情况）</p>
<p>这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只需要找出前K个最大的就行。</p>
<p>这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，比划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号index刚好等于K，那么这个划分元以及它左边的数，刚好就是前K个最大的元素；如果index  &gt; K，那么前K大的数据在index的左边，那么就继续递归的从index-1个数中进行一趟排序；如果index &lt; K，那么再从划分元的右边继续进行排序，直到找到序号index刚好等于K为止。再将前K个数进行排序后，返回Top K个元素。这种方法就避免了对除了Top K个元素以外的数据进行排序所带来的不必要的开销。</p>
<p>3、最小堆法</p>
<p>这是一种局部淘汰法。先读取前K个数，建立一个最小堆。然后将剩余的所有数字依次与最小堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的K个数。</p>
<p>4、分治法</p>
<p>将全部数据分成N份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大的K个数。此时剩下N* K个数据，如果内存不能容纳N * K个数据，则再继续分治处理，分成M份，找出每份数据中最大的K个数，如果M * K个数仍然不能读到内存中，则继续分治处理。直到剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。</p>
<p>5、Hash法</p>
<p>如果这些数据中有很多重复的数据，可以先通过hash法，把重复的数去掉。这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则可以直接排序；否则可以使用分治法或者最小堆法来处理数据。</p>
<h2><span id="5-hash">5 hash</span></h2><p>hash 用在什么地方,解决 hash 冲突的几种方法?负载因子?</p>
<ol>
<li>如何构造哈希函数<br>a) 数字分析法;<br>b) 平方取中法;<br>c) 除留余数法;</li>
<li><strong>处理冲突</strong></li>
</ol>
<ul>
<li>分离链式法，将散列到同一值的元素保留在一个链表中。新元素被插在链表前端。</li>
<li>线性探测法（一般负载因子小于0.5）<ul>
<li>发生冲突时，顺序查找下一节点，直到找出一个空单元</li>
<li>问题：占据的位置会形成一个连续的区块，再次散列到这个区块的任何关键字都要试很多单元才能解决冲突。（聚集问题）</li>
</ul>
</li>
<li>平方探测法<ul>
<li>解决聚集问题，要求表的大小是素数，冲突函数是二次的f(i) = i^2,冲突发生时，探测1,2,4,9.。。位置上是否冲突（也会产生二次聚集，散列到相同单元探测相同元素）</li>
</ul>
</li>
<li>伪随机探测<ul>
<li>令线性探测的步长从常数改为随机数。在实际程序中应预先用随机数发生器产生一个随机序列，将此序列作为依次探测的步长。这样就能使不同的关键字具有不同的探测次序，从而可以避 免或减少堆聚。</li>
</ul>
</li>
<li>双散列<ul>
<li>就是使用哈希函数取散列一个输入的时候，探测hash2(x),2*hash2(x)…</li>
</ul>
</li>
</ul>
<p>空间不够了，如超过70%的单元是满的，就新建一个表，将原来的表扩大两倍后的第一个素数。重新插入。</p>
<p><strong>负载因子</strong></p>
<p>散列表元素和散列表大小的比例。</p>
<p>如果负载因子是默认的 0.75,HashMap(16)的时候,占 16 个内存空间,实际<br>上只用到了 12 个,超过 12 个就扩容。<br>如果负载因子是 1 的话,HashMap(16)的时候,占 16 个内存空间,实际上会<br>填满 16 个以后才会扩容。增大负载因子可以减少 hash 表的内存,如果负载因子<br>是 0.75,hashmap(16)最多可以存储 12 个元素,想存第 16 个就得扩容成<br>32。如果负载因子是 1,hashmap(16)最多可以存储 16 个元素。同样存 16 个<br>元素,一个占了 32 个空间,一个占了 16 个空间的内存。</p>
<h2><span id="6-哈夫编码的原理和作用">6  哈夫编码的原理和作用</span></h2><p>哈夫曼编码是哈夫曼树的一种应用，广泛用于<strong>数据文件压缩。</strong>哈夫曼编码算法用<strong>字符在文件中出现的频率</strong>来建立0，1编码最优的表示个字符，使得生成文件的总比特数降低。</p>
<p>各个字符的编码通过建立哈夫曼树来确定，构建哈夫曼树。首先计算每个字符出现的次数。以权值作为根节点构建n棵二叉树，组成森林。在森林中选出两个根节点最小的树合并，作为一棵新树的左右子树，且新树的根节点作为其左右子树根节点的合并。从森林中删除刚选的两颗树，并将新树加入森林，重复上述步骤直到森林中只剩下一棵树为止。</p>
<p>通过从哈夫曼树到根节点的路径经历的路径就可以确定该字符的哈夫曼编码了。根节点向左子树走记0,向右子树走记1。n个权值构建的哈夫曼树有n个叶子节点了，每个哈夫曼编码都不是另一个哈夫曼编码的前缀。这样就保证了在解析哈夫曼编码的过程中不会产生歧义。<strong>哈夫曼树是带权路径最短的树（这也就代表了最终哈夫曼编码的总长度最小），</strong>树中所有叶子节点的权值乘上其到根节点的路径长度与最终的哈夫曼编码总长度成正比关系。权值小的路径长，权值大的路径短。</p>
<h1><span id="数据库问题">数据库问题</span></h1><h2><span id="1-聊一聊事务">1 聊一聊事务</span></h2><p>在 MySQL 中，事务其实是一个最小的不可分割的工作单元。事务能够<strong>保证一个业务的完整性</strong>。</p>
<p>事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。</p>
<p>比如我们的银行转账：在数据库中要执行两条语句，一个用户A加钱，一个用户B减钱，这就是一个不可分割的事务，要么两条语句同时成功，要么两条语句同时失败，这就体现了<strong>原子性</strong>质。如果只有一条执行成功就会出现数据前后不一致的现象。假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的<strong>一致性</strong>。另外事务还有一个性质是隔离性，通常来说，<strong>隔离性</strong>是当多个用户并发访问数据库的时候，<strong>执行自己的事务的时候不能被其它事务执行所干扰。</strong>通常来说，一个事务所做的修改在最终提交以前，对其他事务是可不见的。</p>
<p><strong>隔离性</strong>也分为各种级别：</p>
<p>Read Uncommitted（读取未提交）：最低的隔离级别，什么都不需要做，如果有多个事务，那么任意事务都可以看见其他事务的<strong>未提交数据</strong>。这样会导致<strong>脏读</strong>显现，A开启一个事务操作操作转账给B之后未提交，B一方查询到帐了，A回滚，B钱没了。</p>
<p>Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。但是依然出现问题，一个用户<strong>对表多次读的时候，发现读取到的东西不一致</strong>，产生困惑，这也叫<strong>不可重复读现象。</strong></p>
<p>Repeated Read（可重复读）：在一个事务中，<strong>对于同一份数据的读取结果总是相同的</strong>，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。这就可能产生<strong>幻读</strong>现象，小张，和小王同时开启事务对表进行操作，小张插入一条数据，无论小张是否执行过 <code>COMMIT</code> ，在小王这边，都不会查询到小张的事务记录，而是<strong>只会查询到自己所处事务的记录</strong>，小王插入一条主键相同的数据，提示错误，冗余插入，给小张带来很大困惑，我这边查询没有这条数据啊。幻读，<strong>一个事务提交的数据，不能被其他事务读取到</strong>。**</p>
<p>Serialization（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。串行化的意思就是：假设把所有的事务都放在一个串行的队列中，那么所有的事务都会按照<strong>固定顺序执行</strong>，执行完一个事务后再继续执行下一个事务的<strong>写入操作</strong> ( <strong>这意味着队列中同时只能执行一个事务的写入操作</strong> ) 。小张写数据的时候我这边堵塞，等小张写完数据了，小王才能进行操作。</p>
<p>事务的最后一条性质，持久性，持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是<strong>永久性</strong>的，即便是<strong>在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</strong></p>
<h2><span id="2-数据库的三大范式">2  数据库的三大范式</span></h2><p>第一范式：<strong>数据表中的所有字段都是不可分割的原子值。</strong>只要字段值还可以继续拆分，就不满足第一范式。</p>
<p>范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。</p>
<p>第2范式：<strong>必须在满足第一范式的前提下</strong>，其他列都必须完全依赖于主键列。如果出现不完全依赖，只可能发生在联合主键的情况下：</p>
<p>第三范式：必须在满足第二范式的前提下，除了主键列之外，<strong>其他列之间不能有传递依赖关系。</strong></p>
<p>我的理解，尽量将字段拆分成原子值，除了与主键字段外，每个字段之间关系都是正交的。减少冗余，新增，修改，删除变少。</p>
<p>对查询不友好了。</p>
<h2><span id="3-inner-join和left-join">3 inner join和left join</span></h2><p>left join(左联接) 返回包括左表中的所有记录和右表中<strong>联结字段相等的记录</strong> right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录<br>inner join(等值连接) 只返回两个表中联结字段相等的行</p>
<h2><span id="4-索引">4 索引</span></h2><p>数据库索引是为了增加查询速度而对表字段附加的一种标识，是对数据库表中一列或多列的值进行排序的一种结构。首先明白为什么索引会增加速度，DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行<strong>全表扫描</strong>，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中<strong>一次定位到特定值的行数</strong>，<strong>大大减少遍历匹配的行数，所以能明显增加查询的速度。</strong> </p>
<p>优点：</p>
<p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p>
<p>可以<strong>大大加快数据的检索速度</strong>，这也是创建索引的最主要的原因。</p>
<p>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p>
<p>在使用分组和排序子句进行数据检索时，同样可以显著<strong>减少查询中分组和排序的时间</strong>。</p>
<p>缺点：</p>
<p><strong>创建索引和维护索引要耗费时间</strong>，这种时间随着数据量的增加而增加。</p>
<p>索引需要<strong>占物理空间</strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立<strong>聚簇索引，那么需要的空间就会更大。</strong></p>
<p>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p>
<h4><span id="myisam索引实现">MyISAM索引实现</span></h4><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是<strong>数据记录的地址</strong>。主键索引的key不可以重复，而辅助索引的key可以重复。<strong>MyISAM 的索引方式也叫做“非聚集索引”</strong>。</p>
<h4><span id="innodb索引实现">InnoDB索引实现</span></h4><p>InnoDB也是使用B+Tree作为索引结构，但是具体实现方式却与MyISAM截然不同。</p>
<p>1 InnoDB的数据文件本身就是索引文件。数据文件本身按照B+Tree组织的一个索引结构，这棵树的叶子节点data域完整保存数据记录。这个索引的key是数据表的主键。<strong>这种索引叫做聚集索引。因为 InnoDB 的数据文件本身要按主键聚集。</strong></p>
<p>同时,请<strong>尽量在 InnoDB 上采用自增字段做表的主键</strong>。因为 InnoDB 数据文件本身是一棵B+Tree,非单调的主键会造成在插入新记录时数据文件为了维持 B+Tree 的特性而频繁的分裂调整,十分低效,而使用自增字段作为主键则是一个很好的选择。如果表使用自增主键,那么每次插入新的记录,记录就会顺序添加到当前索引节点的后续位置,当一页写满,就会自动开辟一个新的页。</p>
<p>2 .第二个与 MyISAM 索引的不同是 InnoDB 的<strong>辅助索引 data 域</strong>存储相应记录主键的值而不是地址。</p>
<p>聚集索引这种实现方式使得按主键的搜索十分高效,但是辅助索引搜索需要检索两遍索引:首先检索**辅助索引获得主键,**然后用主键到主索引中检索获得记录。</p>
<p>因为辅助索引存储的数据是主键索引的key，这样就不建议主键过长，主键过长会导致辅助索引变的过大。</p>
<h4><span id="添加索引原则">添加索引原则</span></h4><p>在<strong>查询中很少使用或者参考的列不应该创建索引</strong>。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p>
<p><strong>只有很少数据值的列也不应该增加索引</strong>。这是因为，由于这些列的取值很少，<strong>例如人事表的性别列</strong>，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p>
<p><strong>定义为text、image和bit数据类型的列不应该增加索引。</strong>这是因为，这些列的数据量要么相当大，要么取值很少。</p>
<p>当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，<strong>会提高检索性能，但是会降低修改性能。</strong>当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p>
<h4><span id="使用索引的注意事项">使用索引的注意事项</span></h4><p>使用索引时，有以下一些技巧和注意事项：</p>
<ul>
<li>索引不会包含有NULL值的列</li>
</ul>
<p>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。</p>
<ul>
<li>使用短索引</li>
</ul>
<p>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</p>
<ul>
<li>索引列排序</li>
</ul>
<p>MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</p>
<ul>
<li>like语句操作</li>
</ul>
<p>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。</p>
<ul>
<li>不要在列上进行运算</li>
</ul>
<p>select * from users where YEAR(adddate)&lt;2007;<br>将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成</p>
<p>select * from users where adddate&lt;‘2007-01-01’; </p>
<ul>
<li>不使用NOT IN和&lt;&gt;操作</li>
</ul>
<h2><span id="5-数据库引擎-innodb-和-myisam-的特点与区别">5 数据库引擎, innodb 和 myisam 的特点与区别</span></h2><ol>
<li><p>Innodb 引擎提供了<strong>对数据库 ACID 事务的支持</strong>,并且实现了 <strong>SQL 标准的四种隔离级别</strong>,该引擎<strong>还提供了行级锁和外键约束,**它的设计目标是处理</strong>大容量数据库系统*<em>,它本身其实就是基于 MySQL 后台的完整数据库系统,MySQL 运行时 Innodb 会在内存<strong>中建立缓冲池,用于缓冲数据和索引。</strong>但是该引擎<strong>不支持 FULLTEXT 类型的索引</strong>,而且<br>它没有保存表的行数,**当 SELECT COUNT( * ) FROM TABLE 时需要扫描全表。*</em>当需要使用数据库事务时,该引擎当然是首选。由于**锁的粒度更小,写操作不会锁定全表,**所以在并发较高时,使用 Innodb 引擎会提升效率。但是使用行级锁也不是绝对的,如果在执行一个 SQL 语句时 MySQL 不能确定要扫描的范围,InnoDB 表同样会锁全表。</p>
</li>
<li><p>MyIASM没有提供对数据库事务的支持,也不支持行级锁和外键,因此当 INSERT(插入)或 UPDATE(更新)数据时即写操作需要锁定整个表,效率便会低一些。不过和 Innodb 不同*<em>,MyIASM 中存储了表的行数**,于是<br>SELECT COUNT(</em>) FROM TABLE 时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持,那MyIASM 也是很好的选择。</p>
</li>
<li><p><strong>大尺寸的数据集趋向于选择 InnoDB 引擎,因为它支持事务处理和故障恢复。</strong>数据库的大小决定了故障恢复的时间长短,InnoDB 可以利用事务日志进行数据恢复,这会比较快。主键查询在 InnoDB 引擎下也会相当快,不过需要注意的是如果主键太长也会导致性能问题。大批的 INSERT 语句(在每个INSERT 语句中写入多行,批量插入)在 MyISAM 下会快一些,但是 UPDATE 语句在 InnoDB 下则会更快一些,尤其是在并发量大的时候。</p>
</li>
</ol>
<h3><span id="innodb和mylsam的区别">InnoDB和Mylsam的区别：</span></h3><p>1）事务：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持，提供事务支持已经外部键等高级数据库功能。</p>
<p>2）性能：MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快。</p>
<p>3）行数保存：InnoDB 中不保存表的具体行数，也就是说，执行select count() fromtable时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时，两种表的操作是一样的。</p>
<p>4）索引存储：<strong>对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引</strong>，但是在MyISAM表中，可以和其他字段一起建立联合索引。MyISAM支持<strong>全文索引（FULLTEXT）、压缩索引</strong>，InnoDB不支持。</p>
<p><strong>MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。</strong>能加载更多索引，<strong>而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。</strong></p>
<p>InnoDB存储引擎被完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB存储它的表＆索引在一个表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与MyISAM表不同，比如在MyISAM表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上。</p>
<p>5）服务器数据备份：InnoDB必须导出SQL来备份，LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。</p>
<p><strong>MyISAM应对错误编码导致的数据恢复速度快。MyISAM的数据是以文件的形式存储，</strong>所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。</p>
<p>InnoDB是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p>
<p>6）锁的支持：<strong>MyISAM只支持表锁。InnoDB支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</strong></p>
<h2><span id="6-锁及粒度">6 锁及粒度</span></h2><p>悲观锁？</p>
<p>当我们要对一个数据库里的一条数据进行修改的时候，为了避免被其他人修改，最好的方法是直接对数据库加锁以防并发。这种借助数据库的锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观锁。</p>
<p>乐观锁？</p>
<p>乐观锁<strong>假设一般情况下不会造成冲突，所以在数据提交更新的时候，才会对数据的冲突与否进行检测，如果发生冲突了，则返回给用户错误信息，让用户决定怎么去做。</strong></p>
<p>如何选择？</p>
<p>乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败率较高，容易发生业务失败。</p>
<p>悲观锁效率低，不能并发执行。</p>
<ul>
<li>共享锁/读锁：互不阻塞，优先级低</li>
<li>排他锁/写锁：阻塞其他锁，优先级高，即确保在一个事务写入时不受其他事务的影响。</li>
<li>锁粒度：锁定的数据量越少（粒度越小），并发程度越高，但相应的加锁、检测锁、释放锁用的系统开销也随之增大。</li>
<li>锁策略：锁开销与数据安全性之间的平衡<ul>
<li>表锁：锁住整张表，读锁互不阻塞，写锁阻塞其他所有读写锁（同一张表）。开销最小。</li>
<li>行级锁：对每一行数据（记录）加锁，开销大，并发程度高。</li>
</ul>
</li>
</ul>
<h2><span id="7-sql优化">7 SQL优化</span></h2><p>索引 ？假设有2000个sql语句</p>
<p>找到最慢的sql来进行分析</p>
<p>sql 程序量 随着数据量变大，测试库和生产库不同，执行语句变慢，有一些语句会变很慢</p>
<h3><span id="慢查询"><strong>慢查询</strong></span></h3><p>找到值得优化的sql语句，查询慢的日志。</p>
<p>慢查询分析，找到最慢的优化</p>
<p>首先，查询当前mysql数据库是否开启了慢查询日志功能：</p>
<p><code>show VARIABLES like &#39;%slow%&#39;;</code></p>
<p>还可以查看超过多少秒算是慢查询：</p>
<p><code>show VARIABLES like &#39;long_query_time&#39;;</code></p>
<p>long_query_time的默认值是10，意思是运行10S之上的语句。</p>
<p>修改时间默认时间</p>
<p><code>set global long_query_time=4;</code></p>
<p>未使用索引的查询被记录到慢查询日志中。如果调优的话，建议开启这个选项。如果开启了这个参数，full index scan的sql也会被记录到慢查询日志中。</p>
<p><code>show variables like &#39;log_queries_not_using_indexes</code></p>
<p><code>set global log_queries_not_using_indexes=1 </code></p>
<p>查询有多少条慢查询记录</p>
<p><code>show global status like &#39;%Slow_queries%&#39;;</code></p>
<hr>
<p>Linux系统下是编辑/etc/my.cnf</p>
<p>注意：[mysqld]下面添加<br>#mysql慢日志开启<br>slow_query_log=ON<br>slow_query_log_file=/var/lib/mysql/mysql-slow.log<br>long_query_time=1</p>
<p>然后，重启mysql服务使之生效：</p>
<p>service mysqld restart</p>
<p>接下来就可以通过slow_query_log_file指定的日志路径查看慢查询记录了。</p>
<h3><span id="如何使用mysqldumpslow工具">如何使用mysqldumpslow工具</span></h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token operator">-</span>s 按照那种方式排序
    c：访问计数
    l：锁定时间
    r:返回记录
    al：平均锁定时间
    ar：平均访问记录数
    at：平均查询时间
<span class="token operator">-</span>t 是<span class="token keyword">top</span> n的意思，返回多少条数据。
<span class="token operator">-</span>g 可以跟上正则匹配模式，大小写不敏感。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>记录最多的20个sql</p>
<p><code>mysqldumpslow -s r -t 20 sqlslow.log</code></p>
<p>得到平均访问次数最多的20条sql</p>
<p><code>mysqldumpslow -s ar -t 20 sqlslow.log</code></p>
<p>得到平均访问次数最多,并且里面含有ttt字符的20条sql</p>
<p><code>mysqldumpslow -s ar -t 20 -g &quot;ttt&quot; sqldlow.log</code></p>
<p>使用mysqldumpslow的分析结果不会显示具体完整的sql语句，说明：</p>
<p>SELECT * FROM sms_send WHERE service_id=10 GROUP BY content LIMIT 0, 1000;</p>
<p>mysqldumpslow显示的结果会是：</p>
<p>Count: 1  Time=1.91s (1s)  Lock=0.00s (0s)  Rows=1000.0 (1000), vgos_dba[vgos_dba]@[10.130.229.196]<br>SELECT * FROM sms_send WHERE service_id=N GROUP BY content LIMIT N, N;</p>
<p>2：如果我们再执行一条</p>
<p>SELECT * FROM sms_send WHERE service_id=20 GROUP BY content LIMIT 10000, 1000;</p>
<p>mysqldumpslow显示的结果会是：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">Count: <span class="token number">2</span>  <span class="token keyword">Time</span><span class="token operator">=</span><span class="token number">2.79</span>s <span class="token punctuation">(</span><span class="token number">5</span>s<span class="token punctuation">)</span>  <span class="token keyword">Lock</span><span class="token operator">=</span><span class="token number">0.00</span>s <span class="token punctuation">(</span><span class="token number">0</span>s<span class="token punctuation">)</span>  <span class="token keyword">Rows</span><span class="token operator">=</span><span class="token number">1.0</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vgos_dba<span class="token punctuation">[</span>vgos_dba<span class="token punctuation">]</span>@<span class="token punctuation">[</span><span class="token number">10.130</span><span class="token number">.229</span><span class="token number">.196</span><span class="token punctuation">]</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> sms_send <span class="token keyword">WHERE</span> service_id<span class="token operator">=</span>N <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> content <span class="token keyword">LIMIT</span> N<span class="token punctuation">,</span> N<span class="token punctuation">;</span><span class="token punctuation">`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>虽然这两条语句条件不一样，</p>
<p>1：一个是server_id=10,一个是server_id=20</p>
<p>2：一个是LIMIT 0, 1000,一个是LIMIT 10000, 1000</p>
<p>但是mysqldumpslow分析会认为这是一种类型的语句，会合并显示。这里的time是最长的一条语句执行时间，括号里是总时间</p>
<h3><span id="怎么优化">怎么优化</span></h3><ul>
<li>服务器硬件</li>
<li>mysql服务器优化</li>
<li>sql本身优化：避免子查询</li>
</ul>
<p>1.子查询<br>1.1. MySQL从4.1版本开始支持子查询，使用子查询进行SELECT语句嵌套查询，可以一次完成很多逻辑上需要多个步骤才能完成的SQL操作<br>1.2.子查询虽然很灵活，但是执行效率并不高<br>1.3.执行子查询时，MYSQL需要创建临时表，查询完毕后再删除这些临时表，所以，子查询的速度会受到一定的影响，这里多了一个创建和销毁临时表的过程</p>
<p>2.连接查询（join）<br>2.1.可以使用连接查询（JOIN）代替子查询<strong>，连接查询不需要建立临时表，因此其速度比子查询快</strong><br>总结：连接查询效率高于子查询！！！<br>扩展：多表联查性能优化<br>优化的本质就是(join on 和where的执行顺序）！！！</p>
<ul>
<li><p>反范式设计优化</p>
<p><strong>适当违反满足三大范式</strong>，为了读取效率，允许少量冗余，使用空间换取时间。</p>
</li>
<li><p>索引优化,优化 10 大策略</p>
<ul>
<li><p>策略 1.尽量全值匹配，当建立了索引列后,能在 where条件中使用索引的尽量所用。</p>
</li>
<li><p>策略 2.<strong>最佳左前缀法则如果索引了多列,要遵守最左前缀法则。</strong>指的是查询从索引的最左前列开始并且不跳过索引中的列。</p>
</li>
<li><p>策略 3**.不在索引列上做任何操作**<br>不在索引列上做任何操作(计算、函数、(自动 or 手动)类型转换),会导致索引失效而转向<br>全表扫描</p>
</li>
<li><p>策略 4.范围条件放最后，中间有范围查询会导致后面的索引列全部失效</p>
</li>
<li><p>策略 5.覆盖索引尽量用，尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致)),减少 select *</p>
</li>
<li><p>策略 6.不等于要甚用mysql 在使用不等于(!= 或者&lt;&gt;)的时候无法使用索引会导致全表扫描</p>
</li>
<li><p>策略 7.Null/Not 有影响注意 null/not null 对索引的可能影响，在字段为 not null 的情况下,使用 is null 或 is not null 会导致索引失效</p>
<p>自定义为 NULL 或者不定义，Is not null 的情况会导致索引失效</p>
</li>
<li><p>策略 8.Like 查询要当心like 以通配符开头(‘%abc…’)mysql 索引失效会变成全表扫描的操作</p>
</li>
<li><p>策略 9.字符类型加引号字符串不加单引号索引失效</p>
</li>
<li><p>策略 10.OR 改 UNION 效率高</p>
</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> staffs <span class="token keyword">where</span> name<span class="token operator">=</span><span class="token string">'July'</span> <span class="token operator">or</span> name <span class="token operator">=</span> <span class="token string">'z3'</span>
<span class="token keyword">EXPLAIN</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> staffs <span class="token keyword">where</span> name<span class="token operator">=</span><span class="token string">'July'</span>
<span class="token keyword">UNION</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> staffs <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'z3'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


</li>
</ul>
<p><strong>索引</strong> </p>
<p>是否用到了索引。。执行计划 expain select….</p>
<p>是否充分用到了索引。。查看key_len 字段 索引长度</p>
<p>key 算法  字符类型</p>
<p>1.字符集 utf-8 3</p>
<p>2.字符类型 vchar+，char+0</p>
<p>3.是否为空 null+1  not null +0</p>
<p>4.本身长度 </p>
<p>varchar(50)  50*3 = 150+2+0 =152; </p>
<p>组合索引要保证最佳左前缀原则</p>
<ul>
<li>在经常性的检索列上，建立必要索引，以加快搜索速率，避免全表扫描（索引覆盖扫描）；</li>
<li>多次查询同样的数据，可以考虑<strong>缓存该组数据</strong>；</li>
<li>审视select * form tables, 你需要所有列数据吗？</li>
<li>切分查询（大查询切分成为小查询，<strong>避免一次性锁住大量数据）</strong></li>
<li>分解关联查询（单表查询，结果在应用程序中进行关联，可以减少处理过程中的锁争用）</li>
<li>尽量先做<strong>单表查询</strong>；</li>
<li>…</li>
</ul>
<h2><span id="8-为什么索引用b树">8 为什么索引用B+树</span></h2><p>1、 <strong>B+树的磁盘读写代价更低</strong>：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，<strong>如果把所有同一内部节点的关键字存放在同一盘块中，那</strong>么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对<code>IO读写次数就降低</code>了。</p>
<p>2、<strong>由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库</strong>，只 需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在<code>区间查询</code>的情况，所以通常B+树用于数据库索引。</p>
<h2><span id="9-树的高度为-3-的情况下mysql-能存多少数据">9 树的高度为 3 的情况下,mysql 能存多少数据</span></h2><p>show VARIABLES like ‘innodb_page_size’ //默认为 16K,代表一个节点能存放 16K 数据<br>假设:主键为 bigint 长度为 8,额外需要 6 的长度记录位置信息(8+6=14)<br>第一行:那么一个页能存放=16 * 1024/14 =1170.2857<br>第二行:1170 * 1170=136,89 00<br>第三行:假设一行数据为 1K, 1170 * 1170 * 16 = 2190,2400 行</p>
<h2><span id="10-为什么myisam插入速度比innodb性能差">10 为什么myISAM插入速度比InnoDB性能差？</span></h2><p>MyISAM在读操作占主导的情况下是很高效的。<strong>可一旦出现大量的读写并发，</strong>同InnoDB相比，MyISAM的效率就会直线下降，而且，MyISAM和InnoDB的数据存储方式也有显著不同：通常，在MyISAM里，新数据会被附加到数据文件的结尾，<strong>可如果时常做一些 UPDATE，DELETE操作之后，数据文件就不再是连续的，形象一点来说，就是数据文件里出现了很多洞洞，</strong>此时再插入新数据时，按缺省设置会先看这些洞洞的大小是否可以容纳下新数据，如果可以，则直接把新数据保存到洞洞里，反之，则把新数据保存到数据文件的结尾。之所以这样做是为了<strong>减少数据文件的大小，降低文件碎片的产生。</strong>但InnoDB里则不是这样，<strong>在InnoDB里，由于主键是cluster的，所以，数据文件始终是按照主键排序的，如果使用自增ID做主键，则新数据始终是位于数据文件的结尾。</strong></p>
<h2><span id="11-数据库连接池的作用">11 数据库连接池的作用</span></h2><ol>
<li>在内部对象池中,维护一定数量的数据库连接,并对<strong>外暴露数据库连接的获取和返回方法</strong>,如外部使用者可通过 getConnection 方法获取数据库连接,使用完毕后再通过 releaseConnection 方法将连接返回,注意此时的连接并没有关闭,而是由连接池管理器回收,并为下一次使用做好准备。</li>
<li>资源重用,由于数据库连接得到重用,避<strong>免了频繁创建、释放连接引起的大量性能开销</strong>。在减少系统消耗的基础上,增进了系统环境的平稳性(减<strong>少内存碎片以级数据库临时进程、线程的数量</strong>)</li>
<li><strong>更快的系统响应速度,**数据库连接池在初始化过程中,往往已经创建了若干数据库连接置于池内备用。此时连接池的初始化操作均已完成。对于业务请求处理而言,**直接利用现有可用连接,避免了数据库连接初始化和释放过程的时间开销</strong>,从而缩减了系统整体响应时间。</li>
<li>新的资源分配手段,对于多应用共享同一数据库的系统而言,可在应用层通过数据库连接的配置,实现数据库连接技术。</li>
<li><strong>统一的连接管理,避免数据库连接泄露,**较较为完备的数据库连接池实现中,可根据</strong>预先的连接占用超时设定,强制收回被占用的连接**,从而避免了常规数据库连接操作中可能出现的资源泄露。</li>
</ol>
<h2><span id="12-数据库union-join-的区别">12 数据库union join 的区别</span></h2><ol>
<li>join 是两张表做交连后里面条件相同的部分记录产生一个记录集, <strong>union 是产生的两个记录集(字段要一样的) 并在一起,成为一个新的记录集 。</strong></li>
<li><strong>union 在数据库运算中会过滤掉重复数据</strong>,并且合并之后的是根据<strong>行合并</strong>的,即:如果 <strong>a 表和 b 表中的数据各有五行,且有两行是重复数据,合并之后为 8 行。</strong>运用场景:<br>适合于需要进行统计的运算</li>
<li>union all 是进行全部合并运算的,即:如果 a 表和 b 表中的数据各有五行,且有两<br>行是重复数据,合并之后为 10 行。</li>
<li><strong>join 是进行表关联运算的,两个表要有一定的关系</strong>。即:如果 a 表和 b 表中的数据各<br>有五行,且有两行是重复数据,根据某一列值进行笛卡尔运算和条件过滤,<strong>假如 a 表有 2 列,b 表有 2 列,join 之后是 4 列。</strong></li>
</ol>
<h2><span id="13-请问mysql的端口号是多少如何修改这个端口号">13、请问MySQL的端口号是多少，如何修改这个端口号</span></h2><p>使用命令show global variables like ‘port’;查看端口号 ，mysql的默认端口是3306。（补充：sqlserver默认端口号为：1433；oracle默认端口号为：1521；DB2默认端口号为：5000；PostgreSQL默认端口号为：5432）</p>
<p>修改端口号：</p>
<p>修改端口号：编辑/etc/mysql/mysql.conf.d文件</p>
<h1><span id="项目相关">项目相关</span></h1><p>Merge会自动根据两个分支的共同祖先和两个分支的最新提交 进行一个三方合并，然后将合并中修改的内容生成一个新的 commit，即merge合并两个分支并生成一个新的提交,并且仍然后保存原来分支的commit记录。</p>
<p>Rebase会从两个分支的共同祖先开始提取当前分支上的修改，然后将当<strong>前分支上的所有修改合并到目标分支的最新提交后面</strong>，如果提取的修改有多个，那git将依次应用到最新的提交后面。Rebase后只剩下一个分支的commit记录。</p>
<h1><span id="测试相关">测试相关</span></h1><p>软件开发的声明周期：产品定义（确定想要做什么）-&gt;可行性分析（该问题是否有解决方案）-&gt;需求分析（沟通，深入调研了解用户需求）-&gt; 系统设计（设计可实施的方案，设计程序的体系结构）-&gt; 详细设计（具体设计每个功能模块，确定模块所需的算法和数据结构）-&gt; 软件编码 -&gt; 单元测试综合测试 -&gt; 软件运维</p>
<p>测试需要的能力</p>
<p>对商品需求的了解，业务逻辑清晰，站在用户的角度思考产品。</p>
<p>对计算机硬件、操作系统、编程语言和数据库、web体系要有所了解。</p>
<p>软件测试流程，软件测试需求书，软件测试计划书，软件测试缺陷管理。</p>
<p>责任心，沟通能力，协作能力，耐心，细心，严谨的工作态度。</p>
<h2><span id="软件测试是干什么的及工作内容"><strong>软件测试是干什么的及工作内容</strong></span></h2><h3><span id="第一-通过测试发现软件中的缺陷或不足"><strong>第一、通过测试发现软件中的缺陷或不足</strong></span></h3><p>　　软件测试是干什么的呢？通过测试发现软件中存在的不足是其中一个内容，测试软件的技术分为两种，一是黑盒测试，二是白盒测试。之后通过黑盒和白盒进行不同类型的测试比如有类弄分法、因果图法以及白盒测试中的分支覆盖等等，通过这些不同的测试可以发现软件中存在的不足，以让软件开发工程师再次进行完善。</p>
<h3><span id="第二-软件测试需要把发现的的问题整理成报告"><strong>第二、软件测试需要把发现的的问题整理成报告</strong></span></h3><p>　　软件测试的工作还包括把发现的问题整理成报告上交，提交缘分开发工程师，当得到确认后再对软件进行修复。对于软件测试是干什么的问题，大家还需要了解，测试人员在整理报告的时候应使用专业的术语<strong>，同时要具备很好的文字表达能力以及较强的语言组织能力，也只有这样才能把发现的缺点或不足详细、清楚的表达出来，让开发人员更好的对软件进行修复。</strong></p>
<h3><span id="第三-测试人员需要分析软件的质量好坏"><strong>第三、测试人员需要分析软件的质量好坏</strong></span></h3><p>　　软件测试是干什么的呢？包括哪些工作内容呢？除了要测试软件的不足，还要分析软件质量的好坏，需要根据测试的结果来分析，计算出软件的缺陷率和缺陷分布的情况，以及提出对软件修复的趋势等。<strong>测试工程师需要给出软件各种质量特性的具体度量，比如功能性、可靠性以及易用性等，并得出结论提交给软件开发工程师。</strong></p>
<h2><span id="1-软件测试流程">1 软件测试流程：</span></h2><ul>
<li>测试需求分析阶段：阅读需求，理解需求，主要就是对业务的学习，分析需求点，参与需求评审会议 </li>
<li>测试计划阶段：主要任务就是编写测试计划，参考软件需求规格说明书，项目总体计划，内容包括测试范围（来自<strong>需求文档</strong>），<strong>进度安排，人力物力的分配，整体测试策略的制定。</strong>风险评估与规避措施有一个制定。 </li>
<li>测试设计阶段：<strong>主要是编写测试用例</strong>，会参考需求文档（原型图），概要设计，详细设计等文档，用例编写完成之后会进行评审。 </li>
<li>测试执行阶段：搭建环境，执行冒烟测试（预测试）-然后进入正式测试，bug管理直到测试结束 </li>
<li>测试评估阶段：出测试报告，确认是否可以上线 </li>
<li>测试流程：了解用户需求–&gt;参考需求规格说明书–&gt;测试计划（人力物力时间进度的安排）–&gt;编写测试用例–&gt;评审用例–&gt;搭建环境–&gt;测试包安排预测（冒烟测试）-正式测试-bug-测试结束出报告–&gt;版本上线–&gt;面向用户</li>
</ul>
<h2><span id="2-android中造成app闪推的原因总结">2 Android中造成APP闪推的原因总结</span></h2><ul>
<li>弱网络情况下，服务端响应不及时，可能倒是闪退。（网络异常引起的） </li>
<li>应用版本太低，会导致不兼容，造成闪退。（有些API在老版本中有,在新版本中没有,造成对象为空引起闪退） </li>
<li>APP的SDK和手机的系统不兼容。 </li>
<li>缓存垃圾过多：由于安卓系统的特性，如果长时间不清理垃圾文件。会导致越来越卡，也会出现闪退情况。 </li>
<li>设计不合理，1个接口，拉取的数据量太大，请求结果会很慢，且占用大量内存，APP会闪退（比如，我们现在做的记录仪，进入相册列表时候，要拉取所有图片，拉取太慢了，就闪退了） </li>
<li>不同APP间切换，交互测试，可能会出现闪退。 </li>
<li>权限问题。</li>
</ul>
<h2><span id="3-网页很卡的原因">3 网页很卡的原因</span></h2><p>http请求次数太多。 </p>
<p>接收数据时间过长，如下载资源过大。 </p>
<p>JS脚本过大，阻塞了页面的加载。 </p>
<p>网页资源过多、接受数据时间长、加载某个资源慢。 </p>
<p>DNS解析速度。</p>
<h2><span id="4-测试方法分类单元测试-集成测试-系统测试">4 测试方法分类：单元测试、集成测试、系统测试</span></h2><ul>
<li><p>单元测试：开发阶段，研发人员负责代码编写，并且自己进行代码检测，<strong>对代码的函数，或者类进行单元测试</strong>，也被称为组件测试。</p>
</li>
<li><p>冒烟测试：针对每个版本或每次需求变更后，在正式测试前，对产品或系统的一次简单的验证性测试。冒烟测试主要是测试系统的主流程是否可用.为正式测试前，验证<strong>是否产品或系统的主要需求或预置条件是否存在bug</strong>。　最好的方法，设计出自动化测试脚本，每一次版本更新后都可以去执行脚本验证一下。</p>
</li>
<li><p>集成测试：组装测试，测试接口，测试数据结构</p>
</li>
<li><p>系统测试：测试用例执行过程，准备计算机，相应操作系统，软件运行环境，分配测试人员进行系统测试。</p>
</li>
<li><p>验收测试：啊法测试，删档内测。</p>
<ul>
<li>贝塔测试，不删档公测。</li>
</ul>
</li>
<li><p>粒度不同：</p>
<ul>
<li>单元测试粒度最小，集成测试粒度居中，系统测试粒度最大。 </li>
</ul>
</li>
<li><p>测试方式不同：</p>
<ul>
<li>单元测试一般由开发小组采用白盒方式来测试，集成测试一般由开发小组采用白盒加黑盒的方式来测试，系统测试一般由独立测试小组采用黑盒方式来测试。 </li>
</ul>
</li>
<li><p>测试内容不同：</p>
<ul>
<li>单元测试主要测试单元是否符合“设计”，集成测试既验证“设计”，又验证“需求”，系统测试主要测试系统是否符合“需求规格说明书”。 </li>
</ul>
</li>
<li><p>使用阶段不同：</p>
<ul>
<li>单元测试为开发人员在开发阶段要做的事情，集成测试和系统测试为测试人员在测试周期内级层做的工作。 </li>
</ul>
</li>
</ul>
<h2><span id="测试类型5-12">测试类型5-12</span></h2><h2><span id="5-什么是黑盒测试和白盒测试">5 什么是黑盒测试和白盒测试</span></h2><p>白盒测试：是通过程序的源代码进行测试而不是用户界面。这种类型的测试需要从<strong>代码语句发现内部代码在的算法，溢出，路径，条件等等中的缺点或者错误，</strong>进而加以改正。</p>
<p>黑盒测试：通过使用整个软件或者莫种软件功能来严格的测试，而并没有通过检查程序的源码或者很清晰的了解软件的源代码程序是怎样设计的。<strong>测试人员通过输入他们的数据然后看输出结果从而了解软件怎样工作。在测试其间，把程序看作一个不能打开的黑匣子，</strong>完全不考虑内部结构和内部特性，测试者在程序接口进行测试，它只检查程序是否能<strong>适当地接受和正确的输出</strong>。对<strong>页面和功能</strong>进行测试，要根据说明书，用户手册进行测试，要求多组数据，多次测试才能得到准确的报告。</p>
<p><strong>灰盒测试</strong>：介于白盒测试和黑盒测试之间，根据实际场景，资源，复杂情况等状况进行结合</p>
<h2><span id="6-功能测试">6 功能测试</span></h2><p>功能测试指测试软件各个功能模块是否正确，逻辑是否正确。</p>
<p>　　对测试对象的功能测试应侧<strong>重于所有可直接追踪到用例或业务功能和业务规则的测试需求。这种测试的目标是核实数据的接受、处理和检索是否正确，以及业务规则的实施是否恰当。</strong>此类测试基于<strong>黑盒技术，该技术通过图形用户界面（GUI）与应用程序进行交互，</strong>并对交互的输出或结果进行分析，以此来核实应用程序及其内部进程。功能测试的主要参考为类似于功能说明书之类的文档。</p>
<h2><span id="7-ui测试">7 UI测试</span></h2><p>　　UI测试指测试用户界面的风格是否满足客户要求，文字是否正确，页面美工是否好看，文字，图片组合是否完美，背景是否美观，操作是否友好等等</p>
<p>　　用户界面（UI）测试用于核实用户与软件之间的交互。UI测试的目标是确保用户界面会通过测试对象的功能来为用户提供相应的访问或浏览功能。另外，UI测试还可确保UI中的对象按照预期的方式运行，并符合公司或行业的标准。包括用户友好性，人性化，易操作性测试。UI测试比较主观，与测试人员的喜好有关。</p>
<h2><span id="8性能测试"><strong>8.性能测试</strong></span></h2><p>　　确定软件在测试环境下的速度，稳定性，和伸缩型等特征，指满足产品的性能目标以及资源利用率等。性能测试主要测试软件测试的性能，包括负载测试，强度测试，数据库容量测试，基准测试。</p>
<p>性能：主观响应时间，软件系统处理时间，网络传输时间，后端测试，前端测试。。</p>
<h2><span id="9安全性和访问控制测试"><strong>9.安全性和访问控制测试</strong></span></h2><p>　　安全性和访问控制测试侧重于安全性的两个关键方面：</p>
<p>　　应用程序级别的安全性，包括对数据或业务功能的访问</p>
<p>　　系统级别的安全性，包括对系统的登录或远程访问。</p>
<h2><span id="10故障转移和恢复测试"><strong>10.故障转移和恢复测试</strong></span></h2><p>　　故障转移和恢复测试指当主机软硬件发生灾难时候，<strong>备份机器</strong>是否能够正常启动，<strong>使系统是否可以正常运行</strong>，这对于电信，银行等领域的软件是十分重要的。</p>
<p>　　故障转移和恢复测试可确保测试对象能成功完成故障转移，并能<strong>从导致意外数据损失或数据完整性破坏的各种硬件、软件或网络故障中恢复。</strong></p>
<h2><span id="12兼容性测试">12.兼容性测试</span></h2><p>配置测试核实<strong>测试对象在不同的软件和硬件配置中的运行情况。</strong>在大多数生产环境中，客户机工作站、网络连接和数据库服务器的具体硬件规格会有所不同。<strong>客户机工作站可能会安装不同的软件例如，应用程序、驱动程序等而且在任何时候，都可能运行许多不同的软件组合，从而占用不同的资源。</strong></p>
<h2><span id="13-什么是测试用例">13 什么是测试用例？</span></h2><p>测试用例就是一个文档，描述输入、动作、或者时间和一个期望的结果，其目的是确定应用程序的某个特性是否正常的工作。</p>
<p>软件测试的基本要素包括测试用例编号、测试标题、重要级别、测试输入、操作步骤、预期结果。</p>
<p><strong>测试角度</strong></p>
<p>功能性，安全性，压测性，兼容性</p>
<p><strong>测试用例设计原则</strong><br>  1.测试用例的代表性：能够代表并覆盖各种合理的和不合理的、合法的和非法的、边界的和越界的以及极限的输入数据、操作和环境设置等。<br>  2.测试结果的可判定性：即测试执行结果的正确性是可判定的，每一个测试用例都应有相应的期望结果。<br>  3.测试结果的可再现性：即对同样的测试用例，系统的执行结果应当是相同的。</p>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/%E6%B5%8B%E8%AF%95%E6%A8%A1%E6%9D%BF.png"></p>
<p><img src="/YXY996/2021/04/14/%E5%85%AB%E8%82%A1%E6%96%87/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B2.png"></p>
<h2><span id="13聊天功能实际测试用例">13.聊天功能实际测试用例</span></h2><ul>
<li><p>登录退出—忘记密码，更换账号 </p>
</li>
<li><p>发送对象（普通用户、公众号、群、其他特殊主体） </p>
</li>
<li><p>衍生功能（转发、语音转文字、删除等） </p>
</li>
<li><p>消息发送—单聊、群聊、语音、文字、图片、表情、链接、字符及长度 </p>
</li>
<li><p>消息管理—发布通知、接受通知、发文件、消息提醒、通知提醒、声音、震动、好友请求、请求处理 </p>
</li>
<li><p>发送内容（空白、正常文字、超长文字、以前曾经引起过崩溃的特殊内容、特殊字符、表情、图片、多媒体、红包、语音等） </p>
</li>
<li><p>消息推送—在线、离线、收发、时序 </p>
</li>
<li><p>权限管理—开放群（任何人入群），半开放群（验证入群），验证加好友，不需验证加好友 </p>
</li>
<li><p>隐私管理—黑名单，允许好友查看动态，允许陌生人查看动态，允许通过手机号查找，允许真实姓名查找 </p>
</li>
<li><p>成员管理—加人，被加，退出，被动退出，编辑，删除 </p>
</li>
<li><p>群组管理—创建群，消息设置，申请入群，扫二维码入群，退群，通知提醒，头像编辑，名称编辑，简介编辑，权限编辑，成员编辑 </p>
</li>
<li><p>好友管理—扫二维码加人，加好友，查好友，好友推荐，群组推荐，联系人导入，拉黑名单，解除好友，备注名 </p>
</li>
<li><p>动态管理—发动态，发投票，点赞，表情，评论，增加，删除，分享，隐藏，编辑 </p>
</li>
<li><p>文件管理—接收，离线接收，预览，删除，分享，转存，文件格式，大小 </p>
</li>
<li><p>语音聊天—接通/挂断、通话质量、耳机插拔、音量调解、话筒/扬声器切换、打开/关闭麦克风、后台挂起 </p>
</li>
<li><p>视频聊天—接通/挂点/切换语音、视频质量、耳机插拔、音量调解、话筒/扬声器切换、前置后置摄像头切换、视频框切换、后台挂起</p>
</li>
</ul>
<h2><span id="14-微信红包功能怎么测试">14 微信红包功能怎么测试</span></h2><ul>
<li>功能<ul>
<li>在红包钱数，和红包个数的输入框中只能输入数字 </li>
<li>红包里最多和最少可以输入的钱数  200  0.01 </li>
<li>拼手气红包最多可以发多少个红包  100、超过最大拼手气红包的个数是否有提醒 </li>
<li>当红包钱数超过最大范围是不是有对应的提示 </li>
<li>当发送的红包个数超过最大范围是不是有提示 </li>
<li>当余额不足时，红包发送失败 </li>
<li>在红包描述里是否可以输入汉字，英文，符号，表情，纯数字，汉字英语符号，是否可以输入它们的混合搭配 </li>
<li>输入红包钱数是不是只能输入数字 </li>
<li>红包描述里许多能有多少个字符   10个 </li>
<li>红包描述，金额，红包个数框里是否支持复制粘贴操作 </li>
<li>红包描述里的表情可以删除 </li>
<li>发送的红包别人是否可以领取、发的红包自己可不可以领取   2人 </li>
<li>24小时内没有领取的红包是否可以退回到原来的账户、超过24小时没有领取的红包，是否还可以领取 </li>
<li>用户是否可以多次抢一个红包 </li>
<li>发红包的人是否还可以抢红包   多人 </li>
<li>红包的金额里的小数位数是否有限制 </li>
<li>可以按返回键，取消发红包 </li>
<li>断网时，无法抢红包 </li>
<li>可不可以自己选择支付方式 </li>
<li>余额不足时，会不会自动匹配支付方式 </li>
<li>在发红包界面能否看到以前的收发红包的记录 </li>
<li>红包记录里的信息与实际收发红包记录是否匹配 </li>
<li>支付时可以密码支付也可以指纹支付 </li>
<li>如果直接输入小数点，那么小数点之前应该有个0 </li>
<li>支付成功后，退回聊天界面 </li>
<li>发红包金额和收到的红包金额应该匹配 </li>
<li>是否可以连续多次发红包 </li>
<li>输入钱数为0，”塞钱进红包”置灰</li>
</ul>
</li>
</ul>
<p>性能</p>
<ul>
<li>弱网时抢红包，发红包时间 </li>
<li>不同网速时抢红包，发红包的时间 </li>
<li>发红包和收红包成功后的跳转时间 </li>
<li>收发红包的耗电量 </li>
<li>退款到账的时间 </li>
</ul>
<p>兼容</p>
<ul>
<li>苹果，安卓是否都可以发送红包 </li>
<li>电脑端可以抢微信红包 </li>
</ul>
<p>界面</p>
<ul>
<li>发红包界面没有错别字 </li>
<li>抢完红包界面没有错别字 </li>
<li>发红包和收红包界面排版合理， </li>
<li>发红包和收到红包界面颜色搭配合理 </li>
</ul>
<p>安全</p>
<ul>
<li>对方微信号异地登录，是否会有提醒   2人 </li>
<li>红包被领取以后，发送红包人的金额会减少，收红包金额会增加 </li>
<li>发送红包失败，余额和银行卡里的钱数不会少 </li>
<li>红包发送成功，是否会收到微信支付的通知 </li>
</ul>
<p>易用性(有点重复)</p>
<ul>
<li>红包描述，可以通过语音输入 </li>
<li>可以指纹支付也可以密码支付</li>
</ul>
<h2><span id="15-朋友圈里的点赞功能">15 朋友圈里的点赞功能</span></h2><ul>
<li>是否可以点赞、取消点赞 </li>
<li>多次点赞会出现什么情况 </li>
<li>多人点赞时的顺序是否按照时间顺序进行排列 </li>
<li>点赞是否显示头像和名称 </li>
<li>点赞之后能否进行评论 </li>
<li>点赞之后退出该页面，再次进入朋友圈点赞消息是否还存在 </li>
<li>多用户点赞，再次打开朋友圈是是否可以按照顺序看到是谁谁谁赞了我 </li>
<li>弱网络的情况下点赞能否实时更新 </li>
<li>点赞时有短信或电话进来，能否显示点赞情况 </li>
<li>点赞的人是否在可见分组里 </li>
<li>点赞之后共同好友的点赞和评论是否会提醒你</li>
</ul>
<h1><span id="排名算法二淘宝搜索排序算法分析">排名算法（二）–淘宝搜索排序算法分析</span></h1><p>淘宝搜索排序的目的是帮助用户快速的找到需要的商品。从技术上来说，就是在用户输入关键词匹配到的商品中，把最符合用户需求的商品排到第一位，其它的依次排在后续相应的位置。为了更好的实现这个目标，算法排序系统基本按三个方面来推进：</p>
<p>一、算法模型</p>
<p>当用户输入关键词进行搜索的时候，系统依据算法模型来给匹配到的每个商品进行实时的计算，并按照分数的大小对商品进行排序。</p>
<p>对于好的算法模型，首先需要考虑我们能够有哪些特征因子可以应用。比如在网页搜索中，算法模型基本就是按网页的重要性和相关性给网页计算一个分数，然后进行排序。这里的相关性，和重要性就是网页排序模型中两个重要的因子。具体来说相关性因子是指搜索关键字在文档中出现的度数，当这个度数越高时，则认为该文档的相关程度越高。重要度因子比如 Google 的 Pagerank，可以理解为一个网页入口超级链接的数目：一个网页被其他网页引用得越多，则该网页就越有价值。特别地，一个网页被越重要的网页所引用，则该网页的重要程度也就越高。</p>
<p>考虑淘宝搜索的时候，有些特征因子是很容易能想到的，比如：</p>
<p>A、文本的相关性：关键词和商品的匹配，匹配的程度，是否重要词的匹配，匹配词之间的距离等，都可能影响相关性。比如搜索“小鸭子洗衣机”的时候，一个商品的中心词是洗衣机的要比卖洗衣机配件商品的相关性高，小鸭子连在一起的相关性要比“小”和“鸭子”分开时候的相关性高等。文本相关性最基本的计算方式可以参考 BM25 等。</p>
<p>B、类目热点：淘宝数据的一个重要特质是每个商品都挂靠在类目属性体系下面，每个商品都做了一个很好的分类。在搜索过程中，同一搜索词的大量用户行为数据很容易聚焦到相应的热点类目，比如“手机”的搜索行为会集中到手机类目，而不是配件类目。</p>
<p>C、图片质量：图片是电子商务网站非常重要的一个数据，图片是否精美吸引人，图片上是否有各种各样的“牛皮癣”，和商品匹配度等都很大程度上影响着用户的点击和购买决策。</p>
<p>D、商品质量：每个商品都有不同的质量，商品的描述真实性，是否物美价廉，受人欢迎的程度等。</p>
<p>E、作弊因子：类似于全网搜索有关键词堆砌，link spam，网页重复等等作弊的问题，电子商务搜索也面临同样的问题，比如商品关键词堆砌，重复铺货，重复开店，广告商品引流等等，也有商品特有的问题如价格作弊，交易作弊等，需要利用统计分析或者机器学习来做异常行为，异常规律的发现和识别并运用到排序中。</p>
<p>F、公平因子：淘宝的商品很丰富，每个搜索词下都有足够多的商品在竞争，需要在相似质量的情况下让更多的商品和卖家有展示的机会，而不是像网页搜索一样是一个基本静态的排序，照成商品点击和展示的马太效应。</p>
<p>类似的商品，卖家，买家，搜索词等方面的特征因子有很多，一个排序模型就是把各种各样不同的特征因子组合起来，给出一个最终的关键词到商品的相关性分数。只用其中的一到两个特征因子，已经可以对商品做一些最基本的排序。如果有更多的特征参与到排序，我们就可能得到一个更好的排序算法。组合的方法可以有简单的人工配置到复杂的类似 Learning to Rank 等的学习模型。</p>
<p>那么如何衡量不同算法之间的优劣呢？</p>
<p>二、线下评估</p>
<p>算法模型的评估一般分为线下的评估和线上的评估，线下的评估很多都体现在搜索中常用的相关性（Relevance）指标。相关性的定义可以分为狭义相关性和广义相关性两方面，狭义相关性一般指检索结果和用户查询的相关程度。而从广义的层面，相关性可以理解为用户查询的综合满意度。当用户在搜索框输入关键词，到需求获得满足，这之间经历的过程越顺畅，越便捷，搜索相关性就越好。</p>
<p>在淘宝搜索衡量狭义相关性的时候，一般是使用 PI（Per Item）测试的方法：</p>
<p>A、抽取具有代表性的查询关键词，组成一个规模适当的关键词集合</p>
<p>B、针对这个关键词集合，从模型的产出结果中查询对应的结果，进行人工标注（人工判断为相关性好、中、差等）， 对人工评测的结果数据，使用预定义好的评价计算公式比如 DCG 等，用数值化的方法来评价算法模型的结果和标注的理想结果的接近程度。</p>
<p>利用人工标注数据来计算相关性的分数，来判断模型的好坏；在这个过程中人工不可避免的会有主观的判断，但综合了多人的判断结果还是可以获得一个有统计意义的结果，另一方面标注数据也可以帮助我们找到一个算法表现不理想的地方，有针对性的提升。<br>广义的相关性线下评测比较困难，受人工主观因素的影响更大，一般使用 SBS（Side by Side）的评测方法，针对一个关键词，把两个不同算法模型产出的结果同时展示在屏幕上，每次新模型和对比模型展示的位置关系都是随即的，人工判断的时候不知道哪一边的数据是新模型的结果，人工判断那一边的搜索结果好，以最终的统计结果综合来衡量新模型和老模型的搜索表现。</p>
<p>线下评测的方法和指标有很多，不同的搜索引擎会关注不同的指标，比如以前 Yahoo 的全网搜索引擎比较关注 RCFP（Relevance，Coverage，Freshness，Perspective）等，淘宝搜索线下评测时候一般统计 DCG 和 SBS 的指标。</p>
<p>线下的评测方法从统计上有一定的指导意义，能从一定程度上区分模型的好坏，但要真正验证算法模型的好坏，还需要接受真实的流量来验证。</p>
<p>三、线上测试</p>
<p>为了真实验证一个算法模型的好坏，需要有一个系统能提供真实的流量来检验。淘宝搜索实现的 BTS（Bucket Testing System）系统就是这样的一个环境，在用户搜索时，由搜索系统根据一定的策略来自动决定用户的分组号（Bucket id），保证自动抽取导入不同分组的流量具有可对比性，然后让不同分组的用户看到的不同算法模型提供的结果。用户在不同模型下的行为将被记录下来，这些行为数据通过数据分析形成一系列指标，而通过这些指标的比较，最后就形成了不同模型之间孰优孰劣的结论。只要分组的流量达到一定的程度，数据指标从统计意义上就具有可比性。</p>
<p>不同的 BTS 系统会关注不同的数据指标，在淘宝搜索，有一些重要的指标是很多算法模型测试的时候关注的：</p>
<p>访问 UV 成交转化率：来淘宝搜索的 UV，最终通过搜索结果成交的用户占比。<br>IPV-UV 转化率：来淘宝搜索的 UV，有多少比例的用户点击了搜索结果<br>CTR：搜索产生的点击占搜索产生的 PV 的比例<br>客单价：每个成交用户在淘宝搜索上产生成交的平均价格<br>基尼系数：基尼系数是一个经济学名词，考量社会财富的集中度；如果社会财富集中到很少一部分富人手中的时候，基尼系数就会增大，社会的稳定性和可持续发展性就会出现问题；淘宝搜索借用了这个概念来衡量搜索带给卖家的 PV 展示，和点击的集中度，在保证用户体验的前提下，给更多的优质或小小而美的卖家展示的机会。<br>大部分时候我们都有好几个模型和功能在线上测试，我们用 BTS 的方式来观察测试的情况，如果提升稳定就逐渐开放给所有用户，如果没有提升，我们也能从中获得经验帮助我们更好的理解用户。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>知识点面试</tag>
      </tags>
  </entry>
</search>
